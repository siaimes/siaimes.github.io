<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Openpai v1.6.0部署总结</title>
      <link href="2021/06/07/p57.html"/>
      <url>2021/06/07/p57.html</url>
      
        <content type="html"><![CDATA[<h1 id="前提条件">前提条件</h1><ol type="1"><li>集群内主机系统为Ubuntu 18.04 LTS server，且具有相同用户名和密码的管理员账户。</li></ol><p>Openpai项目文档建议用Ubuntu 16.04 LTS，但是我在Ubuntu 16.04 LTS遇到了很严重的<a href="https://github.com/microsoft/pai/issues/5316" target="_blank" rel="noopener">问题</a>，所以更新到Ubuntu 18.04。</p><p>master，worker必须为物理机器，dev-box可以是硬盘空间不少于40GB的虚拟机，毕竟他只有安装和维护系统的时候才用到，用物理机器太浪费了。</p><ol start="2" type="1"><li>一台境外VPS服务器以及域名（域名可选）。</li></ol><p><a href="/2020/11/12/p53.html">之前使用代理的方案</a>虽然可用，但是代理本身会给集群系统带来不确定因素，第二次部署选择了自己构建gcr.io镜像。</p><h1 id="初始化">初始化</h1><h2 id="所有机器">所有机器</h2><h3 id="切换清华源">切换清华源</h3><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><h3 id="更新依赖">更新依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装openssh-server">安装openssh-server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><h3 id="安装docker">安装docker</h3><p><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/ubuntu/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="variable">$(lsb_release -cs)</span> stable"</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>删除添加的docker源，因为安装Openpai的时候，Openpai的脚本会再添加一次docker源，会导致源冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure><h3 id="安装python">安装python</h3><p>按理说Ubuntu默认是有安装python的，但是我在实际操作的时候发现有的机器就是没有python，所以手动确认以下，以避免报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python</span><br></pre></td></tr></table></figure><h3 id="安装nfs客户端">安装nfs客户端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nfs-common</span><br></pre></td></tr></table></figure><h3 id="提前下载一些可能无法访问的文件到系统">提前下载一些可能无法访问的文件到系统</h3><p><a href="https://1drv.ms/u/s!AnaEV90wVhTQrs02CwLDQwVFjq_ZzA?e=jVGPoj" target="_blank" rel="noopener">https://1drv.ms/u/s!AnaEV90wVhTQrs02CwLDQwVFjq_ZzA?e=jVGPoj</a></p><p>访问密码是我的域名，其中4个文件是我使用代理从官方链接下载的，可放心享用。</p><p>将上述4个文件下载好放到<code>/tmp/releases/</code>文件夹，其中<code>calicoctl</code>、<code>hyperkube-v1.15.11-amd64</code>、<code>kubeadm-v1.15.11-adm64</code>需要赋予可执行权限，这样可避免大部分网络问题。</p><h2 id="master">master</h2><h3 id="安装ntp">安装ntp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ntp</span><br></pre></td></tr></table></figure><h2 id="worker">worker</h2><h3 id="安装gpu驱动">安装GPU驱动</h3><p><a href="https://launchpad.net/~graphics-drivers/+archive/ubuntu/ppa" target="_blank" rel="noopener">https://launchpad.net/~graphics-drivers/+archive/ubuntu/ppa</a></p><p><a href="https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-check-whether-the-gpu-driver-is-installed" target="_blank" rel="noopener">https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-check-whether-the-gpu-driver-is-installed</a></p><p><a href="https://howtoinstall.co/en/ubuntu/xenial/xserver-xorg?action=remove" target="_blank" rel="noopener">https://howtoinstall.co/en/ubuntu/xenial/xserver-xorg?action=remove</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nvidia-driver-465</span><br><span class="line">sudo apt autoremove xserver-xorg</span><br><span class="line">sudo apt autoremove --purge xserver-xorg</span><br></pre></td></tr></table></figure><h3 id="安装nvidia-container-runtime">安装nvidia-container-runtime</h3><p><a href="https://github.com/NVIDIA/nvidia-container-runtime#installation" target="_blank" rel="noopener">https://github.com/NVIDIA/nvidia-container-runtime#installation</a></p><p><a href="https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-install-nvidia-container-runtime" target="_blank" rel="noopener">https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-install-nvidia-container-runtime</a></p><p>先用这个命令<code>ping</code>一下<code>nvidia.github.io</code>看看返回的IP地址是否正常。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping nvidia.github.io</span><br></pre></td></tr></table></figure></p><p>我的网络环境这个域名已经被DNS污染了（DNS返回127.0.0.1），我的解决方案是在<code>/etc/hosts</code>文件中添加一行如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">185.199.110.153 nvidia.github.io</span><br></pre></td></tr></table></figure></p><p>然后继续安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | \</span><br><span class="line">  sudo apt-key add -</span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/<span class="variable">$distribution</span>/nvidia-container-runtime.list | \</span><br><span class="line">  sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nvidia-container-runtime</span><br><span class="line">sudo nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"default-runtime"</span>: <span class="string">"nvidia"</span>,</span><br><span class="line">  <span class="string">"runtimes"</span>: &#123;</span><br><span class="line">      <span class="string">"nvidia"</span>: &#123;</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/usr/bin/nvidia-container-runtime"</span>,</span><br><span class="line">          <span class="string">"runtimeArgs"</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="设置gpu常驻内存">设置GPU常驻内存</h3><p><a href="https://linuxeye.com/463.html" target="_blank" rel="noopener">https://linuxeye.com/463.html</a></p><p>设置GPU常驻内存，可将<code>nvidia-smi -pm 1</code>加入<code>/etc/rc.local</code>，重启生效，可解决GPU初始化缓慢、无任务运行但是利用率居高不下、偶尔丢卡等问题。</p><p>Ubuntu 18.04 LT的rc.local逻辑已经改变了，需要自己调整一下。</p><ol type="1"><li><code>/lib/systemd/system/rc-local.service</code>文件新增以下内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=rc-local.service</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>设置rc-local开机自启：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> rc-local</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>在<code>/etc/rc.local</code>中填入以下内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"></span><br><span class="line">nvidia-smi -pm 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>赋予可执行权限：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><h3 id="测试驱动是否正常">测试驱动是否正常</h3><ol type="1"><li>重启一下服务器。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>检查显卡驱动以及常驻内存是否生效</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>能正确返回信息即驱动安装成功，<code>Persistence-M</code>的状态为<code>On</code>，则常驻内存配置成功。</li></ol><p>检查<code>nvidia-container-runtime</code>是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run nvidia/cuda:10.0-base nvidia-smi</span><br></pre></td></tr></table></figure><h2 id="devbox">devbox</h2><h3 id="配置免密登录">配置免密登录</h3><ol type="1"><li>生成密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>向远程主机注册密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>测试是否可免密登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote_host</span><br></pre></td></tr></table></figure><h1 id="配置gcr.io镜像">配置gcr.io镜像。</h1><p><a href="/2021/05/12/p56.html">配置docker镜像</a>，需确保镜像服务器可以访问gcr.io。</p><p>下文假设你的镜像地址为：<code>your.gcr.mirror.addr</code>。</p><p>注意，如果是自签证书记得要按文章介绍配置每一台机器，如果是可信的证书，那么无需额外配置。</p><h1 id="开始安装">开始安装</h1><p>下面都在devbox中操作</p><p><a href="https://openpai.readthedocs.io/en/pai-1.6.y/manual/cluster-admin/installation-guide.html" target="_blank" rel="noopener">https://openpai.readthedocs.io/en/pai-1.6.y/manual/cluster-admin/installation-guide.html</a></p><h2 id="准备项目">准备项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/pai.git</span><br><span class="line"><span class="built_in">cd</span> pai</span><br><span class="line">git checkout pai-1.6.0</span><br></pre></td></tr></table></figure><h2 id="修改部分文件">修改部分文件</h2><p>修改理由在这里看：<a href="https://github.com/microsoft/pai/issues/5445" target="_blank" rel="noopener">Problems of install v1.6.0</a></p><ol type="1"><li>注释掉<a href="https://github.com/microsoft/pai/blob/b18ec56fd4cc089e681891825a01c2ee966c4d4b/contrib/kubespray/quick-start-kubespray.sh#L60" target="_blank" rel="noopener">这一行</a>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i <span class="variable">$&#123;HOME&#125;</span>/pai-deploy/cluster-cfg/hosts.yml docker-cache-config-distribute.yml || <span class="built_in">exit</span> $?</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>注释掉<a href="https://github.com/microsoft/pai/blob/b18ec56fd4cc089e681891825a01c2ee966c4d4b/contrib/kubespray/script/environment.sh#L50" target="_blank" rel="noopener">这一行</a>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 -m pip install ansible==2.9.7</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>将<a href="https://github.com/microsoft/pai/blob/b18ec56fd4cc089e681891825a01c2ee966c4d4b/contrib/kubespray/script/kubernetes-boot.sh#L8" target="_blank" rel="noopener">这一行</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i inventory/pai/hosts.yml -e <span class="string">"ansible_python_interpreter=/usr/bin/python3"</span> cluster.yml --become --become-user=root -e <span class="string">"@inventory/pai/openpai.yml"</span> || <span class="built_in">exit</span> $?</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i inventory/pai/hosts.yml -e <span class="string">"ansible_python_interpreter=/usr/bin/python2"</span> cluster.yml --become --become-user=root -e <span class="string">"@inventory/pai/openpai.yml"</span> || <span class="built_in">exit</span> $?</span><br></pre></td></tr></table></figure><h2 id="编写参数文件">编写参数文件</h2><p>参考项目文档编写<code>layout.yaml</code>文件。</p><p>参考下面的格式编写<code>config.yaml</code>文件，其中<code>your.gcr.mirror.addr</code>替换为你的gcr镜像地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">user: &lt;your-ssh-username&gt;</span><br><span class="line">password: &lt;your-ssh-password&gt;</span><br><span class="line">docker_image_tag: v1.6.0</span><br><span class="line"></span><br><span class="line">gcr_image_repo: <span class="string">"your.gcr.mirror.addr"</span></span><br><span class="line">kube_image_repo: <span class="string">"your.gcr.mirror.addr/google-containers"</span></span><br><span class="line"> </span><br><span class="line">openpai_kubespray_extra_var:</span><br><span class="line">  pod_infra_image_repo: <span class="string">"your.gcr.mirror.addr/google_containers/pause-&#123;&#123; image_arch &#125;&#125;"</span></span><br><span class="line">  dnsautoscaler_image_repo: <span class="string">"your.gcr.mirror.addr/google_containers/cluster-proportional-autoscaler-&#123;&#123; image_arch &#125;&#125;"</span></span><br><span class="line">  tiller_image_repo: <span class="string">"your.gcr.mirror.addr/kubernetes-helm/tiller"</span></span><br><span class="line">  registry_proxy_image_repo: <span class="string">"your.gcr.mirror.addr/google_containers/kube-registry-proxy"</span></span><br><span class="line">  metrics_server_image_repo: <span class="string">"your.gcr.mirror.addr/google_containers/metrics-server-amd64"</span></span><br><span class="line">  addon_resizer_image_repo: <span class="string">"your.gcr.mirror.addr/google_containers/addon-resizer"</span></span><br><span class="line">  dashboard_image_repo: <span class="string">"your.gcr.mirror.addr/google_containers/kubernetes-dashboard-&#123;&#123; image_arch &#125;&#125;"</span></span><br></pre></td></tr></table></figure><h2 id="安装">安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> contrib/kubespray</span><br><span class="line">/bin/bash quick-start-kubespray.sh</span><br><span class="line">/bin/bash quick-start-service.sh</span><br></pre></td></tr></table></figure><p>如果卡在下载文件的地方，那么需要再次确认<code>/tmp/releases</code>文件夹下相关文件是否都存在，且赋予相应权限。这几个文件有可能会被<code>quick-start-kubespray.sh</code>脚本删除，目前还没空看源码，我是重新再拷贝一次就可以了，等有时间看看为什么再优化。</p><h2 id="重启服务注意事项">重启服务注意事项</h2><p><a href="https://github.com/microsoft/pai/issues/5465" target="_blank" rel="noopener">https://github.com/microsoft/pai/issues/5465</a></p><p><a href="https://github.com/microsoft/pai/blob/master/docs/manual/cluster-admin/basic-management-operations.md" target="_blank" rel="noopener">项目文档</a>说管理集群要使用/pai/paictl.py，但是该文件默认checkout的是最终版本而非当前版本，所以会导致版本不一致问题。</p><p>如果要使用这个脚本的话，每次启动容器都要手动checkout一下，否则可能导致服务无法正常启动。</p><p>解决方案是将本地checkout好的项目挂载到容器里面然后直接用那里面的paictl.py。</p><h1 id="后续">后续</h1><p>成功启动service之后，其他个性化配置过程一般不会有问题，除非配置文件写错了，务必检查清楚。</p>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> microsoft </tag>
            
            <tag> openpai </tag>
            
            <tag> Ubuntu 16.04 </tag>
            
            <tag> PyCharm </tag>
            
            <tag> vs code </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置Docker镜像</title>
      <link href="2021/05/12/p56.html"/>
      <url>2021/05/12/p56.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>用于配置docker镜像的脚本，启用ssl保证安全性，兼容有无域名、兼容局域网或Internet网部署等情况。</p><h1 id="服务端配置">服务端配置</h1><h2 id="安装docker和docker-compose">安装docker和docker-compose</h2><p><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/ubuntu/</a></p><p><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></p><h2 id="克隆项目">克隆项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/siaimes/docker-cache.git</span><br><span class="line"><span class="built_in">cd</span> docker-cache</span><br></pre></td></tr></table></figure><h2 id="生成证书">生成证书</h2><p>生成证书，其中第二个参数为1表示生成域名证书，其他值会生成IP证书，以自己条件确定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ssl</span><br><span class="line">chmod +x get_ssl.sh</span><br><span class="line">./get_ssl.sh your_server_ip_or_domain 0</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>如果端口有开放互联网访问，可以申请Let's Encrypt证书，或者配合Nginx部署更多的服务，这里就不展开了。</p><h2 id="启动服务">启动服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano docker-compose</span><br></pre></td></tr></table></figure><p>其中，修改<code>your_server_ip_or_domain</code>为你的服务器IP或域名，修改<code>0.0.0.0:5000:5000</code>中第一个<code>5000</code>为你宿主机可用端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x *.sh</span><br><span class="line">./start.sh</span><br></pre></td></tr></table></figure><p>如果你镜像的不是dockerhub，例如gcr.io，那么将 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- PROXY_REMOTE_URL=https://registry-1.docker.io</span><br></pre></td></tr></table></figure></p><p>改为 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- PROXY_REMOTE_URL=https://gcr.io</span><br></pre></td></tr></table></figure></p><h1 id="客户端配置">客户端配置</h1><h2 id="克隆项目-1">克隆项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/siaimes/docker-cache.git</span><br><span class="line"><span class="built_in">cd</span> docker-cache</span><br></pre></td></tr></table></figure><h2 id="获取证书">获取证书</h2><p>如果是可信的证书，例如Let's Encrypt签发的证书，那么无需这一步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./get_docker_cache_ssl.sh your_server_ip_or_domain port username /path/to/ssl</span><br></pre></td></tr></table></figure><p>如果服务器限制密码登录，用脚本拷贝证书到客户端可能会遇到问题。</p><p>我们可以自己参考<code>get_docker_cache_ssl.sh</code>配置客户端：</p><p>这里如果port是443可以省略，后面也是如此。</p><ol type="1"><li>创建文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker/certs.d/your_server_ip_or_domain:port/</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>输出服务端的证书并拷贝到剪切板</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./ssl/your_server_ip_or_domain.crt</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>在客户端创建证书文件并粘贴服务端证书内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/docker/certs.d/your_server_ip_or_domain:port/your_server_ip_or_domain.crt</span><br></pre></td></tr></table></figure><h2 id="测试服务">测试服务</h2><p>如果镜像的是dockerhub，可以用下述命令测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull your_server_ip_or_domain:port/library/ubuntu</span><br></pre></td></tr></table></figure><p>注意到拉取官方镜像的时候需要加上<code>library</code>，否则<code>Error response from daemon: manifest for ubuntu:latest not found</code>。</p><p>如果镜像的是gcr.io，可以用下述命令测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull your_server_ip_or_domain:port/google-containers/kube-apiserver:v1.15.11</span><br></pre></td></tr></table></figure><h2 id="固化配置">固化配置</h2><p>如果是镜像dockerhub才可以做这一步，如果镜像的是其它仓库，请忽略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"registry-mirrors"</span>: [<span class="string">"https://your_server_ip_or_domain:port"</span>]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi your_server_ip_or_domain:port/library/ubuntu</span><br><span class="line">sudo docker pull ubuntu</span><br></pre></td></tr></table></figure><h1 id="参考连接">参考连接</h1><p><a href="https://openpai.readthedocs.io/en/latest/manual/cluster-admin/basic-management-operations.html" target="_blank" rel="noopener">How To Set Up HTTPS</a></p><p><a href="https://blog.csdn.net/min19900718/article/details/87920254" target="_blank" rel="noopener">x509: cannot validate certificate for 10.30.0.163 because it doesn't contain any IP SANs</a></p><p><a href="https://www.huaweicloud.com/articles/5fa5f84d8308590fcaa949d5dd5d9a04.html" target="_blank" rel="noopener">私有安全docker registry授权访问实验</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> docker </tag>
            
            <tag> gcr.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-Compose导致ssh连接断开的问题</title>
      <link href="2021/04/29/p55.html"/>
      <url>2021/04/29/p55.html</url>
      
        <content type="html"><![CDATA[<p>一般情况下，使用docker-compose不会出现网络问题，但是我遭遇的这个情况比较特殊，故记录之。</p><p>我遭遇的情况是：通过172.17.0.0网段的客户端访问具有Internet地址的ssh服务器，此情况使用docker或docker-compose都会导致ssh连接断开。这种情况常见于单位内部使用172.17.0.0网段的私有地址部署局域网，管理员通过ssh管理本单位的Internet服务器的时候。</p><h1 id="安装docker导致ssh断开连接">安装docker导致ssh断开连接</h1><p>其原因为docker安装完成时，立刻生成docker0网桥。由于ssh服务器是Internet地址，故docker认为默认的网段<code>172.17.0.0/16</code>不会与宿主机冲突，所以分配给docker0网桥的地址是<code>172.17.0.1</code>。然而，因为局域网主机全是<code>172.17.0.0/16</code>，故从该服务器到局域网的所有流量均会被发送到docker0，导致ssh断开连接。</p><p>这个问题比较容易定位，解决方案也很直观。打开<code>/lib/systemd/system/docker.service</code>，在<code>ExecStart=...</code>这一行末尾添加<code>--bip "172.18.0.1/16"</code>然后运行下面的命令重启docker即可： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload </span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><h1 id="使用docker-compose启动容器时导致ssh断开连接">使用docker-compose启动容器时导致ssh断开连接</h1><p>其原因为使用docker-compose启动一组容器会共用一个全新的网桥，docker-compose也认为默认的网段<code>172.17.0.0/16</code>不会与宿主机冲突，且docker0居然不用，所以不用白不用，所以你懂的，于是ssh挂了！</p><p>解决方案：添加一条到局域网的路由，这等于报告docker和docker-compose<code>172.17.0.0/16</code>这个网段已经有用了，你两悠着点。</p><p>首先使用<code>route</code>命令查看默认网关，一般是与主机IP地址同网段的xxx.xxx.xxx.254这个地址。</p><p>然后使用如下命令添加一条路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add -net 172.17.0.0 netmask 255.255.0.0 gw &lt;默认网关&gt;</span><br></pre></td></tr></table></figure><p>现在在使用docker-compose就不会导致ssh断开连接了。</p><h1 id="合并两个问题">合并两个问题</h1><p>其实只要我们添加了这一条路由，那么也就不用在<code>/lib/systemd/system/docker.service</code>，中添加<code>--bip "172.18.0.1/16"</code>了。</p><h1 id="固化配置">固化配置</h1><p>若上述测试没有问题了，那么将命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add -net 172.17.0.0 netmask 255.255.0.0 gw &lt;默认网关&gt;</span><br></pre></td></tr></table></figure></p><p>写入<code>/etc/rc.local</code>即可永远生效。</p><h1 id="参考连接">参考连接</h1><p><a href="https://stackoverflow.com/questions/41736187/docker-compose-network-creation-kicks-me-out-of-ssh" target="_blank" rel="noopener">docker-compose network creation kicks me out of ssh</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> docker </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决使用容器部署NFS服务器无法限制客户端IP问题</title>
      <link href="2021/01/01/p54.html"/>
      <url>2021/01/01/p54.html</url>
      
        <content type="html"><![CDATA[<p><a href="/2020/11/12/p53.html">部署Openpai</a>后，我使用了<a href="https://hub.docker.com/r/itsthenetwork/nfs-server-alpine" target="_blank" rel="noopener">nfs-server-alpine</a>镜像为深度学习环境搭建数据存储服务。不使用<a href="https://openpai.readthedocs.io/en/latest/manual/cluster-admin/how-to-set-up-storage.html" target="_blank" rel="noopener">Openpai的storage-manager</a>的原因是，当需要升级Openpai时，storage-manager也会一并关闭升级，这就导致所有运行中的服务由于IO错误而被迫中断。另一方面，考虑到数据存储服务与Openpai耦合性也没那么高，完全可以自己部署。</p><p>但是这样部署存在的问题是，<a href="https://hub.docker.com/r/itsthenetwork/nfs-server-alpine" target="_blank" rel="noopener">nfs-server-alpine</a>直接将共享目录暴露于<code>IP:/</code>下。那么，只要黑客使用nfs挂载命令扫描到你的IP，那么你的所有数据均暴露无疑。</p><p>刚开始的时候直接使用<a href="https://hub.docker.com/r/itsthenetwork/nfs-server-alpine" target="_blank" rel="noopener">nfs-server-alpine</a>介绍里面的方法限制客户端IP，但是发现，除了使用'*'以外，使用其他配置，客户端都无法挂载。</p><p><strong><em>思考：</em></strong>在保证nfs服务器没问题的情况下，客户端IP又在共享列表中，但是却无法挂载。那么可能的原因是，是否客户端到服务器的链路中存在NAT转换，导致实际到达服务器的IP已经不是客户端的IP了。</p><p><strong><em>启发：</em></strong>我的所有节点都在同一个网段中，本身不存在NAT。那另一个存在NAT的地方也只有docker了。</p><p><strong><em>问题：</em></strong>客户端到服务器的链路是正确的，但是服务器接收到客户端的请求后将请求提交给容器时使用NAT转换。</p><p><strong><em>解决方案：</em></strong>nfs容器使用主机网络(host network)可去除NAT转换。</p><p>最后docker-compose.yml配置文件如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># https://hub.docker.com/r/itsthenetwork/nfs-server-alpine</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">itsthenetwork/nfs-server-alpine:12</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nfs</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SHARED_DIRECTORY=/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PERMITTED=192.168.1.0\/255.255.255.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/local/data:/data</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openpai v1.3.0部署总结</title>
      <link href="2020/11/12/p53.html"/>
      <url>2020/11/12/p53.html</url>
      
        <content type="html"><![CDATA[<h1 id="前提条件">前提条件</h1><ol type="1"><li><p>集群内主机系统为Ubuntu 16.04 LST，且具有相同用户名和密码的管理员账户。</p></li><li><p>每一台机器的代理软件监听地址为<a href="http://127.0.0.1:8118" target="_blank" rel="noopener">http://127.0.0.1:8118</a>，自己部署，不在本文范围以内。</p></li></ol><h1 id="初始化">初始化</h1><h2 id="所有机器">所有机器</h2><h3 id="切换清华源">切换清华源</h3><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><h3 id="更新依赖">更新依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装openssh-server">安装openssh-server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><h3 id="安装docker">安装docker</h3><p><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/ubuntu/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove docker docker-engine docker.io containerd runc</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">sudo nano /etc/apt/sources.list.d/download_docker_com_linux_ubuntu.list</span><br></pre></td></tr></table></figure><p>这里不按照上面官网提供的方法做的原因是pai是这样操作的，否则会导致源重复，apt update会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb https://download.docker.com/linux/ubuntu xenial stable</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --remove-architecture i386</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="安装python">安装python</h3><p>按理说Ubuntu默认是有安装python的，但是我在实际操作的时候发现有的机器就是没有python，所以手动确认以下，以避免报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python</span><br></pre></td></tr></table></figure><h2 id="master">master</h2><h3 id="安装ntp">安装ntp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ntp</span><br></pre></td></tr></table></figure><h2 id="worker">worker</h2><h3 id="安装gpu驱动">安装GPU驱动</h3><p><a href="https://launchpad.net/~graphics-drivers/+archive/ubuntu/ppa" target="_blank" rel="noopener">https://launchpad.net/~graphics-drivers/+archive/ubuntu/ppa</a></p><p><a href="https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-check-whether-the-gpu-driver-is-installed" target="_blank" rel="noopener">https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-check-whether-the-gpu-driver-is-installed</a></p><p><a href="https://howtoinstall.co/en/ubuntu/xenial/xserver-xorg?action=remove" target="_blank" rel="noopener">https://howtoinstall.co/en/ubuntu/xenial/xserver-xorg?action=remove</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nvidia-430</span><br><span class="line">sudo apt autoremove xserver-xorg</span><br><span class="line">sudo apt autoremove --purge xserver-xorg</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="安装nvidia-container-runtime">安装nvidia-container-runtime</h3><p><a href="https://github.com/NVIDIA/nvidia-container-runtime#installation" target="_blank" rel="noopener">https://github.com/NVIDIA/nvidia-container-runtime#installation</a></p><p><a href="https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-install-nvidia-container-runtime" target="_blank" rel="noopener">https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-faqs-and-troubleshooting.html#how-to-install-nvidia-container-runtime</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | \</span><br><span class="line">  sudo apt-key add -</span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/<span class="variable">$distribution</span>/nvidia-container-runtime.list | \</span><br><span class="line">  sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nvidia-container-runtime</span><br><span class="line">sudo nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"default-runtime"</span>: <span class="string">"nvidia"</span>,</span><br><span class="line">  <span class="string">"runtimes"</span>: &#123;</span><br><span class="line">      <span class="string">"nvidia"</span>: &#123;</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/usr/bin/nvidia-container-runtime"</span>,</span><br><span class="line">          <span class="string">"runtimeArgs"</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="测试驱动是否正常">测试驱动是否正常</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run nvidia/cuda:10.0-base nvidia-smi</span><br></pre></td></tr></table></figure><h3 id="设置gpu常驻内存">设置GPU常驻内存</h3><p>运行此命令设置GPU常驻内存，可解决GPU启动缓慢、无任务运行但是利用率居高不下、偶尔丢卡等问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nvidia-smi -pm 1</span><br></pre></td></tr></table></figure><p>上述命令系统重启之后会失效，要在系统层面生效可将<code>nvidia-smi -pm 1</code>加入<code>/etc/rc.local</code>，注意要放在<code>exit 0</code>之前。</p><h2 id="devbox">devbox</h2><h3 id="配置免密登录">配置免密登录</h3><ol type="1"><li>生成密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>向远程主机注册密钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>测试是否可免密登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote_host</span><br></pre></td></tr></table></figure><h1 id="启动代理">启动代理</h1><p>集群中的机器由于需要拉取gcr.io的镜像，这在国内是无法访问的，故需要配置docker代理（openpai官网给的镜像已不可用）。devbox机器要下载pai的源码，如果访问github速度慢的话，可配置代理。</p><h2 id="启动docker代理">启动docker代理</h2><p><a href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy" target="_blank" rel="noopener">https://docs.docker.com/config/daemon/systemd/#httphttps-proxy</a></p><p>这是docker命令用的代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo nano /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://127.0.0.1:8118"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://127.0.0.1:8118"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull gcr.io/google-containers/kube-apiserver:v1.15.11</span><br></pre></td></tr></table></figure><h2 id="启动git代理">启动git代理</h2><p>启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:8118</span><br><span class="line">git config --global https.proxy http://127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>关闭命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></table></figure><h1 id="开始安装">开始安装</h1><p>下面都在devbox中操作</p><p><a href="https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-guide.html#_4" target="_blank" rel="noopener">https://openpai.readthedocs.io/zh_CN/latest/manual/cluster-admin/installation-guide.html#_4</a></p><h2 id="编写参数文件">编写参数文件</h2><p>参考上面格式直接在家目录建立三个文件，分别为<code>master.csv</code>，<code>worker.csv</code>，<code>config</code>。</p><p>由于已经使用了代理，故不再使用官方文档里面的gcr.io镜像！所以我们只需要下面这个简单的配置文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user: &lt;your-ssh-username&gt;</span><br><span class="line">password: &lt;your-ssh-password&gt;</span><br><span class="line">branch_name: pai-1.3.y</span><br><span class="line">docker_image_tag: v1.3.0</span><br><span class="line"></span><br><span class="line">kubeadm_download_url: <span class="string">"https://shaiictestblob01.blob.core.chinacloudapi.cn/share-all/kubeadm"</span></span><br><span class="line">hyperkube_download_url: <span class="string">"https://shaiictestblob01.blob.core.chinacloudapi.cn/share-all/hyperkube"</span></span><br></pre></td></tr></table></figure><h2 id="按步骤运行">按步骤运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/pai.git</span><br><span class="line"><span class="built_in">cd</span> pai</span><br><span class="line">git checkout pai-1.3.y</span><br><span class="line"><span class="built_in">cd</span> contrib/kubespray</span><br><span class="line">/bin/bash quick-start-kubespray.sh -m ~/master.csv -w ~/worker.csv -c ~/config</span><br><span class="line">/bin/bash quick-start-service.sh -m ~/master.csv -w ~/worker.csv -c ~/config</span><br></pre></td></tr></table></figure><h1 id="后续">后续</h1><p>成功启动service之后，除了安装MarketPlace插件以外，其他个性化配置过程一般不会有问题，除非配置文件写错了。</p><h2 id="marketplace配置">MarketPlace配置</h2><p><a href="https://github.com/siaimes/openpaimarketplace" target="_blank" rel="noopener">https://github.com/siaimes/openpaimarketplace</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> microsoft </tag>
            
            <tag> openpai </tag>
            
            <tag> Ubuntu 16.04 </tag>
            
            <tag> PyCharm </tag>
            
            <tag> vs code </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速Snap</title>
      <link href="2020/10/26/p52.html"/>
      <url>2020/10/26/p52.html</url>
      
        <content type="html"><![CDATA[<p>在国内使用snap安装软件包速度异常的慢，而且没有国内的镜像可用，这导致安装PyCharm等在snap上发布的软件包异常的慢，所以需要为snap配置代理。命令为： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo snap <span class="built_in">set</span> system proxy.http=<span class="string">"http://&lt;proxy_addr&gt;:&lt;proxy_port&gt;"</span></span><br><span class="line">sudo snap <span class="built_in">set</span> system proxy.https=<span class="string">"http://&lt;proxy_addr&gt;:&lt;proxy_port&gt;"</span></span><br></pre></td></tr></table></figure></p><p>上述命令有效的前提是有<code>http</code>代理服务正在监听<code>&lt;proxy_addr&gt;:&lt;proxy_port&gt;</code>，至于如何配置<code>http</code>代理不在本文讨论的范围之内。</p><p>然后就可以使用snap命令愉快的安装PyCharm了： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install pycharm-community --classic</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://askubuntu.com/questions/764610/how-to-install-snap-packages-behind-web-proxy-on-ubuntu-16-04" target="_blank" rel="noopener">How to install snap packages behind web proxy on Ubuntu 16.04</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu 16.04 </tag>
            
            <tag> PyCharm </tag>
            
            <tag> snap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文解决深度学习环境问题</title>
      <link href="2020/10/07/p51.html"/>
      <url>2020/10/07/p51.html</url>
      
        <content type="html"><![CDATA[<p>之前的文章<a href="/2020/08/31/p49.html">Ubuntu 16.04安装tensorflow运行环境</a>给出了一个使用conda管理深度学习环境的方案，实际操作起来比NVIDIA官网，TensorFlow官网等的解决方案都更加容易上手，且不易出错。但是在使用的时候会发现存在一个问题，导致该方案无法直接推广到需要NVCC编译器的项目。其原因在于，conda源中维护的cudatoolkit版本为NVIDIA官方提供的cuda版本的一个子集，即不包含编译器的版本。通过谷歌搜索与自己动手实践，现已解决该问题，故记录于此，以备不时之需。解决方案是，使用conda-forge维护的cudatoolkit-dev软件包，这个软件包是完整的cuda工具箱。PyTorch和TensorFlow都会默认依赖cudatoolkit，这就会导致cudatoolkit和cudatoolkit-dev同时存在。但是，目前我没发现这会导致冲突，故无需处理。</p><p>本文所有实验基于Ubuntu 16.04 Desktop，如需推广到其他系统，只需按对应系统安装好显卡驱动和Anaconda，后续虚环境配置过程理论上没有区别。</p><h1 id="关闭自动更新并主动更新系统依赖">关闭自动更新并主动更新系统依赖</h1><p>Ubuntu自动更新软件在后台运行的时候会导致终端中很多命令无法使用，故新系统建议关闭自动更新。设置方法为在<code>Software &amp; Updates</code>中定位到<code>Updates</code>，将<code>Automatically check for updates</code>和<code>Notify me of a new Ubuntu version</code>设置为<code>Never</code>，如图所示。 <img src="/2020/08/30/p48/NeverUpdates.png" alt="关闭自动更新"></p><p>主动更新依赖命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h1 id="添加ppa源">添加ppa源</h1><p>Ubuntu 16.4官方源的驱动版本已经过时，不支持CUDA 10.0，好在NVIDIA为Ubuntu 16.04提供了ppa源，其中有支持CUDA 10.0的显卡驱动可用。命令如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></p><h1 id="安装显卡驱动">安装显卡驱动</h1><p>去NVIDIA官网下载的显卡驱动，可能对应系统没有对应版本的release而导致需要编译安装，但是编译往往会报错，是一个不可取的方案。本文使用ppa源安装显卡驱动，这样可以完全避免安装驱动导致的各种奇怪问题。</p><p>在<code>Software &amp; Updates</code>中定位到<code>Additional Drivers</code>，选择最新版本的NVIDIA binary driver，然后<code>Apply Changes</code>。等待安装完成之后<code>reboot</code>即可，如图所示。 <img src="/2020/08/30/p48/AdditionalDrivers.png" alt="Additional Drivers"></p><p>这里有一个知识点需要注意，显卡驱动和cuda版本不必要一一对应，但是由于cuda是依赖于显卡驱动的，所以显卡驱动版本不能低于cuda要求的最低版本。安装完成显卡驱动之后，使用<code>nvidia-smi</code>命令输出的cuda版本为该驱动支持的最高cuda版本，但是更低版本的cuda也是可以支持的。基于以上分析，我们直接安装最新版本的驱动即可。</p><h1 id="安装anaconda">安装anaconda</h1><p>参考Anaconda官网<a href="https://docs.anaconda.com/anaconda/install/linux/" target="_blank" rel="noopener">安装指南</a>安装即可。</p><h1 id="切换清华源">切换清华源</h1><p>务必将conda源切换为清华源，否则由于网络问题导致的各种错误会让你怀疑人生。配置方法直接参考清华大学开源软件镜像站提供的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">Anaconda 镜像使用帮助</a>。也可以顺便把pip源也切换了<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">pypi 镜像使用帮助</a>。</p><h1 id="配置虚环境">配置虚环境</h1><p>本文提供3个实例供参考，TensorFlow版本与CUDA之间的对应关系可在<a href="https://www.tensorflow.org/install/source#common_installation_problems" target="_blank" rel="noopener">这里</a>找到，PyTorch不同版本安装命令可在<a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">这里</a>或<a href="https://pytorch.org/get-started/previous-versions/" target="_blank" rel="noopener">这里</a>找到，安装命令已经体现了PyTorch版本与CUDA之间的对应关系。注意安装cudatoolkit-dev时需要去NVIDIA官网下载相关文件，故会在Executing transction停留很久，需要耐心等待。</p><p>安装其他版本的环境的时候需要自己确认是否有对应版本的release，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda search tensorflow</span><br><span class="line">conda search -c pytorch pytorch</span><br><span class="line">conda search -c conda-forge cudatoolkit-dev</span><br></pre></td></tr></table></figure><h2 id="tensorflow-1.13.1">tensorflow 1.13.1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda create --name tensorflow_1_13_1 python=3.6</span><br><span class="line">conda activate tensorflow_1_13_1</span><br><span class="line">conda install numpy=1.16.4</span><br><span class="line">conda install tensorflow-gpu=1.13.1</span><br><span class="line">conda install conda</span><br><span class="line">conda install -c conda-forge cudatoolkit-dev=10.0</span><br><span class="line">cat /home/usrname/anaconda3/envs/tensorflow_1_13_1/include/cudnn.h | grep CUDNN_MAJOR</span><br><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><h2 id="tensorflow-2.1.0">tensorflow 2.1.0</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda create --name tensorflow_2_1_0 python=3.6</span><br><span class="line">conda activate tensorflow_2_1_0</span><br><span class="line">conda install tensorflow-gpu=2.1.0</span><br><span class="line">conda install conda</span><br><span class="line">conda install -c conda-forge cudatoolkit-dev=10.1</span><br><span class="line">cat /home/usrname/anaconda3/envs/tensorflow_2_1_0/include/cudnn.h | grep CUDNN_MAJOR</span><br><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><h2 id="pytorch-1.6.0">pytorch 1.6.0</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pytorch_1_6_0 python=3.6</span><br><span class="line">conda activate pytorch_1_6_0</span><br><span class="line">conda install pytorch torchvision cudatoolkit=10.1 -c pytorch</span><br><span class="line">conda install conda</span><br><span class="line">conda install -c conda-forge cudatoolkit-dev=10.1</span><br><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><h1 id="使用虚环境">使用虚环境</h1><p>如果要使用命令行运行代码，那么在运行代码之前使用<code>conda activate envname</code>命令激活对应的虚环境即可。</p><p>如果在PyCharm中运行代码，那么在<code>File&gt;&gt;Settings&gt;&gt;Project: project name&gt;&gt;Python Interpreter</code>指定对应的虚环境即可。</p><p>如需安装其他包，可在激活环境之后使用<code>conda install packagename</code>来安装，也可以使用PyCharm环境管理器安装。若需要安装pip包，也可在激活环境之后直接使用<code>pip install packagename</code>安装，也会安装到对应虚环境内部。</p>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu 16.04 </tag>
            
            <tag> Anaconda </tag>
            
            <tag> NVIDIA </tag>
            
            <tag> driver </tag>
            
            <tag> CUDA </tag>
            
            <tag> cuDNN </tag>
            
            <tag> tensorflow </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨终端共享键鼠解决方案</title>
      <link href="2020/09/16/p50.html"/>
      <url>2020/09/16/p50.html</url>
      
        <content type="html"><![CDATA[<h1 id="软件安装">软件安装</h1><h2 id="windows">Windows</h2><ol type="1"><li><p>直接去<a href="https://github.com/debauchee/barrier/releases" target="_blank" rel="noopener">barrier releases page</a>下载BarrierSetup-x.x.x-release.exe并安装。</p></li><li><p>按照官方<a href="https://github.com/debauchee/barrier/wiki/Adding-Barrier-to-the-Windows-Firewall" target="_blank" rel="noopener">Wifi</a>指引配置好防火墙。</p></li></ol><h2 id="ubuntu-16.04">Ubuntu 16.04</h2><p>可直接在<code>Ubuntu Software</code>中搜索barrier进行安装，或运行如下命令也可安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install barrier</span><br></pre></td></tr></table></figure><h1 id="软件配置">软件配置</h1><p>启动的时候注意选择运行模式，共享键鼠的设备作为服务端，而接收其他设备共享的键鼠的设备作为客户端。</p><h2 id="服务端">服务端</h2><p>勾选Server，点击<code>设置服务端···</code>按钮，按指引添加一个屏幕，注意名称要和客户端显示的屏幕名一致，为了便于记忆，可以设置一个别名。配置好之后即可退出。待客户端完成配置之后点击开始按钮即可。</p><h2 id="客户端">客户端</h2><p>勾选Client，去掉Auto config选项，服务端IP输入Barrier服务端显示的IP，点击开始。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 键鼠共享 </tag>
            
            <tag> Barrier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 16.04安装tensorflow运行环境</title>
      <link href="2020/08/31/p49.html"/>
      <url>2020/08/31/p49.html</url>
      
        <content type="html"><![CDATA[<p><a href="/2020/08/30/p48.html">上一篇博文</a>本来是为这篇博文做铺垫的，但是真正在安装tensorflow的时候，却发现因为有Anaconda和PyCharm的存在，其实不需要手动安装CUDA和cuDNN，且Python包的管理也简化了，故在此记录一下。</p><h1 id="关闭自动更新并主动更新系统依赖">关闭自动更新并主动更新系统依赖</h1><p>Ubuntu自动更新软件在后台运行的时候会导致终端中很多命令无法使用，故新系统建议关闭自动更新。设置方法为在<code>Software &amp; Updates</code>中定位到Updates，将<code>Automatically check for updates</code>和<code>Notify me of a new Ubuntu version</code>设置为<code>Never</code>，如图所示。 <img src="/2020/08/30/p48/NeverUpdates.png" alt="关闭自动更新"></p><p>主动更新依赖命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure></p><h1 id="添加ppa源">添加ppa源</h1><p>Ubuntu 16.4官方源的驱动版本已经过时，不支持CUDA 10.0，好在NVIDIA为Ubuntu 16.04提供了ppa源，其中有支持CUDA 10.0的显卡驱动可用。命令如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></p><h1 id="安装显卡驱动">安装显卡驱动</h1><p>在<code>Software &amp; Updates</code>中定位到<code>Additional Drivers</code>，选择最新版本的NVIDIA binary driver(至少不能低于CUDA文件包含的版本号，后文会有)，然后<code>Apply Changes</code>。等待安装完成之后<code>reboot</code>即可，如图所示。 <img src="/2020/08/30/p48/AdditionalDrivers.png" alt="Additional Drivers"></p><h1 id="安装anaconda">安装Anaconda</h1><p>参考Anaconda官网<a href="https://docs.anaconda.com/anaconda/install/linux/" target="_blank" rel="noopener">安装指南</a>安装即可。</p><h1 id="安装pycharm">安装PyCharm</h1><p>在<code>Ubuntu Software</code>中搜索<code>PyCharm</code>并安装<code>PyCharm CE</code>即可。</p><h1 id="使用pycharm管理python环境">使用PyCharm管理Python环境</h1><p>启动PyCharm，在创建项目的时候需要选择运行环境，PyCharm在这里提供了调用Conda的接口。在<code>New environment using Conda</code>那里选择目标Python版本，然后Create即可创建一个项目和Python环境，Python版本的选择与你自己目标tensorflow版本之间的关系参考<a href="https://www.tensorflow.org/install/source#common_installation_problems" target="_blank" rel="noopener">这里</a>。等待创建完成进入PyCharm之后，进入File&gt;&gt;Settings&gt;&gt;Project: project name&gt;&gt;Python Interpreter即可管理Python包。点击<code>+</code>并搜索<code>tensorflow-gpu</code>并安装即可，注意右下角可以选择特定的版本。通过此方法安装tensorflow不需要手动安装CUDA和cuDNN，Conda会自动安装相关依赖。</p><h1 id="测试">测试</h1><p>在刚才的项目中创建一个Python文件，添加来自tensorflow官网的<a href="https://www.tensorflow.org/tutorials/quickstart/beginner" target="_blank" rel="noopener">测试代码</a>并运行，查看输出是否有报错，是否有使用到CUDA等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.tensorflow.org/tutorials/quickstart/beginner</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line"></span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">  tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)),</span><br><span class="line">  tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">  tf.keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">  tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu 16.04 </tag>
            
            <tag> Anaconda </tag>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 16.04安装CUDA 10.0和cuDNN 7.6.5</title>
      <link href="2020/08/30/p48.html"/>
      <url>2020/08/30/p48.html</url>
      
        <content type="html"><![CDATA[<h1 id="关闭自动更新并主动更新系统依赖">关闭自动更新并主动更新系统依赖</h1><p>Ubuntu自动更新软件在后台运行的时候会导致终端中很多命令无法使用，故新系统建议关闭自动更新。设置方法为在<code>Software &amp; Updates</code>中定位到Updates，将<code>Automatically check for updates</code>和<code>Notify me of a new Ubuntu version</code>设置为<code>Never</code>，如图所示。 <img src="p48/NeverUpdates.png" alt="关闭自动更新"></p><p>主动更新依赖命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure></p><h1 id="添加ppa源">添加ppa源</h1><p>Ubuntu 16.4官方源的驱动版本已经过时，不支持CUDA 10.0，好在NVIDIA为Ubuntu 16.04提供了ppa源，其中有支持CUDA 10.0的显卡驱动可用。命令如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></p><h1 id="安装显卡驱动">安装显卡驱动</h1><p>在<code>Software &amp; Updates</code>中定位到<code>Additional Drivers</code>，选择最新版本的NVIDIA binary driver(至少不能低于CUDA文件包含的版本号，后文会有)，然后<code>Apply Changes</code>。等待安装完成之后<code>reboot</code>即可，如图所示。 <img src="p48/AdditionalDrivers.png" alt="Additional Drivers"></p><h1 id="安装cuda">安装CUDA</h1><h2 id="下载安装文件">下载安装文件</h2><p>打开CUDA 10.0下载页面：<a href="https://developer.nvidia.com/cuda-10.0-download-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-10.0-download-archive</a>。按下图所示选择对应系统，下载给出的两个<code>run</code>文件。 <img src="p48/CUDA_Toolkit_10.0.jpg" alt="CUDA Toolkit 10.0"></p><h2 id="安装">安装</h2><p>运行如下命令即可安装CUDA。<strong><em>注意不要安装显卡驱动，即当系统询问<code>Install NVIDIA Accelerated Graphics Driver for Linux?</code>的时候输入<code>no</code>。</em></strong>这里选择仅仅安装CUDA，只要系统中的驱动版本不低于CUDA要求的最低版本（CUDA文件名已包含最低要求版本），CUDA即可调用系统中的显卡驱动。这样做可避免不必要的运行报错。虽然可以通过init 3之后安装，但是重启之后却无法登入系统。这可能是CUDA自带的驱动没有针对相应系统做优化导致的，而ppa源中的驱动都是针对相应系统优化了的。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> Downloads</span><br><span class="line">chmod +x *.run</span><br><span class="line">sudo ./cuda_10.0.130_410.48_linux.run</span><br><span class="line">sudo ./cuda_10.0.130.1_linux.run</span><br></pre></td></tr></table></figure></p><p>运行上述命令，提示输入的时候输入如下图所示。 <img src="p48/NotSelectedDriver.png" alt="Not Selected Driver"></p><p>安装完成之后还要修改<code>PATH</code>，使得CUDA可以被调用。在<code>~/.bashrc</code>文件末尾加入如下两行代码并运行<code>source ~/.bashrc</code>即可。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-8.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-8.0/lib64</span><br></pre></td></tr></table></figure></p><h2 id="验证">验证</h2><p>运行如下命令，最后一行输出是<code>Result = PASS</code>即表示CUDA安装成功。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda-10.0/samples/1_Utilities/deviceQuery</span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure></p><h1 id="安装cudnn">安装cuDNN</h1><h2 id="下载安装文件-1">下载安装文件</h2><p>直接去官网下载对应系统的对应deb包安装即可: <a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">cudnn-archive</a>。 <img src="p48/cudnn-archive.jpg" alt="cudnn-archive"></p><h2 id="安装-1">安装</h2><p>进入Downloads文件夹，直接双击下载好的三个<code>deb</code>文件即可安装。</p><h2 id="验证-1">验证</h2><p>运行如下命令，最后一行输出是<code>Test passed!</code>即表示cuDNN安装成功。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -r /usr/src/cudnn_samples_v7/ <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/cudnn_samples_v7/mnistCUDNN</span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line">./mnistCUDNN</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><p><a href="https://launchpad.net/~graphics-drivers/+archive/ubuntu/ppa" target="_blank" rel="noopener">Proprietary GPU Drivers</a></p></li><li><p><a href="https://superuser.com/questions/1183200/cant-login-to-ubuntu-after-installing-cuda" target="_blank" rel="noopener">Can't login to Ubuntu after installing CUDA</a></p></li><li><p><a href="https://askubuntu.com/questions/799184/how-can-i-install-cuda-on-ubuntu-16-04" target="_blank" rel="noopener">How can I install CUDA on Ubuntu 16.04?</a></p></li><li><p><a href="https://medium.com/@kapilvarshney/how-to-setup-ubuntu-16-04-with-cuda-gpu-and-other-requirements-for-deep-learning-f547db75f227" target="_blank" rel="noopener">How to Setup Ubuntu 16.04 with CUDA, GPU, and other requirements for Deep Learning</a></p></li><li><p><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#verify" target="_blank" rel="noopener">Verifying The cuDNN Install On Linux</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu 16.04 </tag>
            
            <tag> CUDA </tag>
            
            <tag> cuDNN </tag>
            
            <tag> Desktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传公钥到服务器</title>
      <link href="2020/08/30/p47.html"/>
      <url>2020/08/30/p47.html</url>
      
        <content type="html"><![CDATA[<p>为了安全和方便，远程Linux系统可使用SSH Key访问。一般本地生成一组SSH Key备用，且无特殊情况不更换，换电脑也将系统文件夹<code>C:\Users\Username\.ssh</code>拷贝到新电脑即可。那么本地生成的SSH Key如何发送到服务器呢？很简单，登录服务器，将<code>.ssh</code>文件夹中<code>id_rsa.pub</code>文件内容拷贝到目标用户的<code>~/.ssh/authorized_keys</code>文件中且单独一行，保存并退出。使用<code>sudo systemctl restart sshd</code>重启SSH服务使得新添加的公钥生效，现在即可使用<code>username+id_rsa</code>组合登录服务器了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH Key </tag>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>台式机配置集成显卡输出，独立显卡计算</title>
      <link href="2020/08/29/p46.html"/>
      <url>2020/08/29/p46.html</url>
      
        <content type="html"><![CDATA[<p>安装了独立显卡的台式机一般默认使用独立显卡输出而禁用集成显卡。但是用于做计算的独立显卡大多没有VGA接口，这样就需要使用HDMI转VGA转接线。一方面，要是机器多了，转接头也是一笔开销。另一方面，用于计算的GPU同时用于显示输出或多或少都会浪费一些资源。按我自己的理解是，集成显卡和独立显卡是可以同时工作的，否则有多显卡服务器就不存在了。通过查资料和自己摸索，最终找到解决方案，现以联想台式机为例，记录如下。</p><p>首先将显示器与独立显卡链接，以点亮显示器。进入BIOS设置界面：开机狂按F12&gt;&gt;Enter Setup&gt;&gt;Devices&gt;&gt;Video Setup:</p><blockquote><p>Select Active Video [IGD]</p></blockquote><blockquote><p>Pre-Allocated Memory Size [1024MB]</p></blockquote><blockquote><p>Total Graphics Memory [Maximum]</p></blockquote><blockquote><p>Multi-Monitor Support [Enabled]</p></blockquote><p>保存并退出：Esc&gt;&gt;Exit&gt;&gt;Save Changes and Exit。现在将显示器与集成显卡链接，可以看到显示器已点亮。进入系统后，打开终端输入命令<code>nvidia-smi</code>可以看到显卡仍然在工作。至此，独立显卡与集成显卡同时工作配置已完成。</p>]]></content>
      
      
      <categories>
          
          <category> 电脑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> 独立显卡 </tag>
            
            <tag> 双显卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 系统蓝牙适配问题</title>
      <link href="2019/07/15/p45.html"/>
      <url>2019/07/15/p45.html</url>
      
        <content type="html"><![CDATA[<p>最近窗户外面修楼，打地基太吵（嗡嗡嗡咯，嗡嗡嗡咯，嗡嗡嗡咯……），于是下血本买了台降噪耳机用。耳机的降噪效果还是有的，发动机的嗡嗡声基本上屏蔽掉了，但是喇叭声、刹车声之类的高频噪音搞不定。不过还算满意吧，已经屏蔽掉大部分声音了，其他的只能期待技术进步啦。</p><p>耳机虽然好用，但是也遇到了难以解决的问题，这里贴一下折腾过程吧。</p><p>问题是这样的，蓝牙耳机与手机连接工作一切正常，但是与PC连接会出现很多奇怪的现象，换了好几个方案都没有解决，最后还是采用了一个折中的方案。</p><p>首先是 CSR 芯片的方案，这个方案不能用，原因是耳机每次开机都要重新配对才可以使用。现象是耳机提示已连接PC，但是PC上显示已断开连接，耳机里面能够听到PC上播放的很微弱的音乐声。</p><p>随后换了博通芯片的方案，这个方案解决了必须重新配对的问题，但是也不能用，原因是每次必须在播放设备里面手动连接耳机。有两个现象，一个是蓝牙耳机语音提示已连接PC，也可以在PC的蓝牙设备列表里面看到耳机已连接，但是在播放设备列表里面显示已断开连接，必须在这里手动连接后耳机才会有声音；另一个是即使耳机连接上了，麦克风也连接不上，也就是说蓝牙耳机的麦克风无法使用。</p><p>想来想去，这个问题应该是 Windows 对蓝牙的支持不好导致的。那既然这样，不是 Windows 对蓝牙支持不够好嘛，那咱搞个免驱的试试呗，所以搞了个免驱的回来。这次成功的解决了我的大部分问题。免驱的方案其实也不是真正的免驱，应该是把声卡和蓝牙做到了一起，即自带声卡的蓝牙适配器。使用的时候以声卡的身份与 Windows 交互，以蓝牙适配器的身份与耳机交互，从而避免了在 Windows 中处理蓝牙问题。这个适配器与耳机的配对都是在适配器上完成的，完全不需要Windows参与，Windows 识别成声卡，插上就可以用，上述提到的问题都解决了。包括重启重新配对，重启重新连接，麦克风不能使用等等问题都不复存在了。</p><p>不过还有一个遗留的问题解决不了：如果在使用耳机播放音乐的同时使用麦克风，那么耳机音质会变得很差。找了很多帖子都没有办法解决，不过这个问题查到最后可以确定是蓝牙协议的问题，而不是 Windows 的问题，所以无法解决。我买的耳机只支持 A2DP 协议，而不支持 aptX 协议， A2DP 协议无法同时使用立体声和麦克风，这时候我才回去手机上测试，发现手机上其实也是存在这个问题的。但是没有在手机上发现这个问题是因为手机在用麦克风的时候会直接将音乐关掉，真是个小机灵鬼呀。最后的折中方案是外挂一个麦克风，将默认播放设备设置为蓝牙耳机，默认录制设备设置为外挂的麦克风，并且将蓝牙耳机的麦克风禁用掉。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝牙 </tag>
            
            <tag> Windows </tag>
            
            <tag> win </tag>
            
            <tag> 驱动 </tag>
            
            <tag> 免驱 </tag>
            
            <tag> 蓝牙问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库快速迁移</title>
      <link href="2019/06/10/p44.html"/>
      <url>2019/06/10/p44.html</url>
      
        <content type="html"><![CDATA[<h1 id="为啥要迁移数据库">为啥要迁移数据库</h1><p>数据库中保留了大量用户信息，虽然运行环境可以重新搭建，但是数据库是无法手动恢复的，所以当服务器迁移的时候，数据库的安全迁移便很重要了。</p><h1 id="目标">目标</h1><p>将源服务器的MySQL数据库迁移到目标服务器，这里源服务器可以是需要被替换掉的服务器，也可以是测试环境等。</p><h1 id="前提">前提</h1><p>源服务器要有一个管理员权限的有密码的用户且允许该用户远程登陆。</p><h1 id="源服务器设置">源服务器设置</h1><p>GCP之类的vps服务器默认是不允许远程使用密码登录的，那么需要为源服务器设置root用户的密码以及允许远程登录。</p><h2 id="切换到root用户使用ssh登录到">切换到root用户使用ssh登录到</h2><p>使用ssh登录到服务器，然后允许命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure><h2 id="修改ssh配置文件">修改SSH配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ol type="1"><li>使用/PermitRootLogin查找到PermitRootLogin，可以看到该行被注释掉了，取消改行的注释并将值改为yes；</li><li>使用/PasswordAuthentication查找到PasswordAuthentication，将其值改为yes。</li></ol><h2 id="为root用户设置密码">为root用户设置密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><h2 id="重启ssh">重启SSH</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><h1 id="迁移">迁移</h1><p>迁移工作在目标服务器进行，直接使用rsync即可，命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz root@old.com:/var/lib/mysql/* /var/lib/mysql/</span><br></pre></td></tr></table></figure><p>其中old.com可以是源服务器的域名或者IP地址。文件迁移完成之后需要检查两台服务器上文件是否相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /var/lib/mysql/</span><br></pre></td></tr></table></figure><h1 id="赋予mysql用户权限">赋予MySQL用户权限</h1><p>如果目标服务器尚未安装MySQL，那么先安装MySQL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install mariadb-server</span><br></pre></td></tr></table></figure><p>如果上面的命令报错，那么需要先更新一下源才可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure><p>安装完MySQL之后可以将/var/lib/mysql权限赋予MySQL： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown mysql:mysql -R /var/lib/mysql/</span><br></pre></td></tr></table></figure></p><h1 id="再次确认数据库正确迁移">再次确认数据库正确迁移</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">enter password</span><br><span class="line">show databases;</span><br><span class="line">SELECT User FROM mysql.user;</span><br><span class="line">use databases;</span><br><span class="line">SELECT * FROM table;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 迁移 </tag>
            
            <tag> rsync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>福州大学学位论文全自动化排版Word模板</title>
      <link href="2019/05/08/p42.html"/>
      <url>2019/05/08/p42.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目地址">项目地址</h1><p>项目主站：<a href="https://blog.siaimes.me/ThesisFZU/">ThesisFZU web page</a></p><p>项目仓库：<a href="https://github.com/siaimes/ThesisFZU" target="_blank" rel="noopener">ThesisFZU github</a></p><h1 id="下载地址">下载地址</h1><p>项目主站下载<a href="https://github.com/siaimes/ThesisFZU/zipball/master" target="_blank" rel="noopener">download ThesisFZU from web page</a></p><p>项目仓库下载<a href="https://github.com/siaimes/ThesisFZU/archive/master.zip" target="_blank" rel="noopener">download ThesisFZU from github</a></p><h1 id="模板特色">模板特色</h1><blockquote><ol type="1"><li>章节编号使用隐藏的阿拉伯数字，实际显示的编号需要手动输入，所以本模板可以在处理所有章节编号格式的同时，不影响交叉引用。不同的专业使用只需对照自己的规范对章编号做细微调整即可；</li><li>本模板中各个模块按照本科生和研究生规范的并集设计制作，注意核对自己的论文规范将不需要的模块删除；</li><li>全文使用样式表排版，做到最大程度的自动化，模板中的样式严格按照《福州大学本科生毕业设计（论文）撰写规范（2017年修订）》和《福州大学研究生毕业论文规范（2016年修订）》设计制作；</li><li>公式建议使用<a href="http://www.amyxun.com/" target="_blank" rel="noopener">AxMath</a><sup>*</sup>插件，该插件支持所见即所得、LaTeX编辑器和交叉引用等，相当好用，最关键的是排版效果相当漂亮；</li><li>优化word自带参考文献排版引擎，并编写引文设置为上标的VBA代码，做到参考文献全自动管理；</li></ol></blockquote><h1 id="使用技巧">使用技巧</h1><blockquote><ol type="1"><li>本模板使用office 365设计制作，要使用该模板，office版本需要在2016及以上，否则不能保证一切正常；</li><li>直接在模板上双击即可新建一个word文档，若提示宏已被禁用，需要点击“启用内容”，否则无法自动管理参考文献；</li><li>若word文档在不同电脑之间迁移或者你移动了模板位置，这会由于无法索引到模板而导致无法自动管理参考文献，现象为找不到宏“调整参考文献格式”，此时打开：Word&gt;&gt;文件&gt;&gt;选项&gt;&gt;加载项&gt;&gt;管理[Word加载项]&gt;&gt;转到，重新选用文档模板即可；</li><li>不建议将该模板导入其他word文件，无法保证一切正常，如果论文快完成才知道这个模板可以考虑将论文使用该模板重排。</li></ol></blockquote><p><sup>*</sup>注：由于该插件需要写入注册表，故许多安全软件会报告病毒，此时请按照官网提示操作即可。</p>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 学术 </tag>
            
            <tag> ThesisFZU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优酷：由于您禁用了COOKIE导致视频无法播放</title>
      <link href="2018/06/12/p40.html"/>
      <url>2018/06/12/p40.html</url>
      
        <content type="html"><![CDATA[<p>17年年底刷<a href="https://www.youku.com/" target="_blank" rel="noopener">优酷</a>时候，点开每个视频都无法播放。提示：由于您禁用了COOKIE导致视频无法播放。本来用的是chrome浏览器，重装浏览器，开启cookie（压根没关过）都试过了没用。然而即使换成IE也不行，所以可以排除是chrome插件的问题。当时咨询了优酷客服也没能解决。</p><p>时隔半年，偶然想起又去鼓捣了一下，我的问题终于解决了。是由于之前使用老D博客提供的hosts翻墙，将windows系统的host替换掉了。然而hosts经常失效，我这怕麻烦的人就觉得太麻烦了，于是参考网上相关教程自己搭了梯子，随后就抛弃hosts了。但是忘记将hosts替换回去，后来hosts失效后导致这种奇怪的现象。发现这个问题后使用老D博客提供的工具恢复host就好了！</p>]]></content>
      
      
      <categories>
          
          <category> 电脑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5 拆铁路</title>
      <link href="2018/01/13/p39.html"/>
      <url>2018/01/13/p39.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小<span class="math inline">\(X\)</span>同学最近在玩一款造桥游戏。游戏由<span class="math inline">\(N\)</span>个岛屿组成，岛屿 1 为首都，岛屿之间已有<span class="math inline">\(M\)</span>条公路和<span class="math inline">\(K\)</span>座桥相连（公路与桥均为双向），使得<span class="math inline">\(N\)</span>个岛屿互相可达，每座桥都直接连接首都与某个岛屿<span class="math inline">\(s\)</span>。但小<span class="math inline">\(X\)</span>同学为了节省经费（中饱私囊）决定拆除一些桥，但保证任意岛屿到首都的最短路距离不变。小<span class="math inline">\(X\)</span>同学想知道最多能拆掉多少座桥。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为包括三个整数<span class="math inline">\(n\ (2\leq n\leq 10^4),\ m\ (1\leq m\leq 2\times 10^4),\ k\ (1\leq k\leq 10^4)\)</span>分别表示岛屿数，公路数与桥的数量。接下来<span class="math inline">\(m\)</span>行，每行三个整数<span class="math inline">\(u_i,\ v_i,\ x_i\ (1\leq u_i,\ v_i\leq n;\ u_i\neq v_i;\ 1\leq x_i\leq 10^9)\)</span> 表示第<span class="math inline">\(i\)</span>条公路连接<span class="math inline">\(u_i\)</span>岛屿与<span class="math inline">\(v_i\)</span>岛屿，长为<span class="math inline">\(x_i\)</span>。接下来<span class="math inline">\(k\)</span>行，每行两个整数<span class="math inline">\(s_i, y_i\ (2\leq s_i\leq n;\ 1\leq y_i\leq 10^9)\)</span>表示第<span class="math inline">\(i\)</span>座桥连接首都与<span class="math inline">\(s_i\)</span>岛屿，长度为<span class="math inline">\(y_i\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出一个整数表示最多可拆除多少座桥，使得首都到其他任意岛屿的最短路不变。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>5 5 3<br>1 2 1<br>2 3 2<br>1 3 3<br>3 4 4<br>1 5 5<br>3 5<br>4 5<br>5 5</td><td>2</td></tr><tr class="even"><td>2 2 3<br>1 2 2<br>2 1 3<br>2 1<br>2 2<br>2 3</td><td>2</td></tr></tbody></table><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">20007</span>;</span><br><span class="line"><span class="keyword">int</span> et, head[N], brid[N];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], used[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">    Edge() &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _nxt) &#123;</span><br><span class="line">        v = _v, w = _w, nxt = _nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[et] = Edge(v, w, head[u]), head[u] = et++;</span><br><span class="line">    e[et] = Edge(u, w, head[v]), head[v] = et++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n;++i) dis[i] = <span class="number">1e17</span>,</span><br><span class="line">        vis[i] = used[i] = <span class="literal">false</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;pair&lt;ll, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line">    que.push(mp(mp(<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">        <span class="keyword">if</span> (~brid[i])</span><br><span class="line">            que.push(mp(mp(-brid[i], -i), i));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        ll D = -que.top().fi.fi;</span><br><span class="line">        <span class="keyword">int</span> src = -que.top().fi.se;</span><br><span class="line">        <span class="keyword">int</span> u = que.top().se;</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>, used[src] = <span class="literal">true</span>, dis[u] = D;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + e[i].w) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].w;</span><br><span class="line">                que.push(mp(mp(-dis[v], -src), v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    et = <span class="number">0</span>, <span class="built_in">memset</span>(head + <span class="number">1</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span>(*head) * n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> _ui, _vi, _xi;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;_ui, &amp;_vi, &amp;_xi);</span><br><span class="line">        addEdge(_ui, _vi, _xi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(brid + <span class="number">1</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span>(*brid) * n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> _si, _yi;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;_si, &amp;_yi);</span><br><span class="line">        <span class="keyword">if</span> (brid[_si] == <span class="number">-1</span> || brid[_si] &gt; _yi)</span><br><span class="line">            brid[_si] = _yi;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(n);</span><br><span class="line">    <span class="keyword">int</span> ans = k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">        <span class="keyword">if</span> (~brid[i] &amp;&amp; used[i])</span><br><span class="line">            --ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>如果在不使用桥的情况下，首都到岛屿<span class="math inline">\(i\)</span>为最短距离，则敲<span class="math inline">\(1\leftrightarrow i\)</span>不需要使用（如果存在）。但是使用一条桥可能会更新多个点的距离，所以不能通过先先处理路再处理桥的方法。</p><p>暴力做法：每次去掉一座桥，计算首都1到其它节点的最短距离，如果存在一个节点不是最短距离，说明此桥不可去除，复杂度<span class="math inline">\(O(knlogn)\)</span>。</p><p>对于一座桥是否使用，主要取决于使用其它桥和公路的情况下的距离是否会比该桥的距离短。这可以看成一个竞争过程，谁先到达<span class="math inline">\(i\)</span>谁就占据改点。于是可以使用Dijkstra算法：每次去除距离最短且未访问过的点进行邻近的点的距离更新。处理过程中需要积累每个点由谁占据，用来判断最后使用了那些桥。如此复杂度即为Dij算法的复杂度<span class="math inline">\(O(nlogn)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> bfs </tag>
            
            <tag> Dijkstra算法 </tag>
            
            <tag> 带标记的单源最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4 神奇宝贝</title>
      <link href="2018/01/13/p38.html"/>
      <url>2018/01/13/p38.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小<span class="math inline">\(X\)</span>同学最近玩起了复古的神奇宝贝游戏。游戏地图为一个<span class="math inline">\(n\times m\)</span>的方格组成，地图中有如下一些表示：</p><p><strong>T：</strong> 该方格被树木占据，不可穿过；</p><p><strong>S：</strong> 小<span class="math inline">\(X\)</span>同学的起始位置，保证图中只包含一个 S；</p><p><strong>E：</strong> 地图的出口，保证图中只包含一个 E；</p><p><strong>0~9：</strong> 表示地图该位置存在<span class="math inline">\(i\)</span>个其它玩家。</p><p>游戏规则如下：每次操作所有玩家可以不行动或行动到相邻的可移动方格中。若小<span class="math inline">\(X\)</span>与其他玩家在同一方格相遇，他就需要与该方格内所有其他玩家分别完成一次决斗。由于小<span class="math inline">\(X\)</span>在这个服务器很出名，其他玩家都会尽一切可能遇上他并进行决斗。当小<span class="math inline">\(X\)</span>走到地图出口时结束游戏（若在出口处相遇，仍需进行完决斗后出地图）。小<span class="math inline">\(X\)</span>想知道他最少需要参加多少次决斗。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为包括两个整数<span class="math inline">\(n\)</span>，<span class="math inline">\(m\ (1\leq n,m\leq 1000)\)</span>表示地图的大小。接下来<span class="math inline">\(n\)</span>行，每行<span class="math inline">\(m\)</span>个字符表示地图，包含字符如题所述。</p><h1 id="数据输出">数据输出</h1><p>输出一个整数表示小 X 同学在游戏中需要参加的最少决斗次数。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>5 7<br>000E0T3<br>T0TT0T0<br>010T0T0<br>2T0T0T0<br>0T0S000</td><td>3</td></tr><tr class="even"><td>1 4<br>SE23</td><td>2</td></tr></tbody></table><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Position</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    Position(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) :x(_x), y(_y)&#123;&#125;</span><br><span class="line">    Position() :x(<span class="number">0</span>), y(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Position t)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x == t.x&amp;&amp;<span class="keyword">this</span>-&gt;y == t.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Position <span class="keyword">operator</span>+(Position t)&#123;</span><br><span class="line">        <span class="keyword">return</span> Position(<span class="keyword">this</span>-&gt;x + t.x, <span class="keyword">this</span>-&gt;y + t.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Position offset[<span class="number">4</span>] = &#123; Position(<span class="number">0</span>, <span class="number">1</span>), Position(<span class="number">1</span>, <span class="number">0</span>), Position(<span class="number">0</span>, <span class="number">-1</span>), Position(<span class="number">-1</span>, <span class="number">0</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> num[maxn][maxn];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Map()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(Position pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[pos.getx()][pos.gety()] == val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(Position pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        num[pos.getx()][pos.gety()] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Position pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="built_in">map</span>[pos.getx()][pos.gety()] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getMap</span><span class="params">(Position pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[pos.getx()][pos.gety()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(Position pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num[pos.getx()][pos.gety()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPath</span><span class="params">(Position start, Position finish)</span></span>&#123;</span><br><span class="line">        <span class="comment">//参考教材//if (start == finish)&#123; return 0;&#125;//按题设条件不可能存在这个情况</span></span><br><span class="line">        Position here = start, nbr;</span><br><span class="line">        setMap(start, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;Position&gt; myqueue;</span><br><span class="line">        myqueue.push(start);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> (!myqueue.empty())&#123;</span><br><span class="line">            here = myqueue.front();</span><br><span class="line">            myqueue.pop();</span><br><span class="line">            len = getMap(here);</span><br><span class="line">            total += getNum(here);</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= maxLen)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                nbr = here + offset[i];</span><br><span class="line">                <span class="keyword">if</span> (equal(nbr, <span class="number">0</span>) &amp;&amp; len &lt;= maxLen)&#123;</span><br><span class="line">                    setMap(nbr, len + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (nbr == finish)&#123;</span><br><span class="line">                        maxLen = len + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    myqueue.push(nbr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复杂度为：n*m</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, i, j;</span><br><span class="line">    <span class="keyword">char</span> str;</span><br><span class="line">    Position S, E;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d\n"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">            str = getchar();</span><br><span class="line">            <span class="keyword">switch</span> (str)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>: E = Position(i, j); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>: S = Position(i, j); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'T'</span>: mymap.setMap(Position(i, j), <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:mymap.setNum(Position(i, j), str - <span class="string">'0'</span>); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置围墙</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        mymap.setMap(Position(i, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        mymap.setMap(Position(i, m + <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m + <span class="number">1</span>; ++j)&#123;</span><br><span class="line">        mymap.setMap(Position(<span class="number">0</span>, j), <span class="number">1</span>);</span><br><span class="line">        mymap.setMap(Position(n + <span class="number">1</span>, j), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mymap.findPath(E, S));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>找到小x的最短路长度，小x一定要走最短路才遭遇最少玩家。因为，如果最短路上能遭遇的玩家，你打算不走最短路去避开他，那么他是可以直接去终点等着你的！然后再考虑逆向思维，所有玩家从终点出发，在小x之前或同时到达自己位置的需要与小x决斗。最终归结为电路布线问题，详细请参考教材。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> bfs </tag>
            
            <tag> 电路布线问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3 生日Party</title>
      <link href="2018/01/13/p37.html"/>
      <url>2018/01/13/p37.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>在 11 月 11 日生日的小<span class="math inline">\(X\)</span>同学刚刚过完了他的生日，朋友们在他家开心地举办了盛大的 party 为他庆生。</p><p>Party 结束后，留下了<span class="math inline">\(n\)</span>瓶未喝完的饮料，第<span class="math inline">\(i\)</span>瓶饮料的容积为<span class="math inline">\(b_i\)</span>，剩余饮料体积为<span class="math inline">\(a_i\)</span>。小<span class="math inline">\(X\)</span>同学十分喜欢这种饮料，希望把剩下的饮料都整理起来慢慢喝，但是家里的冰箱太小了，没有足够多的位置放瓶子，所以他希望用最少的瓶子装完所有剩下的饮料（饮料的体积不超过瓶子的容积）。同时，从一个瓶子倒体积<span class="math inline">\(v\)</span>的饮料到另一个瓶子需要花费<span class="math inline">\(v\)</span>单位的时间，小<span class="math inline">\(X\)</span>急着去看电视剧，他想知道在使用最少瓶子的前提下，最少需要花费多少单位时间能把所有饮料倒到这些瓶子里？</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为包括一个整数<span class="math inline">\(n\ (1\leq n\leq 100)\)</span>表示剩余饮料的瓶数。接下来一行，<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\ (1\leq a_i\leq 100)\)</span>表示<span class="math inline">\(n\)</span>瓶饮料所剩体积。最后一行，<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i\ (1\leq b_i\leq 100)\)</span>表示<span class="math inline">\(n\)</span>瓶饮料瓶子容积。</p><h1 id="数据输出">数据输出</h1><p>输出两个整数分别表示所需的最少瓶子数和倒饮料所需最少时间。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>4<br>3 3 4 3<br>4 7 6 5</td><td>2 6</td></tr><tr class="even"><td>2<br>1 1<br>100 100</td><td>1 1</td></tr></tbody></table><h1 id="源代码分支限界法">源代码（分支限界法）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b&lt;x.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ns[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cur, val, vol, cnt, up;</span><br><span class="line">    Heap(<span class="keyword">int</span> cur, <span class="keyword">int</span> val, <span class="keyword">int</span> vol, <span class="keyword">int</span> cnt, <span class="keyword">int</span> up)</span><br><span class="line">        :cur(cur), val(val), vol(vol), cnt(cnt), up(up) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Heap&amp; hp) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> up&lt;hp.up || up == hp.up&amp;&amp;cnt&lt;hp.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sumv[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, suma = <span class="number">0</span>, sumb = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ns[i].a);</span><br><span class="line">        suma += ns[i].a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ns[i].b);</span><br><span class="line">    sort(ns + <span class="number">1</span>, ns + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span> &amp;&amp; suma&gt;sumb; --i) &#123;</span><br><span class="line">        sumb += ns[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k代表最少瓶数</span></span><br><span class="line">    <span class="keyword">int</span> k = n - i;</span><br><span class="line">    sumv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) sumv[i] = sumv[i - <span class="number">1</span>] + ns[i].b;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + ns[i].a, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Heap&gt; pq;</span><br><span class="line">    pq.push(Heap(n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, dp[n][k]));</span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        Heap u = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (u.cnt == k)&#123;</span><br><span class="line">            res = u.up;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没儿子</span></span><br><span class="line">        <span class="keyword">int</span> cur_vol = u.vol + sumv[u.cur] - sumv[u.cur - (k - u.cnt)];</span><br><span class="line">        <span class="keyword">int</span> lef_cnt = k - u.cnt;</span><br><span class="line">        <span class="keyword">if</span> (cur_vol&lt;suma || lef_cnt&gt;u.cur || u.cur &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        Heap lson = Heap(u.cur - <span class="number">1</span>, u.val + ns[u.cur].a,</span><br><span class="line">            u.vol + ns[u.cur].b, u.cnt + <span class="number">1</span>,</span><br><span class="line">            u.val + ns[u.cur].a + dp[u.cur - <span class="number">1</span>][k - <span class="number">1</span> - u.cnt]);</span><br><span class="line">        pq.push(lson);</span><br><span class="line">        <span class="comment">//右子树，一个小条件提前判断一下</span></span><br><span class="line">        <span class="keyword">if</span> (u.cur - <span class="number">1</span> &gt;= k - u.cnt)&#123;</span><br><span class="line">            Heap rson = Heap(u.cur - <span class="number">1</span>, u.val, u.vol,</span><br><span class="line">                u.cnt, u.val + dp[u.cur - <span class="number">1</span>][k - u.cnt]);</span><br><span class="line">            pq.push(rson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, k, suma - res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1>题目要求用最少瓶子的前提下耗时也最少。首先确定需要瓶子个数<span class="math inline">\(k\)</span>，那么问题转化为用<span class="math inline">\(k\)</span>个瓶子装所有饮料，且转移耗时最少。等价为如下的优化问题：考虑分支限界法求最大值问题，上界定义为：<span class="math inline">\(upper\_bound=cura+h(k-curk)\)</span>，其中<span class="math inline">\(cura\)</span>表示已经选取的瓶子的饮料体积；<span class="math inline">\(curk\)</span>表示已经选取的瓶子数，<span class="math inline">\((k-curk)\)</span>表示还要选的瓶子个数；<span class="math inline">\(h(k-curk)\)</span> 表示从剩余的瓶子中取出<span class="math inline">\(k-curk\)</span>个瓶子的最大饮料体积。有如下剪枝策略：<p>预处理阶：按照瓶子体积升序排列以求得<span class="math inline">\(k\)</span>且方便剪枝。然后用运行一次动态规划算法计算<span class="math inline">\(dp(i,j)\)</span>，表示前<span class="math inline">\(i\)</span>个瓶子中，选<span class="math inline">\(j\)</span>个瓶子，能得到的最大饮料体积为计算<span class="math inline">\(upper\_bound\)</span>做准备。</p><p>优先队列实现分值限界法：从第n个瓶子开始搜，搜到第1个瓶子为止。每次找<span class="math inline">\(upper\_bound\)</span>值最大的节点扩展。</p><p>下面是样例分析：</p><p><img src="p37/6.3.png" title="6.3 题图"></p><h1 id="源代码动态规划">源代码（动态规划）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bottle</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, volume;</span><br><span class="line">&#125;bottles[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(bottle a, bottle b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.volume != b.volume)</span><br><span class="line">        <span class="keyword">return</span> a.volume&gt;b.volume;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.left&gt;b.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, j, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bottles[i].left);</span><br><span class="line">        <span class="comment">//所剩体积</span></span><br><span class="line">        sum += bottles[i].left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bottles[i].volume);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    sort(bottles + <span class="number">1</span>, bottles + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//确定使用的最少的瓶子数</span></span><br><span class="line">        total += bottles[i].volume;</span><br><span class="line">        <span class="keyword">if</span> (total &gt;= sum)&#123;</span><br><span class="line">            cnt = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = sum; (j - bottles[i].left) &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="comment">//dp[i][j] 选i个瓶子其中自带j的水</span></span><br><span class="line">                <span class="keyword">if</span> (dp[k - <span class="number">1</span>][j - bottles[i].left] != <span class="number">-1</span>)</span><br><span class="line">                    dp[k][j] = max(dp[k][j], dp[k - <span class="number">1</span>][j - bottles[i].left] + bottles[i].volume);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = sum; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[cnt][i] &gt;= sum)&#123;</span><br><span class="line">            ans = sum - i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, cnt, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析-1">设计思路与复杂度分析</h1><p>同分支限界法一样首先确定瓶子个数，但是无法使用前<span class="math inline">\(cnt\)</span>容积大的瓶子来作为最后结果，因为有可能那<span class="math inline">\(cnt\)</span>个瓶子外的瓶子剩余量很小且容积较大，或者<span class="math inline">\(cnt\)</span>个瓶子内容积大却剩余少。选取的<span class="math inline">\(cnt\)</span>个瓶子要尽量满足将剩余少的瓶子往剩余多的瓶子倒饮料，则找到<span class="math inline">\(cnt\)</span>个瓶子并且他们剩余的饮料总量最大，则转移时间就最少。所以需要知道选<span class="math inline">\(cnt\)</span>个瓶子时，可以装其他瓶子的剩余饮料总量可以是多少（<span class="math inline">\(cnt\)</span>个瓶子的总容积-<span class="math inline">\(cnt\)</span>个瓶子自己剩余的总饮料量）。如此得到状态转移方程： <span class="math display">\[dp(i,j)=max(dp(i,j),dp(i-1,j-bottle_i.left)+bottle_i.volume)\]</span> 其中<span class="math inline">\(dp(0,0)=0\)</span>，<span class="math inline">\(dp(i,j)\)</span>为选取<span class="math inline">\(i\)</span>个瓶子且这<span class="math inline">\(i\)</span>个瓶子自带<span class="math inline">\(j\)</span>剩余总量的<span class="math inline">\(i\)</span>个瓶子的最大总容积。</p><p>求解出上述转移方程后即可以通过方程 <span class="math display">\[max(sum-init) \ s.t.\ dp[cnt][init] \geq sum,init = 1\cdots sum\]</span> 最终获得所需时间是<span class="math inline">\(ans=sum-init\)</span> 可以理解为求解cnt个瓶子并且自带剩余饮料总量最大。所需时间就是剩余饮料总量减去这<span class="math inline">\(cnt\)</span>个瓶子自带的剩余总量。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分支限界法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2 水果沙拉</title>
      <link href="2018/01/13/p36.html"/>
      <url>2018/01/13/p36.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小<span class="math inline">\(X\)</span>同学最近胖了许多，准备减肥。他决定每天用水果沙拉代替三餐来节食减肥。他从超市买了<span class="math inline">\(n\)</span>种水果，每种水果有对应的美味度<span class="math inline">\(a_i\)</span>和所含的卡路里<span class="math inline">\(b_i\)</span>，他将从中选择一些水果来做水果沙拉，但根据减肥的原则，水果美味度的和要严格等于水果卡路里和的<span class="math inline">\(K\)</span>倍。为了让自己能持续减肥，小<span class="math inline">\(X\)</span>同学希望水果沙拉尽量好吃，即美味度尽量大，你能帮他吗？</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为包括两个整数<span class="math inline">\(n,k\ (1\leq n\leq 100,\ 1\leq k\leq 10)\)</span>表示水果种类数和减肥原则中的<span class="math inline">\(k\)</span>值。接下来一行，<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\ (1\leq a_i\leq 100)\)</span>表示<span class="math inline">\(n\)</span>种水果的美味度。最后一行，<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i\ (1\leq b_i\leq 100)\)</span>表示<span class="math inline">\(n\)</span>种水果的卡路里。</p><h1 id="数据输出">数据输出</h1><p>输出满足减肥原则的前提下小<span class="math inline">\(X\)</span>同学能获得的最大美味度，若无法满足原则，则输出<span class="math inline">\(-1\)</span>。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3 2<br>10 8 1<br>2 7 1</td><td>18</td></tr><tr class="even"><td>5 3<br>4 4 4 4 4<br>2 2 2 2 2</td><td>-1</td></tr></tbody></table><h1 id="源代码动态规划">源代码（动态规划）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NInf 0xfefefefe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_A 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 2 * MAX_N * MAX_A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_V];</span><br><span class="line"><span class="keyword">int</span> w_a[MAX_N];</span><br><span class="line"><span class="keyword">int</span> v_b[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n, k, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> offset = n * MAX_A;</span><br><span class="line">    v = <span class="number">2</span> * offset;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w_a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v_b[i]);</span><br><span class="line">        v_b[i] = w_a[i] - k*v_b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, NInf, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[offset] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v_b[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//依赖下标更小的，所以由大至小dp</span></span><br><span class="line">            <span class="keyword">for</span> (j = v - <span class="number">1</span>; j &gt;= v_b[i]; --j)&#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - v_b[i]] + w_a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//依赖下标更大的，所以由小至大dp</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; v + v_b[i]; ++j)&#123;<span class="comment">//@$v_i&lt;0$@</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - v_b[i]] + w_a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[offset] == <span class="number">0</span> ? <span class="number">-1</span> : dp[offset]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>此题类似0-1背包问题，但是加入了约束条件：<span class="math inline">\(\sum a = k\times\sum b\)</span>。自然首先考虑如何转化为背包问题，现将约束条件转化为：<span class="math inline">\(\sum a - k \times \sum b = 0\)</span>。则得到背包问题如下： <span class="math display">\[\left\{ \begin{array}{l}        v_i = a_i - k\times b_i \\        w_i = a_i               \\\end{array} \right.\]</span> 其状态转移方程为：<span class="math inline">\(dp(i,j)=max(dp(i-1,j),dp(i-1,j-v_i)+w_i)\)</span>。这是一个物品体积为<span class="math inline">\(v_i\)</span>，而价值为<span class="math inline">\(w_i\)</span>的0-1背包问题。与标准0-1背包问题的不同之处在于体积可能为负，所以需要加一个offset。而且最后要求<span class="math inline">\(v=0\)</span>，所以输出的是<span class="math inline">\(dp(n,offset)\)</span>。</p><p>可将offset设置为<span class="math inline">\(maxa\times n\)</span>，证明如下。当a极大，b极小时，得到下标的上界为<span class="math inline">\(maxa \times n\)</span>。当a极小，b极大时得到下标的下界为<span class="math inline">\(-k\times maxb\times n\)</span>。那么简单的将offset设置为<span class="math inline">\(-k\times maxb\times n\)</span> 也是可以的，但是内存负担和计算负担均很大。其实如果一旦有前面选取的物品体积和小于<span class="math inline">\(-maxa\times n\)</span>，那么后面即使所有<span class="math inline">\(a\)</span>加起来也不可能改变总体积为负的局面，所以<span class="math inline">\(dp\)</span> 数组<span class="math inline">\(-maxb\times n \sim -maxa\times n\)</span>段无实际意义，可以省略。即offset设置为<span class="math inline">\(maxa\times n\)</span>。</p><p>由于<span class="math inline">\(v_i\)</span>符号不确定，所以将公式中二维数组优化为一维数组的时候需要额外考虑处理方向问题，详见备注。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1 屠龙宝镜</title>
      <link href="2018/01/13/p35.html"/>
      <url>2018/01/13/p35.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小<span class="math inline">\(X\)</span>同学最近沉迷页游——屠龙宝镜。游戏在一个<span class="math inline">\(N\times M\)</span>的地图上进行，地图上有一些点设置有屠龙宝镜，玩家在地图的左上角，恶龙在地图的右下角。玩家在地图的左上角向右通过魔法发射一束能杀死恶龙的光线，光线通过地图直线传播，若玩家选择使用当前位置光线经过的宝镜，则宝镜会把光线朝上、下、 左、 右四个方向反射。但是每使用一个屠龙宝镜要消耗一定量的魔法值，魔法值的获取十分困难，因此小<span class="math inline">\(X\)</span>同学希望利用最少的屠龙宝镜杀死恶龙。但是随着地图的增大，计算变得越来越困难，小<span class="math inline">\(X\)</span>同学觉得游戏体验很差，你能帮帮他吗？</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为包括两个整数<span class="math inline">\(n,m\ (1\leq n, m\leq 1000)\)</span>表示游戏地图的大小。接下来<span class="math inline">\(n\)</span>行，每行包括<span class="math inline">\(m\)</span>个字符用来表示地图。‘.’ 字符表示该地图位置为空地，‘#’ 字符表示该地图位置设置有屠龙宝镜。30%的数据<span class="math inline">\(n\times m\leq 30\)</span>，70%的数据<span class="math inline">\(n\times m\leq 100\)</span>，100%的数据<span class="math inline">\(n\times m\leq 1000\)</span>。</p><h1 id="数据输出">数据输出</h1><p>若能杀死恶龙，输出需要使用的最少屠龙宝镜，否则输出-1。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3 3<br>.#.<br>...<br>.#.</td><td>2</td></tr><tr class="even"><td>4 4<br>##..<br>..#.<br>...#<br>...#</td><td>-1</td></tr></tbody></table><h1 id="提示">提示</h1><p><img src="p35/6.1.jpg" title="6.1 题图"> # 源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, Inf, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, father, son;</span><br><span class="line">    myqueue.push(idx);</span><br><span class="line">    <span class="keyword">while</span> (!myqueue.empty())&#123;</span><br><span class="line">        father = myqueue.front();</span><br><span class="line">        myqueue.pop();</span><br><span class="line">        flag[father] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;tree[father].size(); i++)&#123;</span><br><span class="line">            son = tree[father][i];</span><br><span class="line">            <span class="keyword">if</span> (!flag[son])&#123;</span><br><span class="line">                myqueue.push(son);</span><br><span class="line">                cnt[son] = min(cnt[father] + <span class="number">1</span>, cnt[son]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[n] == Inf ? <span class="number">-1</span> : cnt[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, i, j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d\n"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">//行节点从1到n，列节点从n+1到n+m</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = getchar();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'#'</span>)&#123;</span><br><span class="line">                tree[i].push_back(n + j);</span><br><span class="line">                tree[n + j].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(<span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>可以把地图的每一行每一列看成是一个点，存在宝镜的地方就把它看成是某行的点到某列的边。这个时候就变成了从起点开始寻找到终点的最短路径。</p><p>建图：<span class="math inline">\(T_1(n)=O(n\times m)\)</span>；搜索路径：<span class="math inline">\(T_2(n)=O(m+n)\)</span>；综上所述，时间复杂度：<span class="math inline">\(T(n)=T_1+T_2=O(m\times n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> bfs </tag>
            
            <tag> 分支限界法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.5 最大字典序</title>
      <link href="2018/01/13/p34.html"/>
      <url>2018/01/13/p34.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>给定一个<span class="math inline">\(1\sim N\)</span>的全排列，给出<span class="math inline">\(M\)</span>对可以交换的位置<span class="math inline">\((A_i,B_i)\)</span>。每一次，你可以选择一对位置，交换其位置上的数值。不限制操作次数，请问经过交换后，字典序最大的全排列是多少(字典序的定义请参考）。</p><h1 id="数据输入">数据输入</h1><p>第一行输入包括两个整数，<span class="math inline">\(N\)</span>和<span class="math inline">\(M\ (1\leq N,M\leq 20000)\)</span>。第二行输入包括<span class="math inline">\(N\)</span>个整数，表示<span class="math inline">\(1\sim N\)</span>的全排列。接下去<span class="math inline">\(M\)</span>行，每行包括两个整数<span class="math inline">\(A_i,B_i\ (1\leq A_i,B_i\leq N,A_i\neq B_i)\)</span>，表示序列中<span class="math inline">\(A_i\)</span>和<span class="math inline">\(B_i\)</span>位置上的数可以交换。</p><h1 id="数据输出">数据输出</h1><p>出入<span class="math inline">\(N\)</span>个整数，表示最大字典序的序列。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>5 3<br>1 5 4 2 3<br>1 3<br>3 5<br>2 4</td><td>4 5 3 2 1</td></tr></tbody></table><h1 id="源代码dfs">源代码（dfs）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; change[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> index[maxn];</span><br><span class="line"><span class="keyword">bool</span> used[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> &amp;len)</span></span>&#123;</span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    index[len] = i;</span><br><span class="line">    <span class="built_in">set</span>[len++] = data[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; change[i].size(); ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[change[i][j]])&#123;</span><br><span class="line">            dfs(change[i][j], len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, i, j, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, data + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        change[u].push_back(v);</span><br><span class="line">        change[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            dfs(i, len);</span><br><span class="line">            sort(<span class="built_in">set</span>, <span class="built_in">set</span> + len, cmp);</span><br><span class="line">            sort(index, index + len);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; ++j)&#123;</span><br><span class="line">                data[index[j]] = <span class="built_in">set</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, data[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源代码并查集">源代码（并查集）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[maxn], vec[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UFset</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> root[maxn];</span><br><span class="line">    <span class="keyword">int</span> rank[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            root[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root[v] = root[v] == v ? v : Find(root[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rx = Find(x);</span><br><span class="line">        <span class="keyword">int</span> ry = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (rx == ry)<span class="keyword">return</span>;<span class="comment">//已合并返回</span></span><br><span class="line">        <span class="comment">//未优化</span></span><br><span class="line">        <span class="comment">//root[rx] = ry;</span></span><br><span class="line">        <span class="comment">//return;</span></span><br><span class="line">        <span class="comment">//优化</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rx] &lt; rank[ry])&#123;</span><br><span class="line">            root[rx] = ry;<span class="comment">//把x的祖先rx合并到y的祖先ry上。因以ry为根的树更高</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root[ry] = rx;</span><br><span class="line">            <span class="keyword">if</span> (rank[rx] == rank[ry])&#123;</span><br><span class="line">                ++rank[rx];<span class="comment">//若两树一样高，那么合并后，高度加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, i, j, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ufset.init(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        ufset.Union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = ufset.Find(i);</span><br><span class="line">        vec[fa].push_back(data[i]);</span><br><span class="line">        pos[fa].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        sort(vec[i].begin(), vec[i].end(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;pos[i].size(); j++)&#123;</span><br><span class="line">            data[pos[i][j]] = vec[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, data[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>位置A和B可以互换，位置B和C可以互换，则位置A和C也可以互换。先将可以互相交换的数都放入同一个集合，然后将同一个集合的数进行逆序排序，放入原来的集合对应的位置即可得到解。</p><p>查找集合的方法就不唯一了：</p><ol type="1"><li>将序列看做深林，每一个交换集看做一棵树，则使用<span class="math inline">\(dfs\)</span>或者<span class="math inline">\(bfs\)</span>遍历即可得到每一颗树；</li><li>既然是集合问题，自然可以使用并查集实现。</li></ol><p>以上算法都可以在<span class="math inline">\(O(n\times logn)\)</span>时间复杂度内实现。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> dfs </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.4 统治世界</title>
      <link href="2018/01/13/p33.html"/>
      <url>2018/01/13/p33.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>大陆上有<span class="math inline">\(N\)</span>个国家，由<span class="math inline">\(N-1\)</span>条道路连接，保证两两连通。我们将国家分布看成一个树形结构，以标号为 1 的国家为根节点。每个国家都有一个综合实力<span class="math inline">\(A_i\)</span>，每条道路上有一个长度<span class="math inline">\(W_i\)</span>。现在，如果国家<span class="math inline">\(V\)</span>可以攻打国家<span class="math inline">\(U\)</span>，当且仅当在树形结构图中，<span class="math inline">\(U\)</span>在<span class="math inline">\(V\)</span>的子树中，且<span class="math inline">\(dist(v,u)\leq A_u\ (V\neq U)\)</span>，<span class="math inline">\(dist(v,u)\)</span>表示<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的最短路。现在想请你帮忙计算每个国家可以攻打的国家数目。</p><h1 id="数据输入">数据输入</h1><p>第一行包含一个整数<span class="math inline">\(N\ (1\leq N\leq 20000)\)</span>，表示国家的个数。第二行包含<span class="math inline">\(N\)</span>个正整数<span class="math inline">\(A_1,A_2,\cdots , A_n\ (1\leq A_i\leq 10^9)\)</span>，表示国家的综合实力。接下去输入<span class="math inline">\(N-1\)</span>行，第<span class="math inline">\(i\)</span>行包括两个整数<span class="math inline">\(P_i\)</span>和<span class="math inline">\(W_i\ (1\leq P_i\leq N,1\leq W_i\leq 10^9)\)</span>，表示标号为<span class="math inline">\(P_i\)</span>的国家是标号为<span class="math inline">\(i+1\)</span>的国家的父节点，且两个国家之间的道路长度为<span class="math inline">\(W_i\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出为<span class="math inline">\(N\)</span>个整数，表示每个国家可以攻打的国家个数。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>5 6<br>4 1 2 6<br>1 2<br>1 2<br>2 4<br>2 5</td><td>1 1 0 0 0</td></tr></tbody></table><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> power, weight, parent, scale;</span><br><span class="line">    Node() :power(<span class="number">0</span>), weight(<span class="number">0</span>), parent(<span class="number">0</span>), scale(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Node node[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node[i].power);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;node[i].parent, &amp;node[i].weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> son = i;</span><br><span class="line">            <span class="keyword">int</span> power = node[son].power;</span><br><span class="line">            <span class="keyword">while</span> (son &gt; <span class="number">1</span> &amp;&amp; power &gt;= node[son].weight)&#123;</span><br><span class="line">                ++node[node[son].parent].scale;</span><br><span class="line">                power -= node[son].weight;</span><br><span class="line">                son = node[son].parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, node[<span class="number">1</span>].scale);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, node[i].scale);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tree.in();</span><br><span class="line">    tree.solve();</span><br><span class="line">    tree.out();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>题目源于实际：地球上有若干国家，国家之间的相互制约表现为“强国” 控制弱国。控制国需要保证对其所有被控国的绝对控制力。即：若某一个被控国的势力范围达到其大本营，则控制国将要攻打该被控国，削弱其势力。而我们的任务是帮助每一个控制国求解其需要攻打的被控国数量。所以不难理解为何是：子节点的实力大于其到父节点的路径长度，则父节点攻打子节点。所以美国虽然控制整个地球，他也没有天天打仗嘛！因为他只是需要一个平衡，然后坐收渔利！</p><p>输入的数据是每一个节点的父节点、到父节点的路径长度以及自身的势力。根据输入数据，将任务转化为对于每一个节点计算其所有父节点是否可以攻击他，并将结果存储在该父节点处。所以对于每一个节点，回溯其势力范围内的祖先节点并将其攻击数加一。</p><p>平均时间复杂度<span class="math inline">\(O(n\times logn)\)</span>，最坏时间复杂度<span class="math inline">\(O(n^2)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.3 最长隧道</title>
      <link href="2018/01/13/p32.html"/>
      <url>2018/01/13/p32.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p><span class="math inline">\(C\)</span>国有<span class="math inline">\(N\)</span>个城市，由<span class="math inline">\(N-1\)</span>条道路连接，保证可以从一个城市到达其他任意一个城市。国王挑选出<span class="math inline">\(2\times k\)</span>个重要的城市，将其分为<span class="math inline">\(k\)</span>组，在每组的两个城市间，沿着道路修筑隧道，来为战争做准备。假设所有的道路长度为1，现在帮助国王分组，使得按照该分组方案进行修筑隧道后，所有隧道的长度之和最大（两不同组若在同一段道路上修建隧道，算作两条）。</p><h1 id="数据输入">数据输入</h1><p>输入第一行包括两个整数<span class="math inline">\(N\)</span>和<span class="math inline">\(K\ (2\leq N\leq 20000,1\leq K\leq n/2)\)</span>，为城市的总个数和重要城市的组数。第二行包括<span class="math inline">\(2\times K\)</span> 个不同的整数，表示重要城市的编号。接下来<span class="math inline">\(N-1\)</span>行，每行包括两个整数<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\ (1\leq X,Y\leq N)\)</span>，表示<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>两个城市之间有一条道路。</p><h1 id="数据输出">数据输出</h1><p>输出整数<span class="math inline">\(K\)</span>，表示隧道的最大长度和。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>7 2<br>4 5 6 7<br>1 2<br>1 3<br>2 4<br>2 5<br>3 6<br>3 7</td><td>8</td></tr></tbody></table><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pair;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son;</span><br><span class="line">    Node() :pair(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    Node node[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, i, u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">        k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            tree.node[u].pair = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            node[u].son.push_back(v);</span><br><span class="line">            node[v].son.push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node[root].son.size() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node[root].son.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> son = node[root].son[i];</span><br><span class="line">            <span class="keyword">if</span> (son == parent)<span class="keyword">continue</span>;</span><br><span class="line">            ret += dfs(son, root);</span><br><span class="line">            ret += min(node[son].pair, k - node[son].pair);</span><br><span class="line">            node[root].pair += node[son].pair;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tree.in();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tree.dfs(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>问题转化：与每条隧道最长等价的问题是，每一条边有尽可能多的隧道通过。</p><p>最小配对原则：假设一条边将一棵树分成了两个部分，若左边有v个要挑选的城市，则右边必有<span class="math inline">\((2\times K-v)\)</span>个要挑选城市。要使该边通过的隧道数尽可能多，则重要城市少的部分的所有重要城市必须通过该边与重要城市多的部分连接，因此该边必有<span class="math inline">\(min(2\times k-v,v)\)</span>条隧道通过。</p><p>实现上使用<span class="math inline">\(dfs\)</span>即可知道每一条边树形结构下方的重要城市数，复杂度为：<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2 统一货币</title>
      <link href="2018/01/13/p31.html"/>
      <url>2018/01/13/p31.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p><span class="math inline">\(C\)</span>国家有<span class="math inline">\(N\)</span>个城市，用<span class="math inline">\(N-1\)</span>条道路连接，保证任意两个城市连通，整个国家中由两种流通的货币，有的城市使用货币<span class="math inline">\(A\)</span>币，有的城市用货币<span class="math inline">\(B\)</span>币，现国王希望统一货币，便于管理。现在只有一种操作：</p><p><span class="math inline">\(change(v)\)</span>，<span class="math inline">\(v\)</span>表示国家中的某个城市，该操作可以改变所有城市<span class="math inline">\(U=\lbrace u|u\)</span>到<span class="math inline">\(v\)</span>的最短路径上的城市当前所使用的货币都与<span class="math inline">\(v\)</span>相同<span class="math inline">\(\rbrace\)</span>的货币类型，如果是<span class="math inline">\(A\)</span>则变成<span class="math inline">\(B\)</span>，是<span class="math inline">\(B\)</span>则变成<span class="math inline">\(A\)</span>。请问最少需要几次操作，能使整个国家货币统一。</p><h1 id="数据输入">数据输入</h1><p>第一行包括一个整数<span class="math inline">\(N(1\leq N\leq 20000)\)</span>，表示城市个数。 第二行为<span class="math inline">\(N\)</span>个整数<span class="math inline">\(t_i\)</span>，表示城市的货币类型。<span class="math inline">\(t_i=0\)</span>表示第<span class="math inline">\(i\)</span>个城市使用<span class="math inline">\(A\)</span>货币，<span class="math inline">\(t_i=1\)</span>表示第<span class="math inline">\(i\)</span>个城市<span class="math inline">\(B\)</span>货币类型。然后输入<span class="math inline">\(N-1\)</span>行，每行包括两个整数<span class="math inline">\(v_i\)</span>，<span class="math inline">\(u_i\ (1\leq v_i,u_i\leq N)\)</span>，表示城市<span class="math inline">\(v_i\)</span>和城市<span class="math inline">\(u_i\)</span>之间有一条道路。</p><h1 id="数据输出">数据输出</h1><p>输出一个个数 K，表示需要使用的最小操作数。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>2<br>0 1 1 0 0 0 1<br>1 2<br>1 3<br>2 4<br>2 5<br>3 6<br>3 7</td><td>2</td></tr></tbody></table><h1 id="提示">提示</h1><p><span class="math inline">\(change(3)\)</span>： <img src="p31/5.2.jpg" title="5.2 题图"></p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node node[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, i, u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            node[u].son.push_back(v);</span><br><span class="line">            node[v].son.push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//parent:fa &lt;-&gt; root &lt;-&gt; son，判断是否处理过了！</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> &amp;leaf, <span class="keyword">int</span> deep, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">        leaf = root;</span><br><span class="line">        <span class="keyword">int</span> ret = deep;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node[root].son.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> son = node[root].son[i];</span><br><span class="line">            <span class="keyword">int</span> leaft = root;</span><br><span class="line">            <span class="keyword">if</span> (son != parent)&#123;</span><br><span class="line">                <span class="keyword">int</span> deept = node[root].type == node[son].type ? deep : deep + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> len = bfs(son, leaft, deept, root);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; ret)&#123;</span><br><span class="line">                    ret = len;</span><br><span class="line">                    leaf = leaft;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tree.in();</span><br><span class="line">    <span class="keyword">int</span> leaf = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//树的直径算法</span></span><br><span class="line">    tree.bfs(<span class="number">1</span>, leaf, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> len = tree.bfs(leaf, leaf, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>压缩点：根据操作的特征，容易发现，所有点权相同且互相“联通”的点，操作一致。可以考虑将它们压缩成一个点，缩完点之后得到的是一棵黑白相间的树。</p><p>考虑一种操作方式：选一个点，从头到尾一直翻转它。对于这样的操作方式，树高决定操作次数。因此，为了让操作次数最少，需要选择一个点，使得树高最小，而这个点称之为树的中心。寻找树的中心方法是：找出树中距离最远的两个点，以这两个点为端点的路径，称之为树的直径，直径中间的那个点就是树的中心。于是题目等价于求出树直径长度Len，最终的答案为<span class="math inline">\(floor(Len/2)\)</span>。</p><p>贪心证明：为何一直翻转树的中心会是最优策略？若每次翻转直径的非叶子结点，缩点之后，结点数减少2。若每次翻转直径的叶子结点，缩点之后，结点数减少1。所以显然优先翻转非叶子结点。要将直径全部变成一种颜色，至少需进行Len/2次操作，结果不会优于一直翻转树的中心策略。</p><p>树的直径：（证明有兴趣可以翻翻算法导论）对于树的任意一个结点a，找到距离结点a的最远结点A；找到距离结点A的最远结点B，则A和B所在的路径就是树的直径。</p><p>复杂度分析：压缩点可以考虑重新建树时间为<span class="math inline">\(T1(n)=n\)</span>，但是其实么必要，在找树的直径的时候对于同色的子节点深度不增加即可达到目的。找树的直径时间为<span class="math inline">\(T2(n)=2\times n\)</span>。所以总时间复杂度为<span class="math inline">\(T(n)=2\times n=O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> dfs </tag>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1 综合实力</title>
      <link href="2018/01/13/p30.html"/>
      <url>2018/01/13/p30.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>大陆上有<span class="math inline">\(N\)</span>个国家，用<span class="math inline">\(N-1\)</span>条道路连接，保证任意两个国家之间有路径可达。弱肉强食，国家之间的战争随时会爆发，因此国家与国家之间选择结盟避免被吞并。因为每个国家的综合实力<span class="math inline">\(A\)</span>不一样，只要联盟的综合实力总和相等，就能保证陆地上暂时的和平。现在需要破坏 2 条道路，将这<span class="math inline">\(N\)</span>个国家划分成 3 个联盟，使各个联盟国家综合实力总和相等。</p><h1 id="数据输入">数据输入</h1><p>输入第一行为整数<span class="math inline">\(N(3\leq N\leq 20000)\)</span>，表示国家的个数。接下来<span class="math inline">\(N\)</span>行，包括两个整数<span class="math inline">\(T\)</span>和<span class="math inline">\(A\ (1\leq A\leq 100)\)</span>，第<span class="math inline">\(i\)</span>行表示第<span class="math inline">\(i\)</span>条道路，连接国家<span class="math inline">\(i\)</span>和国家<span class="math inline">\(T\)</span>（<span class="math inline">\(T=0\)</span>表示这条道路不存在），且国家<span class="math inline">\(i\)</span>的综合实力为<span class="math inline">\(A\)</span>。国家编号从 1 到<span class="math inline">\(N\)</span>，所有的道路都是双向的。</p><h1 id="数据输出">数据输出</h1><p>如果没有解决方案则输出-1。否则输出两个整数，表示这两条道路的编号（即在输入中第几个给出，编号从 1 开始），按从小到大的顺序输出。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>5<br>2 3<br>0 1<br>1 3<br>2 1<br>2 1</td><td>1 3</td></tr></tbody></table><h1 id="提示">提示</h1><p><img src="p30/5.1.jpg" title="5.1 题图"></p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son;</span><br><span class="line">    Node() :power(<span class="number">0</span>)&#123; son.clear(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    Node node[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;<span class="comment">//0是虚节点，其子节点存储根节点的编号</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;parent, &amp;node[i].power);</span><br><span class="line">            node[parent].son.push_back(i);<span class="comment">//下标只会出现一次，做son没问题</span></span><br><span class="line">            total += node[i].power;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不为3的整数倍必定无解</span></span><br><span class="line">        total /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(node[<span class="number">0</span>].son[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;<span class="comment">//dfs(后序遍历)，并将合法子树的根提升为虚节点的子树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node[root].son.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(node[root].son[i]))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//剪枝：已找到两颗满足条件的子树，那么余下的节点一定满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (node[<span class="number">0</span>].son.size() == <span class="number">3</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            node[root].power += node[node[root].son[i]].power;</span><br><span class="line">            <span class="keyword">if</span> (node[root].power&gt;total)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//剪枝：该子树无法凑齐1/3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node[root].power == total)&#123;</span><br><span class="line">            node[<span class="number">0</span>].son.push_back(root);</span><br><span class="line">            node[root].power = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree() :total(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    tree.in(n);</span><br><span class="line">    <span class="keyword">if</span> (!tree.solve()) &#123; <span class="built_in">printf</span>(<span class="string">"-1\n"</span>); &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans1 = tree.node[<span class="number">0</span>].son[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans2 = tree.node[<span class="number">0</span>].son[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (ans1&gt;ans2)swap(ans1, ans2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>设每一颗子树的综合实力为其所有子树的实力与根的实力之和，则对于某一棵子树，若其综合实力刚好等于<span class="math inline">\(1/3\)</span>根树的综合实力，那么将该子树与父节点切断联系独立成一棵树即可。实现上只需要<span class="math inline">\(dfs\)</span>（后序遍历）即可得到每一颗子树的综合实力。 在<span class="math inline">\(dfs\)</span>的时候分如下3情况可优化：</p><ol type="1"><li>某一颗树其所有子树都未达到<span class="math inline">\(1/3\)</span>，但是与其结合之后超过1/3，那么无解，直接返回<span class="math inline">\(false\)</span>；</li><li>若找到两颗子树分别满足<span class="math inline">\(1/3\)</span>，那么在预判总量为3的倍数的前提下剩余节点一定满足条件，可直接返回<span class="math inline">\(true\)</span>；</li><li>找到符合条件的子树的时候直接将其根设为虚节点的儿子，则无需再次遍历查找答案。</li></ol><p>如此所有时间耗费为输入数据和<span class="math inline">\(dfs\)</span>的时间，复杂度为：<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.5 起名2</title>
      <link href="2018/01/13/p29.html"/>
      <url>2018/01/13/p29.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>为了排解巨大的学习压力，小明养成了一个奇特的爱好：在宿舍养蚂蚁。</p><p>小明想给最大的那只蚂蚁起一个霸气的名字，为此他想了很多候选名字，但他选来选去也无法决定要用哪个名字。突然他想到，如果把所有的候选名字按某种顺序首尾相接串起来，就可以得到一个非常霸气的名字了。当然为了让最终的名字更加霸气，小明希望这个最终的结果的字典序尽可能大。现给出<span class="math inline">\(n\)</span>个候选名字，你要帮小明安排一个最优的顺序将它们首尾相接串起来，使得最终得到的那个名字字典序尽可能大(字典序的定义请参考<a href="/2018/01/13/p28">4.4 起名1</a>）。</p><h1 id="数据输入">数据输入</h1><p>输入一行为<span class="math inline">\(n\)</span>，表示字符串的个数。以下<span class="math inline">\(n\)</span>行，每行给出一个字符串。<span class="math inline">\(1\leq n\leq 10000\)</span>。字符串仅由小写字母组成，<span class="math inline">\(1\leq\)</span>字符串长度<span class="math inline">\(\leq 50\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出一个字符串，为所有输入字符串按照某种顺序串起来后，有可能得到的字典序最大的结果。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>2<br>c<br>cav</td><td>ccav</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(70\%\)</span>的测试点，<span class="math inline">\(n\leq 10\)</span>；<span class="math inline">\(30\%\)</span>的测试点，<span class="math inline">\(n\leq 10000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 51</span></span><br><span class="line"><span class="keyword">char</span> str[maxn][maxm], temp1[maxm &lt;&lt; <span class="number">1</span>], temp2[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(temp1, str[a]);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp2, str[b]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="built_in">strcat</span>(temp1, str[b]), <span class="built_in">strcat</span>(temp2, str[a])) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        gets(str[i]);</span><br><span class="line">        index[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(index, index + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, str[index[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>n个字符串串成一个长串，使得长串字典序最大。大小具有传递性，拼接两个串比较大小即可确定两个串的相对顺序。复杂度<span class="math inline">\(O(nlogn\times maxlen)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4 起名1</title>
      <link href="2018/01/13/p28.html"/>
      <url>2018/01/13/p28.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>为了排解巨大的学习压力，小明养成了一个奇特的爱好：在宿舍养蚂蚁。</p><p>小明想给最大的那只蚂蚁起一个霸气的名字，为此他发明了“程序员起名法” 。具体步骤如下：1.~随机生成一个字符串；2. 选择字符串中字典序最大的子序列作为名字。作为一个优秀的程序员，小明顺利地完成了第一步，但第二步他就不会了，请你帮帮他。</p><p>子序列的定义：对于一个字符串<span class="math inline">\(s=s_1s_2\cdots s_{|s|}\)</span>，称字符串<span class="math inline">\(s_{p_1}s_{p_2}\cdots s_{p_k}\ (1\leq p_1&lt;p_2&lt;\cdots &lt; p_k\leq |s|)\)</span>为它的一个子序列。</p><p>字典序的定义：字符串<span class="math inline">\(x=x_1x_2\cdots x_{|x|}\)</span>比字符串<span class="math inline">\(y=y_1y_2\cdots y_{|y|}\)</span>字典序大，当且仅当： 1.~<span class="math inline">\(|x|&gt;|y|\)</span>且<span class="math inline">\(x_1=y_1,x_2=y_2,\cdots ,x_{|y|}=y_{|y|}\)</span>， 或 2.~存在一个非负整数<span class="math inline">\(r\ (r&lt;|x|,r&lt;|y|)\)</span>，使得<span class="math inline">\(x_1=y_1,x_2=y_2,\cdots ,x_r=y_r\)</span>且<span class="math inline">\(x_{r+1}&gt;y_{r+1}\)</span>。字符的大小即它们 ASCII 码的大小。</p><h1 id="数据输入">数据输入</h1><p>输入一行为一个字符串，表示小明第一步的结果。</p><p>字符串仅由小写字母组成，<span class="math inline">\(1\leq\)</span>字符串长度<span class="math inline">\(\leq 100000\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出一个字符串，为输入字符串的字典序最大的子序列。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>ababba</td><td>bbba</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(70\%\)</span>的得分点，输入字符串长度<span class="math inline">\(\leq 10\)</span>；<span class="math inline">\(30\%\)</span>的得分点，输入字符串长度<span class="math inline">\(\leq 100000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    gets(str);</span><br><span class="line">    n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    pos[n - <span class="number">1</span>] = n - <span class="number">1</span>;</span><br><span class="line">    pos[n] = n;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= str[pos[i + <span class="number">1</span>]])pos[i] = i;</span><br><span class="line">        <span class="keyword">else</span> pos[i] = pos[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = pos[<span class="number">0</span>]; i &lt; n; i = pos[i + <span class="number">1</span>])</span><br><span class="line">        <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>考虑输出的第一个字符，必然是字符串中出现的最大字符。如果有多个最大字符，那么第二个、第三个字符也应该是最大字符，才能保证字典序最大。</p><p>当最大字符用完之后，则考虑次大字符。这个次大字符不能出现任意一个最大字符之前，否则会导致字典序变小。也就是说之后输出的所有字符必须在所有最大字符后面，原串成为一个后缀串，在该后缀串找字典序最大的子序列，就是规模更小的子问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 后缀串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.3 小明的爱好</title>
      <link href="2018/01/13/p27.html"/>
      <url>2018/01/13/p27.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>为了排解巨大的学习压力，小明养成了一个奇特的爱好：在宿舍养蚂蚁。</p><p>小明养了两种颜色的蚂蚁：红色和黑色。这一天，他把他所有的蚂蚁排成一列。但他发现这样的队伍看上去颜色杂乱不美观。</p><p>小明的目标是使得队伍中的蚂蚁颜色红黑相间（即第一只红，第二只黑，第三只红……；或第一只黑，第二只红，第三只黑……）。为了达到这个目标，他可以在每一步选用以下任一种方法：1. 交换任意两只蚂蚁的位置；2.用水彩笔将任意一只蚂蚁涂成红色或黑色。</p><p>小明想用尽量少的步骤，使得蚂蚁的颜色红黑相间，请你帮帮他。</p><h1 id="数据输入">数据输入</h1><p>输入第一行为正整数<span class="math inline">\(n\)</span>，表示蚂蚁的个数。接下去<span class="math inline">\(n\)</span>个字符，表示排成一列的蚂蚁的颜色，‘r’ 表示红色，‘b’ 表示黑色。</p><h1 id="数据输出">数据输出</h1><p>输出一个数，表示最少的操作次数。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>5<br>rbbrr</td><td>1</td></tr><tr class="even"><td>5<br>bbbbb</td><td>2</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(70\%\)</span>的得分点，<span class="math inline">\(n \leq 10\)</span>；<span class="math inline">\(30\%\)</span>的得分点，<span class="math inline">\(n \leq 100000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> oddr = <span class="number">0</span>, evenb = <span class="number">0</span>, oddb = <span class="number">0</span>, evenr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> anti;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        anti = getchar();</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> &amp;&amp; anti == <span class="string">'r'</span>)++evenr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">2</span> &amp;&amp; anti == <span class="string">'b'</span>)++evenb;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (anti == <span class="string">'r'</span>)++oddr;</span><br><span class="line">        <span class="keyword">else</span> ++oddb;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(max(oddr, evenb), max(oddb, evenr)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>计算原串变成目标串“<span class="math inline">\(brbrb\cdots\)</span>”的最少操作数<span class="math inline">\(res1\)</span>。计算原串变成目标串“<span class="math inline">\(rbrbr\cdots\)</span>”的最少操作数<span class="math inline">\(res2\)</span>。最终的答案<span class="math inline">\(res=min(res1,res2)\)</span>。</p><p>怎么计算最少操作数？统计位于<span class="math inline">\(r\)</span>（目标串）的位置上的<span class="math inline">\(b\)</span>（原串），记作<span class="math inline">\(sumb\)</span>。统计位于<span class="math inline">\(b\)</span>（目标串）的位置上的<span class="math inline">\(r\)</span>（原串），记作<span class="math inline">\(sumr\)</span>。我们最少需要进行<span class="math inline">\(min(sumb,sumr)\)</span>次交换<span class="math inline">\(+|sumb-sumr|\)</span>次替换。分析上面的式子得<span class="math inline">\(res=max(sumb,sumr)\)</span>。时间复杂度<span class="math inline">\(O(n)\)</span>、空间复杂度<span class="math inline">\(O(n)\)</span>。</p><p>贪心策略：对于已经在正确的位置上的字符，我们没有必要动它，因为这样做不会减少操作数。对于错误位置上的字符，我们肯定优先交换，剩下的不能交换的再替换。因为交换能摆正两个位置，而替换只能摆正一个位置。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2 鲜花礼物</title>
      <link href="2018/01/13/p26.html"/>
      <url>2018/01/13/p26.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>YellowStar 有<span class="math inline">\(n\)</span>朵花，每朵花都有高度，表示为<span class="math inline">\(a_1,a_2,\cdots ,a_n\)</span>。<span class="math inline">\(m\)</span>天之后他要把<span class="math inline">\(n\)</span>朵花作为礼物送给他心爱的小姐姐，不过这<span class="math inline">\(m\)</span>天里可以通过浇花来让花长高。</p><p>由于每天只能浇一朵花，使得该朵花高度加 1。Yellowstar 希望自己送出去的<span class="math inline">\(n\)</span>朵花中的最低高度值，尽可能大，请你帮帮他。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为 2 个数字<span class="math inline">\(n,m\ (1\leq n\leq 10^5,1 \leq m \leq 10^9)\)</span>，表示有<span class="math inline">\(n\)</span>朵花，<span class="math inline">\(m\)</span>天。第二行包含<span class="math inline">\(n\)</span>个整数，表示鲜花的高度<span class="math inline">\(a_1,a_2,\cdots,a_n\ (1\leq a_i\leq 10^9)\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出一个整数，表示答案。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>6 2<br>2 2 2 2 1 1</td><td>2</td></tr><tr class="even"><td>6 1<br>2 2 2 2 1 1</td><td>1</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(m \leq 100000\)</span>； <span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(m \leq 10^9\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">int</span> hight[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次浇最矮的一批花就好</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, i, dh;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m))&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;hight[i]);</span><br><span class="line">        sort(hight, hight + n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dh = (hight[i] - hight[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (dh &gt;= m / i)  <span class="keyword">break</span>;<span class="comment">//这样避免使用长整型</span></span><br><span class="line">            m -= i*dh;<span class="comment">//已经保证i\times dh&lt;m了，所以不会溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, hight[i - <span class="number">1</span>] + m / i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>补短板就好了，但是实现的时候不要去一次一次的模拟，而是一次性将所有最矮的提升到次矮，否则就超时了。注意数据范围！</p><p>复杂度分析：排序<span class="math inline">\(O(n\times logn)\)</span>，数据处理<span class="math inline">\(O(n)\)</span>，整体时间复杂度<span class="math inline">\(O(n\times logn)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1 爬树</title>
      <link href="2018/01/13/p25.html"/>
      <url>2018/01/13/p25.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>YellowStar 拥有一棵<span class="math inline">\(n\)</span>个结点的有根树，标号为 1 到<span class="math inline">\(n\)</span>，1 号结点为根结点，树的每个叶子结点有一只蚂蚁。每一秒钟每只蚂蚁可以选择不动或者爬到相邻的一个结点。除了根节点，其他结点每个时刻最多只能有一只蚂蚁，问开始后最少经过多少秒，所有蚂蚁都能爬到根节点。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为数字<span class="math inline">\(n\  (2\leq n\leq 10^5)\)</span>，表示树的结点个数。接下来第<span class="math inline">\(n - 1\)</span>行，每行包含 2 个整数<span class="math inline">\(u, v\  (1\leq u, v\leq n)\)</span>，表示树边（不保证<span class="math inline">\(u\)</span>是<span class="math inline">\(v\)</span>的父亲，也有可能<span class="math inline">\(v\)</span>是<span class="math inline">\(u\)</span>的父亲）。保证输入的必然是一棵树。</p><h1 id="数据输出">数据输出</h1><p>输出一个整数，表示最少时间。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>12<br>1 2<br>1 3<br>1 4<br>2 5<br>2 6<br>3 7<br>3 8<br>3 9<br>8 10<br>8 11<br>8 12</td><td>6</td></tr><tr class="even"><td>2<br>2 1</td><td>1</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n \leq 1000\)</span>；<span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n \leq 100000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value, deep;</span><br><span class="line">    node(<span class="keyword">int</span> v, <span class="keyword">int</span> d) :value(v), deep(d)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree()&#123;&#125;</span><br><span class="line">    Tree(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)&#123;</span><br><span class="line">            edges[i].clear();</span><br><span class="line">            hasParent[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hasParent[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        hasParent[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>, leaves, i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; edges[<span class="number">1</span>].size(); ++i)&#123;</span><br><span class="line">            leaves = <span class="number">0</span>;</span><br><span class="line">            bfs(edges[<span class="number">1</span>][i], leaves);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; leaves; ++j)</span><br><span class="line">                deeps[j] = max(deeps[j - <span class="number">1</span>] + <span class="number">1</span>, deeps[j]);</span><br><span class="line">            result = max(result, deeps[leaves - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> &amp;treeRoot, <span class="keyword">int</span>&amp; leaves)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt;myqueue;</span><br><span class="line">        myqueue.push(node(treeRoot, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!myqueue.empty())&#123;</span><br><span class="line">            node root = myqueue.front();</span><br><span class="line">            myqueue.pop();</span><br><span class="line">            <span class="comment">//叶子节点度为1</span></span><br><span class="line">            <span class="keyword">if</span> (edges[root.value].size() == <span class="number">1</span>)&#123;</span><br><span class="line">                deeps[leaves++] = root.deep; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;edges[root.value].size(); ++i)</span><br><span class="line">                <span class="keyword">if</span> (!hasParent[edges[root.value][i]])&#123;</span><br><span class="line">                    hasParent[edges[root.value][i]] = <span class="literal">true</span>;</span><br><span class="line">                    myqueue.push(node(edges[root.value][i], root.deep + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line">    <span class="keyword">bool</span> hasParent[maxn];</span><br><span class="line">    <span class="keyword">int</span> deeps[maxn];</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        tree.addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tree.solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>考虑贪心就是对于每一棵子树，使用后序遍历，让所有蚂蚁从下往上爬，记录每一只蚂蚁到达当前节点的时间。在非叶子节点合并该节点的所有子节点的蚂蚁的时候同时考虑重叠问题。其实最后就等于对深度归并排序的同时将重叠的往后推。所以可以考虑遍历所有节点的深度使用快排，然后再考虑重叠问题，这样效率会高很多！另一个优化是其实建树也是后序的，所以两个过程是可以合并的。还有一个优化是使用层次遍历，这样就不用对深度排序了。最后时间复杂度为<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.5 搬家</title>
      <link href="2018/01/13/p24.html"/>
      <url>2018/01/13/p24.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>搬家有多辛苦，相信你们早有耳闻。由于市区建设的需要，继小明之后，小八也加入了这个行列。现在的小八就陷入了极度的纠结之中，看着家里的<span class="math inline">\(n\)</span>件家具，小八开始发呆，因为<span class="math inline">\(n\)</span>是一个小于 2000 的整数，实在是太多了，于是小八决定随便搬<span class="math inline">\(2\times k\)</span>件家具就行了。但还是会很累，因为<span class="math inline">\(2\times k\)</span>也不小是一个不大于<span class="math inline">\(n\)</span>的整数。</p><p>幸运的是小八有了上次帮小明搬东西的经验，发现每搬一次的疲劳度是左右手的物品的重量差的平方（这里补充一句，小明每次搬两件东西，左手一件右手一件）。例如小八左手拿重量为 3 的物品，右手拿重量为 6 的物品，则他搬完这次的疲劳度为<span class="math inline">\((6-3)^2= 9\)</span>。现在可怜的小八希望知道搬完这<span class="math inline">\(2\times k\)</span>件物品后的最佳状态是怎样的（也就是最低的疲劳度），请告诉他吧。</p><p>你的任务是从给定的<span class="math inline">\(n\)</span>件家具中，替小八挑选<span class="math inline">\(2\times k\)</span>件家具，并规划小八的搬运方案，使得小八最终的疲劳度最低。</p><h1 id="数据输入">数据输入</h1><p>输入数据有两行,第一行有两个数<span class="math inline">\(n,k\ (2\leq 2\times k\leq n&lt;2000)\)</span>。第二行有<span class="math inline">\(n\)</span>个整数分别表示<span class="math inline">\(n\)</span>件物品的重量（重量是一个小于<span class="math inline">\(2^{15}\)</span>的正整数）。</p><h1 id="数据输出">数据输出</h1><p>输出只有一行，表示最低的疲劳度。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>2 1<br>1 3</td><td>4</td></tr></tbody></table><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></span><br><span class="line"></span><br><span class="line">ll data[maxn];</span><br><span class="line">ll dp[<span class="number">3</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll a, ll b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;data[i]);</span><br><span class="line">    sort(data, data + n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i_0, i_1, i_2;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        i_0 = i % <span class="number">3</span>;</span><br><span class="line">        i_1 = (i - <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//+3避免溢出，这样不用单独判断i=2 的情况，多一次无意义的比较而已</span></span><br><span class="line">        i_2 = (i - <span class="number">2</span> + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= k; ++j)&#123;</span><br><span class="line">            ll x = data[i]-data[i<span class="number">-1</span>];</span><br><span class="line">            dp[i_0][j] = min(dp[i_1][j], dp[i_2][j - <span class="number">1</span>] + x*x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, dp[i_0][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>重量余越接近的相差越小，所以一定是相邻的两个物品一起搬运。那么先将物品按重量排序之后即可由状态转移方程<span class="math inline">\(dp(i,j)=min(dp(i-1,j),dp(i-2,j-1)+(w_i-w_{i-1})^2)\)</span>求解。复杂度<span class="math inline">\(O(n\times k)\)</span>。 可以看到当前的状态只与前两个状态有关，所以可以使用滚动数组节约内存。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 滚动数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.4 零食</title>
      <link href="2018/01/13/p23.html"/>
      <url>2018/01/13/p23.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小八同学最近爱上了吃零食，但是他又想追求健康的生活。每一包零食都有一个能量值，小八同学每次都一定要吃总能量刚好为<span class="math inline">\(v\)</span>的零食才肯罢休。而且小八同学又很懒，他希望通过吃数量最少的零食达到这个目的。所以他希望你能设计一个程序帮他决定要吃哪些零食。</p><p>给定每种零食所包含的能量和数目，你的任务是给出所要吃的零食的最小数目。</p><h1 id="数据输入">数据输入</h1><p>先输入一行包含 2 个整数<span class="math inline">\(v\ (v\leq 20000)\)</span>、<span class="math inline">\(n\)</span>，表示小八需要吃能量值和为<span class="math inline">\(v\)</span>的零食，而零食一共有<span class="math inline">\(n\)</span>种，下面输入<span class="math inline">\(n\)</span>行，每行 2 个整数，第一个表示该种零食的能量值（能量值大于 0），第二个表示该种零食的总数。所有零食的总数量不会超过 50。</p><h1 id="数据输出">数据输出</h1><p>输出一行包含一个整数表示小八最少需要吃的零食数量，若小八无法通过吃零食达到<span class="math inline">\(v\)</span>的能量值，则输出“Fail”。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>10 2<br>4 1<br>2 10</td><td>4</td></tr><tr class="even"><td>10 2<br>4 1<br>7 3</td><td>Fail</td></tr></tbody></table><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 20005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fminmax min</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"><span class="keyword">int</span> V[maxn], C[maxn], dp[maxm];<span class="comment">//, W[maxn] (if necessary)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多重背包O(V\times \sum log C_i)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, n, i, j, k, tempv;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, V + i, C + i);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (C[i] == <span class="number">1</span>) &#123;<span class="comment">//01背包问题，虽然这题没必要，但是为了举一反三！</span></span><br><span class="line">            <span class="keyword">for</span> (j = v; j &gt;= V[i]; --j)</span><br><span class="line">                dp[j] = fminmax(dp[j], dp[j - V[i]] + <span class="number">1</span>);<span class="comment">//1-&gt;W[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (V[i] * C[i] &gt;= v) &#123;<span class="comment">//转化为完全背包问题</span></span><br><span class="line">            <span class="keyword">for</span> (j = V[i]; j &lt;= v; ++j)</span><br><span class="line">                dp[j] = fminmax(dp[j], dp[j - V[i]] + <span class="number">1</span>);<span class="comment">//1-&gt;W[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k = <span class="number">1</span>;<span class="comment">//多重背包问题</span></span><br><span class="line">            <span class="keyword">while</span> (k &lt; C[i]) &#123;</span><br><span class="line">                tempv = k * V[i];</span><br><span class="line">                <span class="keyword">for</span> (j = v; j &gt;= tempv; --j)</span><br><span class="line">                    dp[j] = fminmax(dp[j], dp[j - tempv] + k);<span class="comment">//k-&gt;k*W[i]</span></span><br><span class="line">                C[i] -= k;</span><br><span class="line">                k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempv = C[i] * V[i];</span><br><span class="line">            <span class="keyword">for</span> (j = v; j &gt;= tempv; --j)</span><br><span class="line">                dp[j] = fminmax(dp[j], dp[j - tempv] + C[i]);<span class="comment">//C[i]-&gt;C[i]*W[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[v] &lt; <span class="number">0x7f7f7f7f</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>此题为多重背包问题，具体请参考背包九讲第1-3讲。做法是将第<span class="math inline">\(i\)</span>种物品分成了<span class="math inline">\(log C_i\)</span>种物品，将原问题转化为复杂度为<span class="math inline">\(O(V\times \sum log C_i)\)</span>的 01 背包问题。</p><p>本题实现的时候已经将01背包、多重背包、完全背包均包括了。如果遇到类似题目可以直接从中举一反三。</p><p>附多重背包问题通用描述：有<span class="math inline">\(N\)</span>种物品和一个容量为<span class="math inline">\(V\)</span>（本题为总能量<span class="math inline">\(m\)</span>）的背包。第<span class="math inline">\(i\)</span>种物品最多有<span class="math inline">\(C_i\)</span>件可用，每件耗费的空间是<span class="math inline">\(V_i\)</span>，价值是<span class="math inline">\(W_i\)</span>（本题价值为1，即占用1 个数量）。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过（刚好等于）背包容量，且价值总和最大（最小）。</p><p>关于0x7f的说明：由于<span class="math inline">\(memset\)</span>函数是来自<span class="math inline">\(string.h\)</span>库的函数，所以其操作对象为字节，将<span class="math inline">\(int\)</span>数组按字节初始化为0x7f，实际得到的是0x7f7f7f7f。已经几乎达到了<span class="math inline">\(int\)</span>的极限。不存在两个极大值相加的情况可以这样初始化，如果存在两个极大值相加的情况可以初始化为0x3f，其为0x7f的一半。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.3 击杀 Boss</title>
      <link href="2018/01/13/p22.html"/>
      <url>2018/01/13/p22.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小八同学是个游戏高手，面对任何游戏总是游刃有余。但他并不满足于此，他想要知道他和真正的高手之间还有多少的差距，这使得小八开始研究起游戏的运行机制。已知在某个游戏里，英雄和 boss 的初始生命值都是 100，每回合英雄先攻击 boss，然后boss 再攻击英雄。boss 每次打英雄的伤害值固定，英雄打 boss 可以使用普通攻击，也可以使用技能攻击。使用普通攻击每次造成的伤害为 1，不花费任何的魔法值。使用技能时，则每次可以从<span class="math inline">\(n\)</span>种技能中挑选一种，造成<span class="math inline">\(b_i\)</span>点伤害，花费魔法值<span class="math inline">\(a_i\)</span>，剩余魔法值小于<span class="math inline">\(a_i\)</span>，则无法使用该技能。</p><p>英雄的初始魔法值为 100，每秒回复魔法值为 t，但是恢复也不会使魔法值超过 100。（回复魔法值会在英雄发动攻击前进行）</p><p>现在小八想通过这些数据了解到打死 boss 最快需要多少时间，又或者英雄会被 boss 杀死。（每秒钟 boss 和英雄都只能进行一次攻击，当生命值小于等于 0，即认为被杀死）</p><h1 id="数据输入">数据输入</h1><p>第 1 行为三个用一个空格隔开的正整数<span class="math inline">\(n\ t\ q\)</span>，其中<span class="math inline">\(n\ (0\leq n\leq 100)\)</span>，表示英雄拥有的技能数，<span class="math inline">\(t\ (1\leq t\leq 5)\)</span>，为每秒回复的魔法值，<span class="math inline">\(q\ (q&gt;0)\)</span>，为每次 boss 对英雄的伤害值。</p><p>从第 2 行到第<span class="math inline">\(n+1\)</span>行，第<span class="math inline">\(j\)</span>行给出了编号为<span class="math inline">\(j-1\)</span>的技能的基本数据，每行有 2 个非负整数<span class="math inline">\(a_i\  b_i\)</span>，其中<span class="math inline">\(a_i\)</span>表示使用该技能花费的魔法值，<span class="math inline">\(b_i\)</span>表示使用该技能造成的伤害。</p><h1 id="数据输出">数据输出</h1><p>输出只有一行，表示英雄杀死 boss 的时间，如果英雄被杀死，则输出“Game over”。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>4 2 25<br>10 5<br>20 10<br>30 28<br>76 70</td><td>4</td></tr><tr class="even"><td>4 2 25<br>10 5<br>20 10<br>30 28<br>77 70</td><td>Game over</td></tr></tbody></table><h1 id="提示">提示</h1><p>在两个示例中，除了最后一行数据，其余数据都一样。</p><p>其中 boss 打英雄每秒伤害为 25，4 秒之后英雄就会被 boss 打死。也就是说英雄最多有发动四次攻击的机会。</p><p>在 4 次攻击里，每一秒的顺序都是英雄先回复魔法值，然后英雄攻击 boss，最后 boss 攻击英雄。由于第一秒的回复值加上 100 会超出上限，所以这两点魔法值无法加入到魔法值总数中。这才导致两个示例的结果不同。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxp 100</span></span><br><span class="line"><span class="keyword">int</span> hurtSum[maxn][maxn];<span class="comment">//turn*magic</span></span><br><span class="line"><span class="keyword">int</span> ai[maxn]; <span class="comment">// 花费</span></span><br><span class="line"><span class="keyword">int</span> bi[maxn];  <span class="comment">// 伤害</span></span><br><span class="line"><span class="keyword">int</span> bosslife = maxp;</span><br><span class="line"><span class="keyword">int</span> maxHurt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, t, q; <span class="comment">//技能数, 魔力恢复值,boss伤害值</span></span><br><span class="line"><span class="keyword">int</span> killflag = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">magicUpdate</span><span class="params">(<span class="keyword">int</span> magic)</span></span>&#123;</span><br><span class="line">    magic = t + magic;</span><br><span class="line">    <span class="keyword">return</span> (magic&gt;maxp) ? maxp : magic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fight</span><span class="params">(<span class="keyword">int</span> lifeturn, <span class="keyword">int</span> magicSum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lifeturn == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (hurtSum[lifeturn][magicSum]&gt;<span class="number">0</span>) <span class="keyword">return</span> hurtSum[lifeturn][magicSum];</span><br><span class="line">    <span class="keyword">int</span> MaxHurt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> updateMagic = magicUpdate(magicSum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (updateMagic &gt;= ai[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = fight(lifeturn - <span class="number">1</span>, updateMagic - ai[i]) + bi[i];</span><br><span class="line">            <span class="keyword">if</span> (temp&gt;MaxHurt) MaxHurt = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (MaxHurt &gt;= bosslife &amp;&amp; (killflag&lt;<span class="number">0</span> || killflag&gt;lifeturn)) killflag = lifeturn;</span><br><span class="line">    hurtSum[lifeturn][magicSum] = MaxHurt;</span><br><span class="line">    <span class="keyword">return</span> MaxHurt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(hurtSum, <span class="number">0</span>, <span class="keyword">sizeof</span>(hurtSum));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;t, &amp;q);</span><br><span class="line">    <span class="comment">//普通攻击</span></span><br><span class="line">    ai[<span class="number">0</span>] = <span class="number">0</span>, bi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ai[i], &amp;bi[i]);</span><br><span class="line">    <span class="comment">//轮数, 魔力值</span></span><br><span class="line">    fight(maxp / q + (maxp % q != <span class="number">0</span>), maxp);</span><br><span class="line">    <span class="keyword">if</span> (killflag&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, killflag);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Game over\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>由于 boss 的攻击手段确定，那么英雄的最多攻击次数即可确定。则问题简化为英雄能否在给定攻击次数中击毙 boss 。由此得到状态转移方程：<span class="math display">\[dp(m,p)=max(b_i+dp(m-1,p + t-a_i)),\ i=0,1,\cdots, n\]</span>其中<span class="math inline">\(m\)</span>为可攻击次数，<span class="math inline">\(p\)</span>为魔法值。考虑到状态转移方程不是单向依赖的，无法使用递推形式的<span class="math inline">\(dp\)</span>，只能使用备忘录方法了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 备忘录方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2 金矿问题</title>
      <link href="2017/12/26/p21.html"/>
      <url>2017/12/26/p21.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了 <span class="math inline">\(n\)</span> 座金矿，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民。后他找到了这个领域的专家小八，对每一座金矿进行勘测，勘测发现挖掘每个金矿所需的人数是固定的（一个也不需要多，一个也不能少），而且这些金矿也有主矿和副矿的区别，主矿可以直接进行挖掘，但是副矿必须在挖掘完其对应的主矿后才能进行挖掘，否则会有相当的风险。每个主矿可能有 0 个、1 个或 2 个副矿，每个副矿都只对应 1 个主矿，且副矿不会再有副矿。了解完这些后，国王决定派 <span class="math inline">\(v\)</span> 个矿工去挖金矿。（<span class="math inline">\(v\)</span> 个矿工不一定要全部用完）</p><p>现给出金矿数量 <span class="math inline">\(n\)</span> 及矿工数量 <span class="math inline">\(v\)</span> ，以及每个金矿的具体情况。求最多能获得的金子数量。</p><h1 id="数据输入">数据输入</h1><p>第 1 行为两个正整数<span class="math inline">\(v\  n\)</span>，其中 <span class="math inline">\(v\ (2\leq v\leq 100)\)</span>，表示所有矿工数量，<span class="math inline">\(n\ (2\leq n\leq 1000)\)</span>，为金矿的数量。</p><p>接下来的<span class="math inline">\(n\)</span> 行，第 <span class="math inline">\(i\)</span> 行给出了编号为 <span class="math inline">\(i\)</span> 的金矿的基本数据，每行有 3 个非负整数<span class="math inline">\(V_i\  W_i\  M_i\)</span>。其中 <span class="math inline">\(V_i\)</span> 表示挖掘该金矿所需的矿工数目，<span class="math inline">\(W_i\)</span> 表示该金矿的含金量，<span class="math inline">\(M_i\)</span> 表示该金矿是主矿还是副矿。如果 <span class="math inline">\(M_i=0\)</span>，表示该金矿是主矿，如果 <span class="math inline">\(M_i&gt;0\)</span>，表示该金矿为副矿，<span class="math inline">\(M_i\)</span>是所属主矿的编号。</p><h1 id="数据输出">数据输出</h1><p>输出只有一行，表示最多的金子数量。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>100 5<br>80 100 0<br>40 500 1<br>20 300 1<br>20 100 0<br>50 200 0</td><td>400</td></tr></tbody></table><h1 id="源代码转化为分组背包">源代码（转化为分组背包）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">107</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1007</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxv];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goldmine</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, m, cnt, sub[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;v, &amp;w, &amp;m); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addSub</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sub[cnt++] = x; &#125;</span><br><span class="line">    Goldmine() :cnt(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125; gm[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖背包</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, n, i, j, k, h;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        gm[i].in();</span><br><span class="line">        <span class="keyword">if</span> (gm[i].m &gt; <span class="number">0</span>) gm[gm[i].m].addSub(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (gm[i].m == <span class="number">0</span>) &#123;<span class="comment">//其实是转化为分组背包求解</span></span><br><span class="line">        <span class="keyword">for</span> (j = v; j &gt; <span class="number">0</span>; --j) &#123;<span class="comment">//dp[i][j]=max(dp[i-1][j],dp[i-1][j-V_k]+W_k)</span></span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; gm[i].cnt); ++k)<span class="comment">//dp组内每一个方案</span></span><br><span class="line">            &#123;<span class="comment">//如果依赖数比较大可以先对所有分组进行一次01背包的预dp</span></span><br><span class="line">                <span class="keyword">int</span> V = gm[i].v, W = gm[i].w;</span><br><span class="line">                <span class="keyword">for</span> (h = <span class="number">0</span>; h&lt;gm[i].cnt; ++h) <span class="keyword">if</span> (k &gt;&gt; h &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    V += gm[gm[i].sub[h]].v;</span><br><span class="line">                    W += gm[gm[i].sub[h]].w;</span><br><span class="line">                &#125;<span class="comment">//由于没有预dp，可能存在不合法的组合</span></span><br><span class="line">                <span class="keyword">if</span> (V &lt;= j) dp[j] = max(dp[j], dp[j - V] + W);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>此题为依赖背包问题，具体请参考背包九讲第 6-7 讲。做法是将依赖背包问题转化为分组背包问题求解。此时每一个分组包含<span class="math inline">\(2^{cnt}\)</span>个“物品”（<span class="math inline">\(cnt\)</span> 为附件个数），<span class="math inline">\(cnt\)</span>比较小时可以直接枚举。复杂度为<span class="math inline">\(O(\sum _{i=1}^n v \times 2^{cnt_i} \times cnt_i)\)</span>（<span class="math inline">\(n\)</span> 为分组数量）。但是当某一个<span class="math inline">\(cnt_i\)</span>比较大时自然会超时，所以需要寻找一个优化策略，让算法复杂度上界不受<span class="math inline">\(cnt_i\)</span> 的影响。</p><p>其实当<span class="math inline">\(2^{cnt_i} \times cnt_i&gt;v\)</span>时（本题为<span class="math inline">\(cnt \geq 5\)</span>）可以对该分组的“附件集合”先进行一次01背包的<span class="math inline">\(dp\)</span>。因为要考虑附件的前提是主件必须选取，所以该<span class="math inline">\(vector\)</span> 大小为背包总容量减去主件的大小（最多可以有这么多容量分配给该分组的附件）。这样做的目的是可以排除许多容量大于可用容量的组合，从而加速算法过程。有了这个<span class="math inline">\(dp\)</span> 过程，代码第34行就可以不用判断了。该预处理的时间复杂度为<span class="math inline">\(O(k \times cnt_i\times v)\)</span>（<span class="math inline">\(k\)</span>为需要预处理的分组数量）。将无需预处理的分组中<span class="math inline">\(2^{cnt_i}\)</span>放大到<span class="math inline">\(v\)</span>，则优化后的算法时间复杂度为<span class="math inline">\(O(n \times v^2)\)</span>。</p><p>当然，以上代码是一个通用解法，针对本题这样做并不是最优的解法。该算法中每一个分组会枚举很多次，由于没有预处理，所以每一次枚举都会有时间消耗。如果使用一个滚动数组<span class="math inline">\(dp\)</span>，可以将时间复杂度优化到<span class="math inline">\(O(\sum _{i=1}^n v \times 2^{cnt_i})\)</span>。现给出代码供参考。</p><h1 id="源代码滚动数组">源代码（滚动数组）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">107</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1007</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][maxv];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goldmine</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, q, cnt, sub[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;v, &amp;w, &amp;q); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addSub</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sub[cnt++] = x; &#125;</span><br><span class="line">    Goldmine() :cnt(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125; gm[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, n, i, j, k;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        gm[i].in();</span><br><span class="line">        <span class="keyword">if</span> (gm[i].q &gt; <span class="number">0</span>) gm[gm[i].q].addSub(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (gm[i].q == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//dp[i][j]=max(dp[i-1][j],dp[i-1][j-V_k]+W_k)</span></span><br><span class="line">        <span class="comment">//其实不是严格意义上的滚动数组，由于每一个组合都会依赖于dp[i-1] 所以需要备份</span></span><br><span class="line">        <span class="built_in">memcpy</span>(dp[!flag], dp[flag], <span class="keyword">sizeof</span>(dp) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k&lt;<span class="number">1</span> &lt;&lt; gm[i].cnt; ++k) &#123;<span class="comment">//交换内外层循环</span></span><br><span class="line">            <span class="keyword">int</span> V = gm[i].v, W = gm[i].w;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;gm[i].cnt; ++j) <span class="keyword">if</span> (k &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                V += gm[gm[i].sub[j]].v;</span><br><span class="line">                W += gm[gm[i].sub[j]].w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j = V; j &lt;= v; ++j)</span><br><span class="line">                dp[flag][j] = max(dp[flag][j], dp[!flag][j - V] + W);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[flag][v]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 滚动数组 </tag>
            
            <tag> 依赖背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1 卡片游戏</title>
      <link href="2017/12/26/p20.html"/>
      <url>2017/12/26/p20.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小八同学最近开发了一款卡片收集的小游戏，在这个游戏中，小八同学布下了一个神奇的迷宫：</p><p><img src="p20/3.1.jpg" title="3.1 题图"></p><p>迷宫可以看成是一个二维的方格阵列，玩家初始不携带任何卡片，从左上角的入口处进入，右下角的出口走出。玩家每经过一个格子会获得或者失去一定数目的卡片，若玩家到了某一格需要支付卡片，但数目不足以支付的话，则清空其所携带的所有卡片，并允许其继续前行。最终的目的是保证用户从出口出来时尽量保留有更多的卡片。</p><p>现在规定玩家只能向右或者向下走，向下走每次只能走一格，但是如果向右的话，则每次可以走一格或者走到列数是当前所在列数数倍的格子，即如果当前格子是<span class="math inline">\((x,y)\)</span>，则下一步可以是<span class="math inline">\((x+1,y)\)</span>，<span class="math inline">\((x,y+1)\)</span>或者<span class="math inline">\((x,y\times k)\)</span>，其中 <span class="math inline">\(k&gt;1\)</span> 且为正整数。</p><p>现在请你计算玩家走出迷宫时所携带的最多的卡片数。</p><h1 id="数据输入">数据输入</h1><p>第 1 行为两个正整数<span class="math inline">\(n\ m\)</span>，其中 <span class="math inline">\(n\ (1\leq n\leq 20)\)</span>，<span class="math inline">\(m\ (10\leq m\leq 1000)\)</span>，分别表示行数和列数。接下来 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列，表示迷宫的情况，数字范围为<span class="math inline">\(-1000\sim 1000\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出只有一行，表示玩家到达出口时剩余的最多卡片数。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3 8<br>9 10 10 10 10 -10 10 10<br>10 -11 -1 0 2 11 10 -20<br>-11 -11 10 11 2 10 -10 -10</td><td>52</td></tr></tbody></table><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxm], arr[maxn][maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a&lt;b ? b : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, k, n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">  dp[<span class="number">1</span>][<span class="number">1</span>] = max(<span class="number">0</span>, arr[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= n) dp[i + <span class="number">1</span>][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j] + arr[i + <span class="number">1</span>][j]);</span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= m) dp[i][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i][j] + arr[i][j + <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">2</span>*j; k &lt;= m; k+=j)&#123;</span><br><span class="line">        dp[i][k] = max(dp[i][k], dp[i][j] + arr[i][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>填表法：设<span class="math inline">\(dp[i][j]\)</span>表示从<span class="math inline">\((1,1)\)</span>到达<span class="math inline">\((i,j)\)</span>位置时能够获得的最多卡片数。则由题意描述，容易得到状态转移方程：<span class="math inline">\(dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i][j-1],dp[i,j/fk])+a[i][j]\)</span> （<span class="math inline">\(fk\)</span>表示<span class="math inline">\(j\)</span> 的因子，需要预处理出<span class="math inline">\(j\)</span>的所有因子)。下图为当<span class="math inline">\((i,j)=(3,8)\)</span>时的一个例子。</p><p><img src="p20/填表法.jpg" title="填表法，阴影代表已完成计算的节点。"></p><p>刷表法：现在假设我们已经得到从<span class="math inline">\((1,1)\)</span>到达<span class="math inline">\((i,j)\)</span> 这个位置的最优值<span class="math inline">\(dp[i][j]\)</span>，我们利用它去更新下一步能够到达的位置。假设下一步为<span class="math inline">\((i&#39;,j&#39;)\)</span>，则有状态转移方程<span class="math inline">\(dp[i&#39;][j&#39;]=max(dp[i&#39;][j&#39;],dp[i][j]+a[i&#39;][j&#39;])\)</span>。下图为当<span class="math inline">\((i,j)=(2,2)\)</span> 时的例子。</p><p><img src="p20/刷表法.jpg" title="刷表法，阴影代表已完成计算的节点。"></p><p>易知填表法思路直观但需要预处理出所有列的因子，而刷表法不需要预处理出因子。所以刷表法效率高于填表法。刷表法时间复杂度计算如下：</p><p><span class="math display">\[\begin{equation}\begin{split} T(n,m) &amp;=n\times (m+m/2+m/3+m/4+...+m/m)\\\\    &amp;=n\times m\times (1+1/2+1/3+...+1/m)\\\\    &amp;=n\times m\times (ln(m)+C)\\\\    &amp;=O(n\times m\times log(m))\end{split}\end{equation}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 刷表法 </tag>
            
            <tag> 填表法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.5 括号匹配</title>
      <link href="2017/12/24/p19.html"/>
      <url>2017/12/24/p19.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>YellowStar 某天得到了一个长度为 <span class="math inline">\(n\)</span> 的括号序列 <span class="math inline">\(p\)</span>，Yellowstar 现在进行 <span class="math inline">\(m\)</span> 次询问，每次询问一个区间<span class="math inline">\([l,r]\)</span>，他想知道子序列<span class="math inline">\(p_l,p_{l+1},\cdots, p_r\)</span>最大括号匹配数量，请你帮助他。最大括号匹配数量的定义是：这个序列中，最长合法括号子序列的长度。例如“())()”括号序列，他的最长合法括号子序列为“()()”，长度为 4。</p><h1 id="数据输入">数据输入</h1><p>每组样例第输入的第 1 行包含一个长度为 <span class="math inline">\(n\ (1\leq n\leq 10^5)\)</span>的括号序列，<span class="math inline">\(p_1,p_2,\cdots p_n\)</span>。<span class="math inline">\(p_i\)</span>满足是‘(’或‘)’；接下来一行输入一个 <span class="math inline">\(m\)</span>，表示询问次数；接下来 <span class="math inline">\(m\)</span> 行，每行包含两个数字 <span class="math inline">\(l,r\ (1\leq l\leq r \leq n)\)</span>。</p><h1 id="数据输出">数据输出</h1><p>对于每次询问，输出一个数字表示答案。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>())(())(())(<br>7<br>1 2<br>1 1<br>2 3<br>5 11<br>1 12<br>8 12<br>2 10</td><td>2<br>0<br>0<br>6<br>10<br>4<br>6</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n \leq 1000\)</span>，<span class="math inline">\(m \leq 1000\)</span>；<span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n \leq 100000\)</span>，<span class="math inline">\(m \leq 100000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dd(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; <span class="meta-string">", "</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> de(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">char</span> p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, plen;</span><br><span class="line">    Info() &#123;&#125;</span><br><span class="line">    Info(<span class="keyword">int</span> _left, <span class="keyword">int</span> _right, <span class="keyword">int</span> _plen) &#123;</span><br><span class="line">        left = _left, right = _right, plen = _plen;</span><br><span class="line">    &#125;</span><br><span class="line">    Info <span class="keyword">operator</span>+(<span class="keyword">const</span> Info &amp;info) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">//当前节点左右括号数量直接由左右子树括号数累加</span></span><br><span class="line">        <span class="comment">//而配对的括号数为分别配对的括号数之和</span></span><br><span class="line">        <span class="comment">//再加上左子树剩余左括号量与右子树剩余右括号量能够配对的数量</span></span><br><span class="line">        <span class="keyword">return</span> Info(left + info.left, right + info.right,</span><br><span class="line">            plen + info.plen + min(left - plen, info.right - info.plen));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dd(left), dd(right), de(plen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls ((t)&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((t)&lt;&lt;1|1)</span></span><br><span class="line">    Info info[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            info[t] = Info(p[l] == <span class="string">'('</span>, p[l] == <span class="string">')'</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> z = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            build(ls, l, z), build(rs, z + <span class="number">1</span>, r);</span><br><span class="line">            info[t] = info[ls] + info[rs];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">query</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> info[t];</span><br><span class="line">        <span class="keyword">int</span> z = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= z) <span class="keyword">return</span> query(ls, l, z, L, R);</span><br><span class="line">        <span class="keyword">if</span> (L &gt; z) <span class="keyword">return</span> query(rs, z + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">return</span> query(ls, l, z, L, R) + query(rs, z + <span class="number">1</span>, r, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(p + <span class="number">1</span>), <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        Info result = seg.query(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        <span class="comment">//result.output();</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result.plen &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>单次括号匹配问题可以使用栈来应对，时间复杂度为<span class="math inline">\(O(n)\)</span>。但是此题需要多次查询，如果使用栈，则总时间复杂度为<span class="math inline">\(O(m\times n)\)</span>，显然会超时。于是需要寻找更优秀的算法，现在已经知道查询次数是<span class="math inline">\(m\)</span>无法优化了，所以启发我们去寻找一个将单次查询的复杂度降低一个数量级的算法。即单次查询需要从<span class="math inline">\(O(n)\)</span>降低到<span class="math inline">\(O(logn)\)</span>。</p><p>我们考虑分治策略，将被查询的区间二等分，那么当前区间配对括号数由左右子区间分别配对的括号数之和再加上左区间剩余左括号量与右区间剩余右括号量能够配对的数量。由此推知这是一个区间操作问题，可以使用线段树实现。</p><p>具体实现的时候，当前节点左右括号数量直接由左右子树括号数累加，而配对的括号数为分别配对的括号数之和再加上左子树剩余左括号量与右子树剩余右括号量能够配对的数量。如此复杂度降低为<span class="math inline">\(O(m\times logn)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 分治策略 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 区间查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.4 序列判定</title>
      <link href="2017/12/23/p18.html"/>
      <url>2017/12/23/p18.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>YellowStar 某天得到了一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，他要判定这个序列的好坏。定义一个序列为好序列应当满足：它的所有连续子序列，至少包含了一个在该子序列中只出现一次的数字。否则这个序列为坏序列。请你帮他判定序列是不是好序列。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为数字 <span class="math inline">\(T\)</span>，表示有 <span class="math inline">\(T\)</span> 组样例每组样例第输入的第 1 行为数字 <span class="math inline">\(n\ (1\leq n\leq 10^3)\)</span>，表示序列长度。接下来 1 行包含 <span class="math inline">\(n\)</span> 个数字，<span class="math inline">\(a_1,a_2,\cdots ,a_n\ (1 \leq a_i \leq 10^9)\)</span>。</p><h1 id="数据输出">数据输出</h1><p>对于每个样例，输出”Good”表示好序列，”Bad” 表示坏序列。(注意输出不包含引号)</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3<br>5<br>6 2 3 2 6<br>5<br>6 2 3 4 5<br>5<br>1 2 1 2 1</td><td>Good<br>Good<br>Bad</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n \leq 100\)</span>；<span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n \leq 1000\)</span>。</p><p><span id="fenzhi"></span></p><h1 id="源代码分治">源代码（分治）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="keyword">int</span> mydata[maxn];</span><br><span class="line"><span class="keyword">int</span> mymap[maxn];</span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//分治算法：最坏情况是n^2，平均情况是O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isGood</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//长度不够的序列直接返回</span></span><br><span class="line">    <span class="built_in">memset</span>(mymap, <span class="number">0</span>, <span class="keyword">sizeof</span>(mymap));</span><br><span class="line">    <span class="keyword">int</span> i, diffL, diffR;</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt; right; ++i)<span class="comment">//标记每个数出现次数</span></span><br><span class="line">        ++mymap[mydata[i]];</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (diffL = mid - <span class="number">1</span>; diffL &gt;= left; --diffL)</span><br><span class="line">        <span class="keyword">if</span> (mymap[mydata[diffL]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//左起最右</span></span><br><span class="line">    <span class="keyword">for</span> (diffR = mid; diffR &lt; right; ++diffR)</span><br><span class="line">        <span class="keyword">if</span> (mymap[mydata[diffR]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//右起最左</span></span><br><span class="line">    <span class="keyword">if</span> (diffL == left - <span class="number">1</span> &amp;&amp; diffR == right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没有唯一数返回false</span></span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">return</span> isGood(left, diffL)</span><br><span class="line">        &amp;&amp; isGood(diffL + <span class="number">1</span>, diffR)</span><br><span class="line">        &amp;&amp; isGood(diffR + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> mydata[a] &lt; mydata[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preprocess</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//排序，压缩，再回排 --&gt; 下标排序可以节省回排的时间！！！</span></span><br><span class="line">    <span class="keyword">int</span> i, temp = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    sort(pos, pos + n, cmpData);</span><br><span class="line">    temp = mydata[pos[<span class="number">0</span>]];</span><br><span class="line">    mydata[pos[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mydata[pos[i]] == temp)</span><br><span class="line">            mydata[pos[i]] = count;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = mydata[pos[i]];</span><br><span class="line">            mydata[pos[i]] = ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mydata[i]);</span><br><span class="line">            pos[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        preprocess(n);<span class="comment">//预处理：将无意义的数据压缩到n，复杂度O(nlogn)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isGood(<span class="number">0</span>, n) ? <span class="string">"Good"</span> : <span class="string">"Bad"</span>);<span class="comment">//判断是否满足条件，复杂度O(nlogn)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>首先需要将数据离散化：题目要求找不同，并没有要求给出这个不同的数是谁，所以<span class="math inline">\(a_i\)</span>的具体值就无意义了。另一方面<span class="math inline">\(Z_1:1\leq n\leq 10^3\)</span>，<span class="math inline">\(Z_2:1\leq a_i\leq 10^9\)</span>。由此，可以生成一个<span class="math inline">\(Z_1\)</span>到<span class="math inline">\(Z_2\)</span>的映射，使得可以使用数组来标记每一个数出现的次数。</p><p>然后使用分治策略：寻找一个串中最靠近中间的唯一数，如果不存在，则返回<span class="math inline">\(false\)</span>。如果存在，则该串中包含当前数字的子串都满足要求，则可以直接判断左边和右边不包含当前字符的两个子串的所有子串是否满足条件。具体实现的时候还有一个可以优化的点是已经找出串中的两个唯一数，其实只要包含这两个数中的任一个的子串都是符合要求的。</p><p>复杂度分析：算法实现类似快排，平均时间复杂度<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度<span class="math inline">\(O(n^2)\)</span>。</p><h1 id="源代码线段树">源代码（线段树）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], v[maxn], L[maxn], R[maxn], last[maxn];</span><br><span class="line">pii seg[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls ((t)&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((t)&lt;&lt;1|1)</span></span><br><span class="line">    <span class="keyword">int</span> count[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        count[t] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            build(ls, l, z), build(rs, z + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;count[t] += V;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> z = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= z) &#123;update(ls, l, z, L, R, V);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; z) &#123;update(rs, z + <span class="number">1</span>, r, L, R, V);&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            update(ls, l, z, L, R, V);</span><br><span class="line">            update(rs, z + <span class="number">1</span>, r, L, R, V);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count[t] &gt; <span class="number">0</span>) <span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> z = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= z) <span class="keyword">return</span> query(ls, l, z, L, R);</span><br><span class="line">        <span class="keyword">if</span> (L &gt; z) <span class="keyword">return</span> query(rs, z + <span class="number">1</span>, r, L, R);</span><br><span class="line">        <span class="keyword">return</span> query(ls, l, z, L, R) + query(rs, z + <span class="number">1</span>, r, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pii &amp;a, <span class="keyword">const</span> pii &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.fi &lt; b.fi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seg_index = <span class="number">0</span>, i;</span><br><span class="line">    tree.build(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (seg_index &lt; n &amp;&amp; seg[seg_index].fi == i) &#123;</span><br><span class="line">            <span class="comment">//覆盖所有p（i被p的左区间覆盖）的右区间</span></span><br><span class="line">            <span class="keyword">int</span> pos = seg[seg_index++].se;</span><br><span class="line">            tree.update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, pos, R[pos] - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果[i,n-1]没有全部被覆盖，说明存在包含左端点i的坏序列</span></span><br><span class="line">        <span class="keyword">int</span> len = tree.query(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; n - i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//删除中点为i的右区间的贡献[i,R[i]-1]，因为下一步已经不包含i了</span></span><br><span class="line">        tree.update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, R[i] - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n, m, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">0</span>; cas &lt; T; ++cas) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i), v[i] = a[i];</span><br><span class="line">        <span class="comment">// compress</span></span><br><span class="line">        sort(v, v + n);</span><br><span class="line">        m = unique(v, v + n) - v;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; ++i) a[i] = lower_bound(v, v + m, a[i]) - v;</span><br><span class="line">        <span class="comment">// get L[i] - same value with max index at the left of i</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;m; ++i) last[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; ++i) L[i] = last[a[i]], last[a[i]] = i;</span><br><span class="line">        <span class="comment">// get R[i] - same value with min index at the right of i</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;m; ++i) last[i] = n;</span><br><span class="line">        <span class="keyword">for</span> (i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) R[i] = last[a[i]], last[a[i]] = i;</span><br><span class="line">        <span class="comment">// get left intervals</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; ++i) seg[i] = mp(L[i] + <span class="number">1</span>, i);</span><br><span class="line">        sort(seg, seg + n, cmp);</span><br><span class="line">        <span class="built_in">puts</span>(solve(n) ? <span class="string">"Good"</span> : <span class="string">"Bad"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析-1">设计思路与复杂度分析</h1><p>此代码使用了线段树，线段树其实也是分治，时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。现分析如下（至于线段树的知识自己参考互联网资料）。</p><p>预处理阶段： 1. 将数据离散化，思想与<a href="#fenzhi">分治</a>一致，活用STL使得代码更简洁； 2. 获取每一个中点的最大影响区间的左端点<span class="math inline">\(L[i]:i\)</span>左边的与<span class="math inline">\(a[i]\)</span>相同的下标最大的数； 3. 获取每一个中点的最大影响区间的右端点<span class="math inline">\(R[i]:i\)</span>右边的与<span class="math inline">\(a[i]\)</span>相同的下标最小的数； 4. 获取每一个左区间并按左端点排序（知道了左区间其右区间可以迅速查找到），注意前两步获取的区间端点是无效的，此步骤左区间左端点已经是有效的了。此时左区间为闭区间间，而右区间为左闭右开区间。按左区间排序的目的是一会儿要由左向右以左端点为基准扫描。</p><p>区间覆盖阶段：</p><p>设当前扫描到第i个位置，第<span class="math inline">\(i-1\)</span>个数<span class="math inline">\(a[i-1]\)</span> 作为左端点的最大影响区间是<span class="math inline">\([p,R[p]-1]\)</span>（<span class="math inline">\(p\)</span>为该左区间的右端点）。也就是他能保证任何<span class="math inline">\([l,r]\ (p\leq l\leq r\leq R[p]-1)\)</span> 的序列是合法的。每次我们考虑<span class="math inline">\(i\ (0\leq i &lt; n)\)</span> 的所有影响区间与在<span class="math inline">\(i\)</span>之前加入的影响区间一起能 否完全覆盖<span class="math inline">\([i,n-1]\)</span>这个大区间（能覆盖<span class="math inline">\([i,n-1]\)</span>这个大区间说明如下区间都是好的：<span class="math inline">\([i,i+1],[i,i+2],\cdots ,[i,n-1]\)</span>，其中右端点为<span class="math inline">\([i,p-1]\)</span> 的区间的合法性由中点为<span class="math inline">\(i\)</span> 的区间保证，他们可能在之前就被覆盖了。），如果能则说明所有以<span class="math inline">\(i\)</span> 为起点的子序列都是满足条件的，这样我们就可以<span class="math inline">\(++i\)</span> 然后重复之前的步骤，否则说明以<span class="math inline">\(i\)</span> 为起点的子序列中存在坏序列，直接结束退出。</p><p>但是当<span class="math inline">\(i\)</span>往右移动的时候，某一次加入的以<span class="math inline">\(i\)</span> 为中点的覆盖会失效（因为以后的区间已经不包含<span class="math inline">\(i\)</span>），所以需要在<span class="math inline">\(i\)</span>右移之前将该区间清除掉。一定会存在这个区间，它是在第<span class="math inline">\(i\)</span>个点作为中点（左区间为<span class="math inline">\((l,i)\ (l\leq i)\)</span>，右区间为<span class="math inline">\((i,R[i]-1)\)</span>）的时候覆盖进来的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 分治策略 </tag>
            
            <tag> 离散化 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 区间覆盖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3 历史账单</title>
      <link href="2017/12/23/p17.html"/>
      <url>2017/12/23/p17.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>YellowStar 有一些历史账单，每个账单有两个属性，时间 <span class="math inline">\(t\)</span> 和金额<span class="math inline">\(c\)</span>，现在他要把这些账单信息储存起来，但是由于业务繁忙，在储存过程中可能会发生查询，查询内容为：某一时间 <span class="math inline">\(t\)</span> 之前(包括 <span class="math inline">\(t\)</span> 时刻)金额为 <span class="math inline">\(c\)</span> 的账单数量。对于每次查询，请你帮助Yellowstar 计算出数量。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为数字 <span class="math inline">\(n\ (1\leq n\leq 10^5)\)</span>，表示事件数。</p><p>接下来 <span class="math inline">\(n\)</span> 行，每行包含 3 个整数，<span class="math inline">\(tp_i, t_i, c_i\ (1 \leq tp_i\leq 2, 1\leq t_i, c_i\leq 10^9)\)</span>。</p><p><span class="math inline">\(tp_i = 1\)</span> 时，表示 Yellowstar 插入一条时间为 <span class="math inline">\(t_i\)</span>, 价值为 <span class="math inline">\(c_i\)</span>的账单信息；</p><p><span class="math inline">\(tp_i = 2\)</span> 时，表示查询时间在 <span class="math inline">\(t_i\)</span> 之前（包括 <span class="math inline">\(t_i\)</span> 时刻），价值为 <span class="math inline">\(c_i\)</span>的账单数量。</p><h1 id="数据输出">数据输出</h1><p>对于每次询问，输出一个整数表示答案。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>6<br>1 1 5<br>2 3 5<br>1 3 5<br>2 3 5<br>2 2 5<br>2 5 4</td><td>1<br>2<br>1<br>0</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n \leq 1000\)</span>；<span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n \leq 100000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> tp[maxn], ti[maxn], ci[maxn];</span><br><span class="line"><span class="keyword">int</span> qid[maxn], id[maxn];<span class="comment">//共用cid与id</span></span><br><span class="line"><span class="keyword">int</span>  sumv[maxn], ran[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//位置p，增加v，更新到n</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">        sumv[p] += v;</span><br><span class="line">        p += p&amp;-p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//返回位置p的前缀和</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        ret += sumv[p];</span><br><span class="line">        p -= p&amp;-p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;<span class="comment">//按照金额稳定排序</span></span><br><span class="line">    <span class="keyword">return</span> ci[x]&lt;ci[y] || ci[x] == ci[y] &amp;&amp; id[x]&lt;id[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照时间排序，第二项保证题目的要求：相同时间的情况下先插入再查询</span></span><br><span class="line">    <span class="keyword">return</span> ti[x]&lt;ti[y] || ti[x] == ti[y] &amp;&amp; tp[x]&lt;tp[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用树状数组分别离线处理每一个c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ran[i] = id[i] = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;tp[i], &amp;ti[i], &amp;ci[i]);</span><br><span class="line">        <span class="keyword">if</span> (tp[i] == <span class="number">2</span>) qid[i] = q++;<span class="comment">//标记qid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(q, <span class="number">0</span>)</span></span>;</span><br><span class="line">    sort(ran, ran + n, cmpc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = j) &#123;</span><br><span class="line">        <span class="comment">//处理相同的c</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ci[ran[j]] != ci[ran[i]])<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//到这里id与之前的id已经意义不同了，之前是操作id，而现在是cid</span></span><br><span class="line">            id[ran[j]] = j - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ran + i, ran + j, cmpt);</span><br><span class="line">        <span class="built_in">memset</span>(sumv + <span class="number">1</span>, <span class="number">0</span>, (j - i + <span class="number">1</span>)*<span class="keyword">sizeof</span>(sumv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (k = i; k&lt;j; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ran[k];</span><br><span class="line">            <span class="keyword">if</span> (tp[v] == <span class="number">2</span>) ans[qid[v]] = get_sum(id[v]);</span><br><span class="line">            <span class="keyword">else</span> add(id[v], <span class="number">1</span>, j - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;q; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>考虑到本题金额属性无实际意义，故以离线方式处理，即以金额属性<span class="math inline">\(c\)</span>相同的作为一批处理，这样即可去掉账单的金额属性<span class="math inline">\(c\)</span>。操作1转变为每次插入一个值<span class="math inline">\(t_i\)</span>，操作2 转变为查询已经插入的数中值<span class="math inline">\(\leq t_i\)</span> 的总数。</p><p>现在问题转变为一个单点更新，在线求前缀和的问题，可使用树状数组处理。但是树状数组要求<span class="math inline">\(t\)</span>连续，一个策略是对<span class="math inline">\(t\)</span>进行离散化，而更优的方法是为每一个输入添加一个<span class="math inline">\(cid\)</span>属性，并以<span class="math inline">\(t\)</span>为关键字排序，而处理的时候以<span class="math inline">\(cid\)</span>的顺序处理。即插入的时候直接插入<span class="math inline">\(cid_i\)</span>，查询的时候查询<span class="math inline">\(\leq cid_i\)</span>。</p><p>但是这样做之后处理顺序与输入顺序不一致，如果直接输出会导致输出顺序不正确，所以需要使用<span class="math inline">\(qid\)</span>标记查询顺序，最后按照<span class="math inline">\(qid\)</span>输出即可。</p><p>对于本题的情形，需要为每一个元素维护许多信息，这样直接对元素排序时移动元素的代价比较大。一个优化策略是使用下标排序：新建一个<span class="math inline">\(rank\)</span> 数组，排完序之后<span class="math inline">\(rank_i\)</span>表示的是排名为<span class="math inline">\(i\)</span>的元素所在的位置。实现上只需以下三个步骤： 1. 初始化<span class="math inline">\(rank\)</span>数组：<code>for (int i=0; i&lt;n; ++i) {rank[i]=i;}</code>； 2. 自定义以<span class="math inline">\(rank_i\)</span>为下标的比较函数：<code>bool cmp(int x, int y){return ci[x] &lt; ci[y];}</code>； 3. 排序：<code>sort(rank, rank + n, cmp)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 分治策略 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 原地排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARIA Documentation</title>
      <link href="2017/12/19/p16.html"/>
      <url>2017/12/19/p16.html</url>
      
        <content type="html"><![CDATA[<h1 id="pioneer-reference">Pioneer Reference</h1><p><a href="../../../../Aria/Aria-Reference/index.html">ARIA Index</a></p><p><a href="../../../../Aria/ArNetworking-Reference/index.html">ArNetworking Index</a></p><p><a href="../../../../Aria/BaseArnl-Reference/index.html">BaseArnl Index</a></p><p><a href="../../../../Aria/Arnl-Reference/index.html">ARNL Index</a></p><p><a href="../../../../Aria/SonArnl-Reference/index.html">SONARNL Index</a></p>]]></content>
      
      
      <categories>
          
          <category> 先锋机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pioneer </tag>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2 消除方块</title>
      <link href="2017/12/13/p15.html"/>
      <url>2017/12/13/p15.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>YellowStar 有 <span class="math inline">\(n\)</span> 个方块排成一列，标号为 1 到 <span class="math inline">\(n\)</span>，每个方块有两个属性 <span class="math inline">\(a\)</span>、 <span class="math inline">\(b\)</span>。现在他要把这些方块一个接一个的消除掉，每次消除一个方块，Yellowstar 需要花费当前方块的 <span class="math inline">\(a\)</span> 数值，加上当前方块左边和右边的第一个方块的 <span class="math inline">\(b\)</span> 数值的总和的代价（如果左边或右边没有方块，则没有代价）。一个方块被消除后即消失，其余方块顺序保持不变。</p><p>现在 Yellowstar 可以决定方块的消除顺序，他想花费最小的代价消除掉所有方块，请你帮助他。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为数字 <span class="math inline">\(n\  (2\leq n\leq 200)\)</span>，表示给定方块的个数；第二行包含 <span class="math inline">\(n\)</span> 个整数，表示方块的第一个属性 <span class="math inline">\(a_1, a_2, \cdots, a_n\ (0\leq a_i\leq 10^5)\)</span>；第三行包含 <span class="math inline">\(n\)</span> 个整数，表示方块的第二个属性 <span class="math inline">\(b_1, b_2, \cdots, b_n\ (0\leq b_i\leq 10^5)\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出一个整数，表示最小代价。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3<br>3 5 7<br>8 2 0</td><td>17</td></tr><tr class="even"><td>5<br>0 0 0 0 0<br>10 50 100 50 10</td><td>190</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n \leq 10\)</span>；<span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n \leq 200\)</span>。</p><h1 id="提示">提示</h1><p>样例 1 最优顺序为，消除 1 方块，消除 2 方块、 消除 3 方块。消除 1 方块 <span class="math inline">\(3+2=5\)</span>，消除 2 方块 <span class="math inline">\(5+0=5\)</span>，消除 3 方块 <span class="math inline">\(7+0=7\)</span>。总代价为：<span class="math inline">\(5+5+7=17\)</span>。</p><p>样例 2 最优顺序为，消除 3 方块，消除 2 方块、 消除 4 方块、 消除 1 方块、 消除 5方块。消除 3 方块 <span class="math inline">\(50+50=100\)</span>，消除 2 方块 <span class="math inline">\(50+10=60\)</span>，消除 4 方块 <span class="math inline">\(10+10=20\)</span>，消除 1 方块 10，消除 5 方块 0。</p><p>总代价为：<span class="math inline">\(100+60+20+10+0=190\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 205</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i) &#123; dp[i][j] = b[j - <span class="number">1</span>] + b[j + <span class="number">1</span>]; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == i) &#123;</span><br><span class="line">                    dp[i][j] = dp[k + <span class="number">1</span>][j] + b[i - <span class="number">1</span>] + b[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (k == j) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k - <span class="number">1</span>] + b[i - <span class="number">1</span>] + b[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k - <span class="number">1</span>] + dp[k + <span class="number">1</span>][j] + b[i - <span class="number">1</span>] + b[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间dp问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n, suma = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[<span class="number">1</span>]);<span class="comment">//借用一下</span></span><br><span class="line">        suma += b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    b[<span class="number">0</span>] = b[n + <span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//增加两个空白方块方便处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, suma + solve(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>首先，无论以什么顺序处理，每一个<span class="math inline">\(a\)</span>都只会被累加一次，所以<span class="math inline">\(a\)</span>可以不参与算法过程而直接将<span class="math inline">\(\sum _{i=1}^{n}{a_i}\)</span>加到算法结果中即可。</p><p>对于<span class="math inline">\(b\)</span>的处理考虑分治算法。假设最后一个消除的方块为<span class="math inline">\(k\)</span>时，有<span class="math inline">\([l,k-1]\)</span>和<span class="math inline">\([k+1,r]\)</span>两个区间的所有方块都已经消除，且消除这两个区间的代价已知。则只需将左右区间以及消除<span class="math inline">\(k\)</span> 的代价加起来即可得到消除整个区间<span class="math inline">\([l,r]\)</span>的代价。但是，并没有足够的条件确定<span class="math inline">\(k\)</span>的具体值，所有需要遍历<span class="math inline">\(k\in [l,r]\)</span>。以<span class="math inline">\(k\)</span>为最后一个被消除的作为出发点而不是第一个的原因在于，<span class="math inline">\(k\)</span>作为最后一个的时候其左右子区间的区间端点是明确的，而以<span class="math inline">\(k\)</span>作为第一个的时候其左右子区间的区间端点不明确。</p><p>但是本题仅仅考虑分治还不够，复杂度过高。仔细推敲上面的分治算法会发现，算法在递归的时候会重复计算许多相同子区间的代价。这满足重叠子问题的性质，所以可以使用动态规划算法加速分治过程。算法时间复杂度为：<span class="math inline">\(O(n^3)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分治策略 </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1 序列求解</title>
      <link href="2017/12/12/p14.html"/>
      <url>2017/12/12/p14.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>对于一个包含 <span class="math inline">\(n\)</span> 个整数的序列 <span class="math inline">\(a_1, a_2, \cdots, a_n\)</span>。定义：</p><p><span class="math display">\[f(i,j)=(j-i)^2+(\sum _{k=i+1}^{j}{\alpha{_k}})^2.\]</span> 现要求计算出所有<span class="math inline">\(f(i,j)\ (1\leq i &lt; j \leq n)\)</span>中的最小值。</p><h1 id="数据输入">数据输入</h1><p>输入的第一行为数字 <span class="math inline">\(n\  (2\leq n\leq 10^5)\)</span>，表示给定序列的长度。第二行包含 <span class="math inline">\(n\)</span> 个整数，表示序列中的整数 <span class="math inline">\(a_1, a_2, \cdots, a_n\ (|a_i|\leq 10^4)\)</span>。</p><h1 id="数据输出">数据输出</h1><p>输出一个整数，即对于所有<span class="math inline">\(f(i,j)\ (1\leq i &lt; j \leq n)\)</span> 中的最小值。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>4<br>1 0 0 -1</td><td>1</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n \leq 1000\)</span>；<span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n \leq 100000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> __int64 ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = ll(<span class="number">9e18</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;p[N], tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmpY</span><span class="params">(<span class="keyword">const</span> P&amp;a, <span class="keyword">const</span> P&amp;b)</span></span>&#123; <span class="keyword">return</span> a.y&lt;b.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">square</span><span class="params">(ll x)</span></span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll x, ll y)</span></span>&#123; <span class="keyword">return</span> x&lt;y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Cpair</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="comment">//x轴使用下标，数据本身已经平均分布了，无需考虑左右子集不平衡问题</span></span><br><span class="line">    <span class="keyword">int</span> m = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> Xm = p[m].x;</span><br><span class="line">    ll lim = min(Cpair(left, m), Cpair(m + <span class="number">1</span>, right));</span><br><span class="line">    <span class="comment">//递归返回的时候两个子段已经有序，合并时间为O(n)，注意稳定排序重载运算符会报错。</span></span><br><span class="line">    <span class="built_in">std</span>::inplace_merge(p + left, p + m + <span class="number">1</span>, p + right + <span class="number">1</span>, cmpY);</span><br><span class="line">    <span class="keyword">int</span> i, j, counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= right; ++i)</span><br><span class="line">        <span class="keyword">if</span> (square(p[i].x - Xm) &lt;= lim)</span><br><span class="line">            tmp[counter++] = p[i];<span class="comment">//x坐标差不超过±d的所有点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; counter; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; counter; ++j) &#123;</span><br><span class="line">            <span class="comment">//y坐标差不超过±d的所有点，注意到y本身已经有序</span></span><br><span class="line">            <span class="keyword">if</span> (square(tmp[j].y - tmp[i].y) &gt;= lim) <span class="keyword">break</span>;</span><br><span class="line">            ll disq = square(tmp[j].x - tmp[i].x) + square(tmp[j].y - tmp[i].y);</span><br><span class="line">            lim = min(lim, disq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sum, a, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        sum += a;</span><br><span class="line">        p[i].x = i, p[i].y = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)Cpair(<span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>令前缀和（可以预处理出来）<span class="math inline">\(sum_i=\sum_{j=1}^{i}{\alpha{_j}}\)</span>，则<span class="math inline">\(f(i,j)=(j-i)^2+(sum_j-sum_i)^2\)</span>。令二维平面上的点<span class="math inline">\(p_i = (i,sum_i)\)</span>，则<span class="math inline">\(f(i,j) = (distance(i,j))^2\)</span>。目标函数为<span class="math inline">\(\min f(i,j)= \min (distance(i,j))^2\)</span>，即将问题转化为二维平面的最近点对问题。关于最近点对的知识点请参考教材P29。</p><p>算法耗时最多在归并排序（平衡），复杂度为<span class="math inline">\(O(nlogn)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 分治策略 </tag>
            
            <tag> 最近点对问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5 枚举子集</title>
      <link href="2017/12/12/p13.html"/>
      <url>2017/12/12/p13.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>对于两个不同的整数集合 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span>，我们根据两个集合的字典序来比较它们的大小。具体来说：</p><ol type="1"><li>先从两个集合中各自取出最大的元素 <span class="math inline">\(a_1\)</span> 和 <span class="math inline">\(b_1\)</span>进行比较，若 <span class="math inline">\(a_1&lt;b_1\)</span>或 <span class="math inline">\(a_1\)</span> 不存在（即 <span class="math inline">\(A\)</span> 为空集），那么 <span class="math inline">\(A&lt;B\)</span>，反之亦然；</li><li>若最大的元素 <span class="math inline">\(a_1\)</span>和 <span class="math inline">\(b_1\)</span>相等，再取出各自第二大的元素 <span class="math inline">\(a_2\)</span>和 <span class="math inline">\(b_2\)</span>比较。若 <span class="math inline">\(a_2&lt;b_2\)</span>或 <span class="math inline">\(a_2\)</span>不存在（即 <span class="math inline">\(A\)</span> 中只有一个元素），那么<span class="math inline">\(A&lt;B\)</span>，反之亦然；</li><li>若 <span class="math inline">\(a_2\)</span>和 <span class="math inline">\(b_2\)</span>仍相等，则取各自第三大元素进行比较，以此类推。</li></ol><p>（例如：{}&lt;{3}&lt;{3,1}&lt;{3,2}&lt;{4}。）</p><p>按照以上规则，一个集合的所有子集可以按一定顺序从小到大排列。现在给出一个整数集合 <span class="math inline">\(S\)</span> 及两个正整数 <span class="math inline">\(L\)</span>、 <span class="math inline">\(R\)</span>，你需要输出 <span class="math inline">\(S\)</span> 的第 <span class="math inline">\(L\)</span> 小到第 <span class="math inline">\(R\)</span> 小子集。</p><h1 id="数据输入">数据输入</h1><p>输入第一行为一个正整数 <span class="math inline">\(n\)</span>，表示 <span class="math inline">\(S\)</span> 中的元素数目。第二行 <span class="math inline">\(n\)</span> 个整数，表示 <span class="math inline">\(S\)</span> 中的元素，以空格隔开；元素大小在 <span class="math inline">\(int\)</span> 范围内。第三行两个正整数 <span class="math inline">\(L\)</span>、 <span class="math inline">\(R\)</span>，含义如上。</p><h1 id="数据输出">数据输出</h1><p>按从小到大的顺序输出 <span class="math inline">\(S\)</span> 的第 <span class="math inline">\(L\)</span> 小到第 <span class="math inline">\(R\)</span> 小子集，每个子集一行；每行最外层为大括号“{}”，括号中从大到小列出子集的元素。若元素个数大于 2，相邻元素以逗号“,”隔开。详见以下示例。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3<br>3 4 1<br>1 5</td><td>{}<br>{1}<br>{3}<br>{3,1}<br>{4}</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(L\leq R\leq 2^n\)</span>，<span class="math inline">\(R-L\leq 1000\)</span>，集合中元素不重复。<span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n\leq 10\)</span>，其余 <span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n\leq 30\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 31</span></span><br><span class="line"><span class="keyword">int</span> Set[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">    <span class="keyword">bool</span> isfirst = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//从第0位开始</span></span><br><span class="line">        <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isfirst) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, Set[i]);</span><br><span class="line">                isfirst = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">",%d"</span>, Set[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> n, left, right;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Set[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;left, &amp;right);</span><br><span class="line">    sort(Set, Set + n);</span><br><span class="line">    <span class="keyword">for</span> (i = left - <span class="number">1</span>; i &lt; right; ++i)</span><br><span class="line">        print(i, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>首先数据范围<span class="math inline">\(n\leq 30\)</span>，其次通过观察可以发现集合顺序与二进制顺序高度一致。所以可以将问题转化为一个数二进制表示时1出现的位置。时间复杂度为<span class="math inline">\(O(n(R-L))\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>先锋机器人VS2013开发环境配置</title>
      <link href="2017/12/12/p12.html"/>
      <url>2017/12/12/p12.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装sdk">安装SDK</h1><p>按照以下顺序安装所有软件即可： 1. ARIA：接口控制库，包含了通信接口库（ArNetworking）； 2. BaseArnl：ARNL库的基础SDK必须先于ARNL安装。 3. ARNL：高精度室内激光定位库； 4. Mapper3：地图绘制软件； 5. MobileEyes：远程界面GUI； 6. MobileSim：机器人仿真软件； 7. SONARNL：室内声纳定位库。</p><h1 id="设置aria和arnl环境变量">设置ARIA和ARNL环境变量</h1><p>路径：计算机图标上右键&gt;&gt;属性&gt;&gt;高级系统设置&gt;&gt;环境变量</p><p>在系统变量里面里面添加如下两项： 1. 变量：ARIA_DIR，值：ARIA安装路径 2. 变量：ARNL_DIR，值：ARNL安装路径</p><p>在系统变量的Path中附加以下两项内容： 1. %ARIA_DIR%; 2. %ARNL_DIR%;</p><h1 id="配置vs2013属性表">配置vs2013属性表</h1><p>先在vs2013中新建一个Win32控制台应用程序再继续下面的步骤。</p><p>每一个vs项目都有自己的属性表，属性表中保存了IDE编译项目需要知道的所有信息。每一个应用都至少有两种编译模式，Release和Debug模式。Debug模式包含许多调试信息，所以使用Debug模式编译的代码可以很容易的查找bug。相反，Release模式是优化过的版本，其目标是让应用尽可能快和尽可能小。所以这两个模式需要使用不同的属性表，需要在属性管理器中分别配置，属性管理器可以在视图菜单中打开。</p><p><img src="p12/打开属性管理器.jpg"></p><p>分别为每个模式添加一个新的属性表，添加所有信息到这个属性表中。这样做的好处是显然的，我们可以重复使用该属性表而不需要每一个项目都去配置。</p><p><img src="p12/添加新的项目属性表.jpg"></p><p>接下来是配置属性表的过程。选择属性表然后右键&gt;&gt;属性。</p><p><img src="p12/属性表属性.jpg"></p><p>定位到C/C++&gt;&gt;常规，在附加包含目录中添加头文件路径。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(ARIA_DIR)\include</span><br><span class="line">$(ARIA_DIR)\ArNetworking\include</span><br><span class="line">$(ARNL_DIR)\include</span><br></pre></td></tr></table></figure></p><p><img src="p12/cpp常规.jpg"></p><p><img src="p12/附加包含目录.jpg"></p><p>定位到连接器&gt;&gt;常规，在附加库目录中添加lib文件路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(ARIA_DIR)\lib</span><br><span class="line">$(ARNL_DIR)\lib</span><br></pre></td></tr></table></figure><p><img src="p12/连接器常规.jpg"></p><p><img src="p12/附加库目录.jpg"></p><p>定位到连接器&gt;&gt;输入，在附加依赖项中添加依赖的lib文件，注意这里Debug模式和Release模式的区别。</p><p><img src="p12/连接器输入.jpg"></p><p>Debug模式： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AriaDebugVC12.lib</span><br><span class="line">ArNetworkingDebugVC12.lib</span><br><span class="line">ArnlDebugVC12.lib</span><br><span class="line">BaseArnlDebugVC12.lib</span><br></pre></td></tr></table></figure></p><p><img src="p12/附加依赖项Debug.jpg"></p><p>Release模式： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AriaVC12.lib</span><br><span class="line">ArNetworkingVC12.lib</span><br><span class="line">BaseArnlVC12.lib</span><br><span class="line">ArnlVC12.lib</span><br></pre></td></tr></table></figure></p><p><img src="p12/附加依赖项Release.jpg"></p><h1 id="重用属性表">重用属性表</h1><p>刚才配置好的属性表在项目路径中，可以将其备份出来备用。</p><p><img src="p12/属性表位置.jpg"></p><p>当以后新建项目的时候无需重新配置，只需要将现有属性表添加到项目中即可。</p><p><img src="p12/添加现有属性表.jpg"></p><p>大功告成，拷贝一个样例进去测试一下吧！</p>]]></content>
      
      
      <categories>
          
          <category> 先锋机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs2013 </tag>
            
            <tag> 环境变量 </tag>
            
            <tag> 属性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4 找不同</title>
      <link href="2017/12/11/p11.html"/>
      <url>2017/12/11/p11.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>对于一个数组，可以玩很多次找不同；每次提问会给出一个位置范围<span class="math inline">\([L,R]\)</span>及一个数 <span class="math inline">\(x\)</span>，你要做的是：在数组的第 <span class="math inline">\(L\)</span> 个数到第 <span class="math inline">\(R\)</span> 个数中，找出第一个不是 <span class="math inline">\(x\)</span>的数所在的位置（即它在整个数组中是第几个数）。</p><h1 id="数据输入">数据输入</h1><p>输入第一行为两个正整数 n,q，表示数组长度及“找不同” 的次数。接下去一行 n 个正整数，表示数组，以空格隔开。接下去 q 行，每行三个正整数 L,R,x,表示一次提问。</p><h1 id="数据输出">数据输出</h1><p>依次对每个提问输出答案。如果没有满足条件的数，输出” -1” 。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>6 4<br>1 2 1 1 3 5<br>1 4 1<br>2 6 2<br>3 4 1<br>3 4 2</td><td>2<br>3<br>-1<br>3</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p>数组中的元素及每次询问的 <span class="math inline">\(x\leq 10^9\)</span>；<span class="math inline">\(1\leq L\leq R\leq n\)</span>；<span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n, q\leq 1000\)</span>；其余 <span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n, q\leq 200000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    Difference() :data(<span class="number">0</span>), next(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Difference dif[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理：连接相邻相同区间，如此查找复杂度降为O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dif[i].data);</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        dif[i].next = dif[i].data != dif[i + <span class="number">1</span>].data ? i + <span class="number">1</span> : dif[i + <span class="number">1</span>].next;</span><br><span class="line">    <span class="keyword">int</span> L, R, x;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;L, &amp;R, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (dif[L].data != x)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dif[L].next &lt;= R ? dif[L].next : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>如果枚举<span class="math inline">\(L\rightarrow R\)</span>，最坏情况需要遍历整个数组，然后发现找不到解，复杂度为<span class="math inline">\(O(n\times q)\)</span>。 最坏情况下，因为相同的值导致需要遍历很多不需要的位置，那么就可以合并位置相邻且数值相同的数为一个数段。这样，如果位置<span class="math inline">\(L\)</span>的值不是<span class="math inline">\(x\)</span>，则答案就是<span class="math inline">\(L\)</span>，否则答案为下一个数段的起始位置。如果下一个数段超出询问区间则返回<span class="math inline">\(-1\)</span>。这样预处理之后，查找复杂度降为<span class="math inline">\(O(1)\)</span>，整体复杂度降为<span class="math inline">\(O(\max(n,q))\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> next数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3 搬家3</title>
      <link href="2017/12/11/p10.html"/>
      <url>2017/12/11/p10.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小明的东西被打包成一个个箱子，他请了搬家公司，用一辆大卡车运箱子。小明有 <span class="math inline">\(n\)</span> 个箱子，每个箱子有各自的体积，卡车有能装下的总体积上限。每件箱子要么装车要么不装，不能装一部分。</p><p>小明想在不超过总体积上限的前提下，尽可能装满卡车，也就是让卡车的剩 余空间最小。请你求出这个最小剩余空间。</p><h1 id="数据输入">数据输入</h1><p>输入第一行为两个正整数 <span class="math inline">\(n\)</span>, <span class="math inline">\(v\)</span>，表示箱子的数量及总体积上限。接下去 <span class="math inline">\(n\)</span> 个正整数，表示每个箱子的体积，以空格隔开。</p><h1 id="数据输出">数据输出</h1><p>输出一个数，表示最小剩余空间。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3 11<br>3 7 3</td><td>1</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n\leq 12\)</span>，<span class="math inline">\(v\)</span> 及每个箱子的体积<span class="math inline">\(\leq 1000\)</span>；其余 <span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n\leq 100\)</span>，<span class="math inline">\(v\)</span> 及每个箱子的体积<span class="math inline">\(\leq 1000\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, v;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;v);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//第i个箱子是否装车</span></span><br><span class="line">    &#123;   <span class="comment">//当前剩余体积从v遍历到w[i]，保证所有可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= w[i]; j--)<span class="comment">//第i个箱子不装车占用体积为dp[j]</span></span><br><span class="line">        &#123;   <span class="comment">//第i个箱子装车占用体积为dp[j - w[i]] + w[i]，取两者之大</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - w[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v - dp[v]);<span class="comment">//总体积去除占用最多的体积即为剩余体积</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>此题为经典0-1背包问题，注意区分此题与<a href="/2017/12/11/p9">Moving2</a>的区别，<a href="/2017/12/11/p9">Moving2</a>中<span class="math inline">\(n\leq 32\)</span>可用折半枚举，而本题<span class="math inline">\(n\leq 100\)</span>，折半枚举已经无可奈何了。</p><p>当然，上帝为你关上一扇门的时候必然为你开了另一扇窗。观察数据范围还可以发现，箱子体积才<span class="math inline">\(1000\)</span>远小于<a href="/2017/12/11/p9">Moving2</a>，所以可以使用动态规划算法求解。</p><p>此题使用动态规划算法的时间复杂度为：<span class="math inline">\(O(nv)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2 搬家2</title>
      <link href="2017/12/11/p9.html"/>
      <url>2017/12/11/p9.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小明的东西被打包成一个个箱子，他请了搬家公司，用一辆大卡车运箱子。小明有 <span class="math inline">\(n\)</span> 个箱子，每个箱子有各自的体积，卡车有能装下的总体积上限。每件箱子要么装车要么不装，不能装一部分。</p><p>小明想在不超过总体积上限的前提下，尽可能装满卡车，也就是让卡车的剩 余空间最小。请你求出这个最小剩余空间。</p><h1 id="数据输入">数据输入</h1><p>输入第一行为两个正整数 <span class="math inline">\(n\)</span>, <span class="math inline">\(v\)</span>，表示箱子的数量及总体积上限。接下去 <span class="math inline">\(n\)</span> 个正整数，表示每个箱子的体积，以空格隔开。</p><h1 id="数据输出">数据输出</h1><p>输出一个数，表示最小剩余空间。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3 11<br>3 7 3</td><td>1</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p><span class="math inline">\(80\%\)</span>的得分点，<span class="math inline">\(n\leq 12\)</span>，<span class="math inline">\(v\)</span>及每个箱子的体积<span class="math inline">\(\leq 1000\)</span>；其余<span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n\leq 32\)</span>，<span class="math inline">\(v\)</span> 及每个箱子的体积<span class="math inline">\(\leq 10^9\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> n, V, x[N + N], i, j, left, right;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1</span> &lt;&lt; N], b[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bruteforce</span><span class="params">(<span class="keyword">int</span> *d, <span class="keyword">int</span> *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    d[<span class="number">1</span>] = x[<span class="number">0</span>]&gt;V ? V + <span class="number">1</span> : x[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="comment">//第i个以后的物品都不放入背包时的所有情况已考虑</span></span><br><span class="line">        <span class="comment">//前i-1个都已经考虑放与不放的所有情况，共2^i种情况</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;(<span class="number">1</span> &lt;&lt; i); ++j)</span><br><span class="line">        &#123;   <span class="comment">//现在考虑放第i个，只需要在前面的所有结果上加上x[i]即可</span></span><br><span class="line">            <span class="comment">//总共2^i种情况，刚好和不放第i个的所有情况数一样</span></span><br><span class="line">            d[(<span class="number">1</span> &lt;&lt; i) + j] = x[i] + d[j];</span><br><span class="line">            <span class="keyword">if</span> (d[(<span class="number">1</span> &lt;&lt; i) + j] &gt; V) d[(<span class="number">1</span> &lt;&lt; i) + j] = V + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(d, d + (<span class="number">1</span> &lt;&lt; n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半枚举</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;V);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, x + i);</span><br><span class="line">    left = n &gt;&gt; <span class="number">1</span>, right = n - left;</span><br><span class="line">    bruteforce(a, x, left);</span><br><span class="line">    bruteforce(b, x + left, right);</span><br><span class="line">    <span class="keyword">int</span> ans = V;</span><br><span class="line">    <span class="comment">//排序之后只需要a从小到大枚举的同时b从大到小枚举即可</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = (<span class="number">1</span> &lt;&lt; right) - <span class="number">1</span>; i&lt;(<span class="number">1</span> &lt;&lt; left); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ~j&amp;&amp;a[i] + b[j]&gt;V; --j);</span><br><span class="line">        <span class="keyword">if</span> (~j &amp;&amp; (V - a[i] - b[j])&lt;ans)</span><br><span class="line">            ans = V - a[i] - b[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p>当问题的规模较大时，无法枚举所有元素的组合，但能够枚举一半元素的组合。此时可将问题拆成两半后分别枚举，再合并它们的结果。</p><p>本题中<span class="math inline">\(n\leq 32\)</span>，<span class="math inline">\(2^{32}\)</span>数据范围太大，但是<span class="math inline">\(2^{16}\)</span>却是一个可以接受的范围。所以考虑折半枚举算法。</p><p>本题为经典0-1背包问题，能够推导出动态规划的状态转移方程，但是由于<span class="math inline">\(v\)</span>比较大，不能使用动态规划算法求解。注意与<a href="/2017/12/11/p10">Moving3</a>相区分。</p><p>两次枚举时间分别为<span class="math inline">\(O(2^{\frac n2})\)</span>，排序时间分别为<span class="math inline">\(O(n\times 2^{\frac n2-1})\)</span>，合并的时间为<span class="math inline">\(O(2^{\frac n2})\)</span>，所以总时间复杂度为：<span class="math inline">\(O(n\times 2^{\frac n2})\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 折半搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1 搬家1</title>
      <link href="2017/12/11/p8.html"/>
      <url>2017/12/11/p8.html</url>
      
        <content type="html"><![CDATA[<h1 id="实验任务">实验任务</h1><p>小明的家具包含 <span class="math inline">\(n\)</span> 个箱子，每个箱子有各自的重量。由于绳子长度有限，他每次只能把最多 <span class="math inline">\(k\)</span>个箱子绑在一起形成一个新箱子，新箱子的重量为被绑的箱子重量之和。这样绑一次，小明耗费的体力值是被绑的箱子重量之和（即新箱子的重量）。并且新箱子还可以作为一个箱子参与后续的操作。</p><p>小明想经过若干次操作，最终把所有的箱子打包成一个箱子。那么他耗费的总体力值最小是多少？</p><p>例如，假设一开始有 3 个箱子，重量为 1、2、4，<span class="math inline">\(k=2\)</span>。那么可以先把 24 绑在一起形成一个重量为 6 的箱子，再把它和重量为 1 的箱子绑在一起，耗费的总体力值是<span class="math inline">\((2+4)+(6+1)=13\)</span>。也可以先绑 1 和 4 得到 5，再绑 2 和 5，耗费的总体力值是<span class="math inline">\((1+4)+(2+5)=12\)</span>，后一种方案耗费的体力值更小，但这也不是最优的绑法。</p><h1 id="数据输入">数据输入</h1><p>输入第一行为两个正整数 <span class="math inline">\(n\)</span>, <span class="math inline">\(k\)</span>，含义如上。接下去 <span class="math inline">\(n\)</span> 个正整数，表示最开始 <span class="math inline">\(n\)</span> 个箱子的重量，以空格隔开。</p><h1 id="数据输出">数据输出</h1><p>输出一行，表示最小总花费。</p><table><thead><tr class="header"><th>输入示例</th><th>输出示例</th></tr></thead><tbody><tr class="odd"><td>3 2<br>1 2 4</td><td>10</td></tr><tr class="even"><td>5 3<br>1 1 1 1 1</td><td>8</td></tr></tbody></table><h1 id="数据范围">数据范围</h1><p>最开始 <span class="math inline">\(n\)</span> 个箱子的重量均在<span class="math inline">\([1, 1000]\)</span>内；<span class="math inline">\(50\%\)</span>的得分点，<span class="math inline">\(n\leq 3\)</span>，<span class="math inline">\(k=2\)</span>；其余 <span class="math inline">\(30\%\)</span>的得分点，<span class="math inline">\(n\leq 100000\)</span>，<span class="math inline">\(k=2\)</span>；其余 <span class="math inline">\(20\%\)</span>的得分点，<span class="math inline">\(n, k\leq 100000\)</span>，<span class="math inline">\(k\geq 2\)</span>。</p><h1 id="源代码">源代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;pq;</span><br><span class="line">    <span class="keyword">int</span> boxi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;boxi);</span><br><span class="line">        pq.push(-boxi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点，直到满足k叉哈夫曼树的定义</span></span><br><span class="line">    <span class="keyword">while</span> ((n - <span class="number">1</span>) % (k - <span class="number">1</span>))&#123;</span><br><span class="line">        pq.push(<span class="number">0</span>);</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pq.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            temp += pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        total += temp;</span><br><span class="line">        pq.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计思路与复杂度分析">设计思路与复杂度分析</h1><p><span class="math inline">\(k\)</span>叉哈夫曼树需要满足的性质：保证每一个非页节点都有<span class="math inline">\(k\)</span> 个子节点。</p><p>如何保证节点页节点数满足性质？考虑特殊情况：第一次<span class="math inline">\(k\)</span>个叶子节点计算，其余的都是<span class="math inline">\((k-1)\)</span>个叶子节点与刚才生成的分支节点计算。</p><p>反过来考虑：假设第一次也是<span class="math inline">\((k-1)\)</span>个节点参与计算，这样相当于总数少了1，变成了<span class="math inline">\(n-1\)</span>个节点每次<span class="math inline">\((k-1)\)</span>的独立运算！所以当<span class="math inline">\((n-1)\%(k-1)=0\)</span>时，刚好构造一棵<span class="math inline">\(k\)</span>叉树。</p><p>对每一个箱子需要插入优先队列然后从优先队列取出(只是计算复杂度无需考虑生成的中间节点)，所以复杂度为：<span class="math inline">\(O(nlogn)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析习题集 </tag>
            
            <tag> 哈夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome搜索关键词后面加斜杠就搜索失败</title>
      <link href="2017/11/30/p7.html"/>
      <url>2017/11/30/p7.html</url>
      
        <content type="html"><![CDATA[<p>自己遇到的问题，鼓捣了几个小时还是没解决，最后在网上搜索到了解决方案，故备份之：</p><p><strong><a href="https://zhidao.baidu.com/question/570535991.html" target="_blank" rel="noopener">问题</a>：</strong> 我的chrome某一次在地址栏键入搜索内容后不小心在后面加了个斜杠，然后就搜索失败跳到了中国电信网址纠错，之后每次键入该关键词按回车时会自动在后面加个斜杠（如:搜索/）然后就网址纠错了。后面我试了下只要在地址栏输入关键词后加个斜杠，那么以后输入该关键词按回车后浏览器就自动在其后面加个斜杠，然后导致搜索失败。</p><p><strong>问题根源：</strong> 在chrome地址栏中输入文字会自动跳转到谷歌搜索页面，但是斜杠是个比较特殊的符号，用在网址中以分割。你加上一个斜杠chrome就会误识别你的关键词为网址，由于无法访问一个不存在的网站，所以会跳转到网址纠错页面。</p><p><strong><a href="https://zhidao.baidu.com/question/502291145.html" target="_blank" rel="noopener">解决方案</a>：</strong> 在地址栏中输入会搜索失败的内容，地址栏中高亮你要删除的网址，按shift+delete就可以了。切记以后不要再地址栏中输入‘/’啦！！！</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> 搜索失败 </tag>
            
            <tag> 网址纠错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逗比的Wifi开关</title>
      <link href="2017/01/04/p5.html"/>
      <url>2017/01/04/p5.html</url>
      
        <content type="html"><![CDATA[<p>笔记本会出现网卡开机不能用的现象。</p><p>具体表现为：网卡没有禁用，但是搜索不到无线信号。适配器选项框里面选中无线网卡，然后诊断这个链接提示启用无线功能。然后我点击应用此修复就能搜索到无线信号了。问题是，电脑重启之后又不行了。</p><p>什么情况？于是google之。试过网上的所有方法也不行啊，也不一一列举了。最后看到一个帖子说什么<code>windows + x</code>什么的。但是他的后续步骤我是没动。不过我按<code>windows + x</code>后发现一个问题。里面有一个无线网络开关？咦不会是他吧！打开，看看有没有信号！咦还真有了。再确认下？关闭，没了。打开，有了。</p><p>好吧。确定就是这个问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 电脑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wifi </tag>
            
            <tag> 无线网卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于搞定Office 2013中文双引号无法匹配问题啦！！</title>
      <link href="2016/01/10/p4.html"/>
      <url>2016/01/10/p4.html</url>
      
        <content type="html"><![CDATA[<p>设计》》字体》》自定义字体》》所有字体改为宋体》》保存》》点击字体确认当前字体是自己刚新建的》》点击旁边设为默认值》》是》》OK！！！！</p><p>然后可以输入一连串双引号试试！！！重启word再试试！！！</p><p><strong>补充：</strong>哎，最暴力的解决办法来了：用bing输入法。</p>]]></content>
      
      
      <categories>
          
          <category> office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微机接口设计题-预测</title>
      <link href="2015/12/26/p3.html"/>
      <url>2015/12/26/p3.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目资料来源">题目资料来源</h1><p>微机原理与接口技术 第二版 马维华 主编</p><p>P382 10.5题电路原理图修改如下: 1. 将ADC0809直接挂载到总线上，读写逻辑和教材P379同,分配地址Y2； 2. 8255PA口接8段的段码，PC6-5接8段的位码； 3. 去掉DAC0832； 4. GATE1直接接到VCC 5V； 5. OUT2接无源蜂鸣器,报警用蜂鸣器同P282一样，就是将R1改为反相器然后输入端接到OUT2。要使无源蜂鸣器发音只需给控制晶体管基极发送一个人耳范围内频率的波形比如1KHz即可。</p><h1 id="题目描述">题目描述</h1><p>已知8255的PA口作为8段显示器的段码接口，PC7接8253的GATE2,PC6-5接8段的位码，ADC0809的CLK时钟有8253OUT1产生，已知8253的CLK1和CLK2端接2MHz的时钟信号。系统工作过程为，循环以下过程：采集ADC0809的IN0的数字量送到8段显示器，如果采集到的数据所对应的模拟量低于1V，则由OUT2产生1KHz的方波,通过蜂鸣器报警。</p><h1 id="补充">补充</h1><p>EOC仍然在PC0,只是使用P379的读写逻辑,读写方式就和实验箱相同了。</p><h1 id="分析">分析</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Y0:</span><span class="number">0E00H</span>-<span class="number">0E03H</span> <span class="number">8253</span></span><br><span class="line"><span class="symbol">Y1:</span><span class="number">0E04H</span>-<span class="number">0E07H</span> <span class="number">8255</span></span><br><span class="line"><span class="symbol">Y2:</span><span class="number">0E08H</span>-<span class="number">0E0BH</span> AD0809</span><br><span class="line"><span class="symbol">Y3:</span><span class="number">0E0CH</span>-<span class="number">0E0FH</span></span><br><span class="line"><span class="symbol">Y4:</span><span class="number">0E10H</span>-<span class="number">0E13H</span></span><br><span class="line"><span class="symbol">Y5:</span><span class="number">0E14H</span>-<span class="number">0E17H</span></span><br><span class="line"><span class="symbol">Y6:</span><span class="number">0E18H</span>-<span class="number">0E1BH</span></span><br><span class="line"><span class="symbol">Y7:</span><span class="number">0E1CH</span>-<span class="number">0E1FH</span></span><br></pre></td></tr></table></figure><h1 id="源代码">源代码</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">base53 <span class="built_in">equ</span> <span class="number">0e00h</span></span><br><span class="line">t0     <span class="built_in">equ</span> base53</span><br><span class="line">t1     <span class="built_in">equ</span> base53 + <span class="number">1</span></span><br><span class="line">t2     <span class="built_in">equ</span> base53 + <span class="number">2</span></span><br><span class="line">ctl53  <span class="built_in">equ</span> base53 + <span class="number">3</span></span><br><span class="line">base55 <span class="built_in">equ</span> <span class="number">0e04h</span></span><br><span class="line">pa     <span class="built_in">equ</span> base55</span><br><span class="line">pb     <span class="built_in">equ</span> base55 + <span class="number">1</span></span><br><span class="line">pc     <span class="built_in">equ</span> base55 + <span class="number">2</span></span><br><span class="line">ctl55  <span class="built_in">equ</span> base55 + <span class="number">3</span></span><br><span class="line">baseAD <span class="built_in">equ</span> <span class="number">0E08H</span></span><br><span class="line">in0    <span class="built_in">equ</span> baseAD</span><br><span class="line">in1    <span class="built_in">equ</span> baseAD + <span class="number">1</span></span><br><span class="line">in2    <span class="built_in">equ</span> baseAD + <span class="number">2</span></span><br><span class="line">in3    <span class="built_in">equ</span> baseAD + <span class="number">3</span></span><br><span class="line">in4    <span class="built_in">equ</span> baseAD + <span class="number">4</span></span><br><span class="line">in5    <span class="built_in">equ</span> baseAD + <span class="number">5</span></span><br><span class="line">in6    <span class="built_in">equ</span> baseAD + <span class="number">6</span></span><br><span class="line">in7    <span class="built_in">equ</span> baseAD + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      tab <span class="built_in">db</span> <span class="number">3fh</span>,<span class="number">06h</span>,<span class="number">5bh</span>,<span class="number">4fh</span></span><br><span class="line">          <span class="built_in">db</span> <span class="number">66h</span>,<span class="number">6dh</span>,<span class="number">7dh</span>,<span class="number">07h</span></span><br><span class="line">          <span class="built_in">db</span> <span class="number">7fh</span>,<span class="number">6fh</span>,<span class="number">77h</span>,<span class="number">7ch</span></span><br><span class="line">          <span class="built_in">db</span> <span class="number">39h</span>,<span class="number">5eh</span>,<span class="number">79h</span>,<span class="number">71h</span></span><br><span class="line">      keys <span class="built_in">db</span> <span class="number">00h</span><span class="comment">;8段使用</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;数据段加载</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">call</span> init55</span><br><span class="line">      <span class="keyword">call</span> init53</span><br><span class="line">      </span><br><span class="line"><span class="symbol">L0:</span>   <span class="comment">;启动AD</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,in0</span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">L1:</span>   <span class="comment">;等待AD转换结束</span></span><br><span class="line">      <span class="keyword">call</span> led8</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pc</span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">test</span> <span class="built_in">al</span>,<span class="number">00000001b</span></span><br><span class="line">      <span class="keyword">jz</span> L1</span><br><span class="line">      </span><br><span class="line">      <span class="comment">;取AD转换结果</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,in0</span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;存数</span></span><br><span class="line">      <span class="keyword">mov</span> keys,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;和1V比较</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">51</span></span><br><span class="line">      <span class="comment">;&lt;1V</span></span><br><span class="line">      <span class="comment">;计算结果为51.2用jbe</span></span><br><span class="line">      <span class="keyword">jbe</span> L2</span><br><span class="line">      <span class="keyword">call</span> disableT2</span><br><span class="line">      <span class="comment">;开始下一轮</span></span><br><span class="line">      <span class="keyword">jmp</span> L0</span><br><span class="line"><span class="symbol">L2:</span></span><br><span class="line">      <span class="comment">;al&lt;1V打开蜂鸣器</span></span><br><span class="line">      <span class="keyword">call</span> enableT2</span><br><span class="line">      <span class="keyword">jmp</span> L0</span><br><span class="line">      </span><br><span class="line">init55 proc</span><br><span class="line">      <span class="keyword">pusha</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,ctl55</span><br><span class="line">      <span class="comment">;a口方式0输出,c上输出,c下输入</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000001b</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">popa</span></span><br><span class="line">      <span class="keyword">ret</span></span><br><span class="line">init55 endp</span><br><span class="line"></span><br><span class="line">init53 proc</span><br><span class="line">      <span class="keyword">pusha</span></span><br><span class="line">      <span class="comment">;T1写高低位,方式3方波</span></span><br><span class="line">      <span class="comment">;不想给自己找麻烦,请用万能写法</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,ctl53</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">01110110b</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,t1</span><br><span class="line">      <span class="comment">;初值2M/500K = 4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,ctl53</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10110110b</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,t2</span><br><span class="line">      <span class="comment">;初值2M/1K = 2000</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2000</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">ah</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">popa</span></span><br><span class="line">      <span class="keyword">ret</span></span><br><span class="line">init53 endp</span><br><span class="line"></span><br><span class="line">enableT2 proc</span><br><span class="line">      <span class="keyword">pusha</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pc</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">80h</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">popa</span></span><br><span class="line">      <span class="keyword">ret</span></span><br><span class="line">enableT2 endp</span><br><span class="line"></span><br><span class="line">disableT2 proc</span><br><span class="line">      <span class="keyword">pusha</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pc</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">00h</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">popa</span></span><br><span class="line">      <span class="keyword">ret</span></span><br><span class="line">disableT2 endp</span><br><span class="line"></span><br><span class="line">led8 proc</span><br><span class="line"></span><br><span class="line">      <span class="keyword">pusha</span></span><br><span class="line">      <span class="comment">;低位使能</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pc</span><br><span class="line">      <span class="comment">;低位在PC5,需要随时修改,需要保存PC7所以不能用这一行</span></span><br><span class="line">      <span class="comment">;mov al,00100000b</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">10011111b</span></span><br><span class="line">      <span class="keyword">or</span>  <span class="built_in">al</span>,<span class="number">00100000b</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="comment">;数据送入低位</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,keys</span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0fh</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,offset tab</span><br><span class="line">      <span class="keyword">xlat</span></span><br><span class="line">      <span class="comment">;or al,80h;如果需要小数点则可以加这一行代码</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pa<span class="comment">;段码在pa,需要随时修改</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="comment">;熄灯</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pc</span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">10011111b</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pa<span class="comment">;段码在pa,需要随时修改</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">;高位使能</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pc</span><br><span class="line">      <span class="comment">;高位在PC6,需要随时修改,需要保存PC7所以不能用这一行</span></span><br><span class="line">      <span class="comment">;mov al,01000000b</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">10011111b</span></span><br><span class="line">      <span class="keyword">or</span>  <span class="built_in">al</span>,<span class="number">01000000b</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="comment">;数据送入高位</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,keys</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">4</span></span><br><span class="line">      <span class="keyword">rol</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0fh</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,offset tab</span><br><span class="line">      <span class="keyword">xlat</span></span><br><span class="line">      <span class="comment">;or al,80h;如果需要小数点则可以加这一行代码</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pa<span class="comment">;段码在pa,需要随时修改</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="comment">;熄灯</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pc</span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">10011111b</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,pa<span class="comment">;段码在pa,需要随时修改</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">popa</span></span><br><span class="line">      <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">led8 endp</span><br><span class="line"></span><br><span class="line">ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 微机接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Win7的那些事儿</title>
      <link href="2015/11/15/p2.html"/>
      <url>2015/11/15/p2.html</url>
      
        <content type="html"><![CDATA[<p>由于win7系统只支持MBR格式的分区，如果强行将win7安装到UEFI分区方式的硬盘上将不能启动，所以，如果你要给别人的win8或者win10的OEM系统安装win7的话，记得先将重要数据备份出去，然后直接将硬盘所有分区删除，将硬盘分区方式改成MBR，新建分区，再安装win7，就可以正常启动了。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win7 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器优化问题</title>
      <link href="2015/10/24/p1.html"/>
      <url>2015/10/24/p1.html</url>
      
        <content type="html"><![CDATA[<p>今天同学在群里火急火燎的@我还以为有什么事要发生呢，结果发了一段代码出来，大概是这个意思： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> data[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一反应是这代码是哪个傻逼新生写得呢！结果，他说这个代码GCC编译通过了，当然我也试了一下，VS不用编译就有红色的下划线了，Dev C++用GCC编译确实是通过了，等等，我想静静，那么问题来了，静静是谁？难道是GCC编译器有bug？上C语言课老师可是反复强调C/C++没有变长数组啊(除非new一个)，可GCC编译器是经过这么多人测试全球都在使用的东西啊，这作何解释呢？</p><p>结论是编译器智能了。它懂你的意思。就不要那么古板了，它为什么可以这么做呢？这样不是违反了C标准吗？要从C标准说的话就有话说啦，C标准规定了不能有变长数组，但是C标准为了程序运行效率没有做越界处理，是否越界全靠程序员决定，而这一点正好给了编译器发挥的余地，每一个进程开始运行的时候操作系统总会分一个栈给它，编译器便是利用这个栈来实现这个“变长数组”的，至于个中细节，还需推敲。</p><p>几乎每一个编译器对这种C标准比较模糊的概念都有自己的解释。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
