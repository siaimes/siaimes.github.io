<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Aria: ArSignalHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Aria
   &#160;<span id="projectnumber">2.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classArSignalHandler.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ArSignalHandler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Signal handling class.  
 <a href="classArSignalHandler.html#details">More...</a></p>

<p><code>#include &lt;ArSignalHandler.h&gt;</code></p>

<p>Inherits <a class="el" href="classArASyncTask.html">ArASyncTask</a>.</p>

<p><a href="classArSignalHandler-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb60c7340a29b2853811bcc412b7685f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Signal</b> { <br/>
&#160;&#160;<b>SigHUP</b> = 1, 
<b>SigINT</b>, 
<b>SigQUIT</b>, 
<b>SigILL</b>, 
<br/>
&#160;&#160;<b>SigTRAP</b>, 
<b>SigABRT</b>, 
<b>SigBUS</b>, 
<b>SigFPE</b>, 
<br/>
&#160;&#160;<b>SigKILL</b>, 
<b>SigUSR1</b>, 
<b>SigSEGV</b>, 
<b>SigUSR2</b>, 
<br/>
&#160;&#160;<b>SigPIPE</b>, 
<b>SigALRM</b>, 
<b>SigTERM</b>, 
<b>SigSTKFLT</b>, 
<br/>
&#160;&#160;<b>SigCHLD</b>, 
<b>SigCONT</b>, 
<b>SigSTOP</b>, 
<b>SigTSTP</b>, 
<br/>
&#160;&#160;<b>SigTTIN</b>, 
<b>SigTTOU</b>, 
<b>SigURG</b>, 
<b>SigXCPU</b>, 
<br/>
&#160;&#160;<b>SigXFSZ</b>, 
<b>SigVTALRM</b>, 
<b>SigPROF</b>, 
<b>SigWINCH</b>, 
<br/>
&#160;&#160;<b>SigIO</b>, 
<b>SigPWR</b>
<br/>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a307e762ba1088d3a120d314b0156b15e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307e762ba1088d3a120d314b0156b15e"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><b>runThread</b> (void *arg)</td></tr>
<tr class="memitem:a50c08e255b08ab66b81693e07876e38f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c08e255b08ab66b81693e07876e38f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a50c08e255b08ab66b81693e07876e38f">~ArSignalHandler</a> ()</td></tr>
<tr class="memdesc:a50c08e255b08ab66b81693e07876e38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="inherit_header pub_methods_classArASyncTask"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classArASyncTask')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classArASyncTask.html">ArASyncTask</a></td></tr>
<tr class="memitem:a2f8d322b93edf16edd3253692e130480 inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f8d322b93edf16edd3253692e130480"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#a2f8d322b93edf16edd3253692e130480">ArASyncTask</a> ()</td></tr>
<tr class="memdesc:a2f8d322b93edf16edd3253692e130480 inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:a1219f8fc48adfc07ab59ea414585c479 inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1219f8fc48adfc07ab59ea414585c479"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#a1219f8fc48adfc07ab59ea414585c479">create</a> (bool joinable=true, bool lowerPriority=true)</td></tr>
<tr class="memdesc:a1219f8fc48adfc07ab59ea414585c479 inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the task and start it going. <br/></td></tr>
<tr class="memitem:acd6307214f0bfdcd9f1c89664b2a7ad1 inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#acd6307214f0bfdcd9f1c89664b2a7ad1">getThreadActivity</a> (void)</td></tr>
<tr class="memdesc:acd6307214f0bfdcd9f1c89664b2a7ad1 inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string that describes what the thread is doing, or NULL if it doesn't know.  <a href="#acd6307214f0bfdcd9f1c89664b2a7ad1"></a><br/></td></tr>
<tr class="memitem:a9da8602419f2c52f001f130fe489b387 inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#a9da8602419f2c52f001f130fe489b387">run</a> (void)</td></tr>
<tr class="memdesc:a9da8602419f2c52f001f130fe489b387 inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run without creating a new thread.  <a href="#a9da8602419f2c52f001f130fe489b387"></a><br/></td></tr>
<tr class="memitem:a3d9b25fe57d5d4c4a7146827798dcbe0 inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d9b25fe57d5d4c4a7146827798dcbe0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#a3d9b25fe57d5d4c4a7146827798dcbe0">runAsync</a> (void)</td></tr>
<tr class="memdesc:a3d9b25fe57d5d4c4a7146827798dcbe0 inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run in its own thread. <br/></td></tr>
<tr class="memitem:ab1b9692583669e973fcb70fe843e556f inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#ab1b9692583669e973fcb70fe843e556f">runInThisThread</a> (void *arg=0)</td></tr>
<tr class="memdesc:ab1b9692583669e973fcb70fe843e556f inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used with system threading system to run the new thread.  <a href="#ab1b9692583669e973fcb70fe843e556f"></a><br/></td></tr>
<tr class="memitem:adb6a00c292ff5aa6e8db8cd9d33747ac inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb6a00c292ff5aa6e8db8cd9d33747ac"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#adb6a00c292ff5aa6e8db8cd9d33747ac">stopRunning</a> (void)</td></tr>
<tr class="memdesc:adb6a00c292ff5aa6e8db8cd9d33747ac inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread. <br/></td></tr>
<tr class="memitem:a9a7a9aafc788b3a03fbaf71a87e1ee44 inherit pub_methods_classArASyncTask"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a7a9aafc788b3a03fbaf71a87e1ee44"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArASyncTask.html#a9a7a9aafc788b3a03fbaf71a87e1ee44">~ArASyncTask</a> ()</td></tr>
<tr class="memdesc:a9a7a9aafc788b3a03fbaf71a87e1ee44 inherit pub_methods_classArASyncTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="inherit_header pub_methods_classArThread"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classArThread')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classArThread.html">ArThread</a></td></tr>
<tr class="memitem:af6646fdb41042a80a0d54c778d1af3d9 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6646fdb41042a80a0d54c778d1af3d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#af6646fdb41042a80a0d54c778d1af3d9">ArThread</a> (bool blockAllSignals=true)</td></tr>
<tr class="memdesc:af6646fdb41042a80a0d54c778d1af3d9 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:aff21160d49a502bfc018d0e2126959aa inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff21160d49a502bfc018d0e2126959aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#aff21160d49a502bfc018d0e2126959aa">ArThread</a> (ThreadType thread, bool joinable, bool blockAllSignals=true)</td></tr>
<tr class="memdesc:aff21160d49a502bfc018d0e2126959aa inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - starts the thread. <br/></td></tr>
<tr class="memitem:a08068bcc611a53074d8999a5622f2289 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08068bcc611a53074d8999a5622f2289"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a08068bcc611a53074d8999a5622f2289">ArThread</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *func, bool joinable=true, bool blockAllSignals=true)</td></tr>
<tr class="memdesc:a08068bcc611a53074d8999a5622f2289 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - starts the thread. <br/></td></tr>
<tr class="memitem:a9f5c6ddc088c46736ce2e698a5ae3050 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f5c6ddc088c46736ce2e698a5ae3050"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a9f5c6ddc088c46736ce2e698a5ae3050">cancel</a> (void)</td></tr>
<tr class="memdesc:a9f5c6ddc088c46736ce2e698a5ae3050 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the thread. <br/></td></tr>
<tr class="memitem:a70f8c5e5a01c432f8e5722487b11b9aa inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70f8c5e5a01c432f8e5722487b11b9aa"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a70f8c5e5a01c432f8e5722487b11b9aa">detach</a> (void)</td></tr>
<tr class="memdesc:a70f8c5e5a01c432f8e5722487b11b9aa inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detatch the thread so it cant be joined. <br/></td></tr>
<tr class="memitem:aa8dc1c54a7c07dc2affdef031a74833e inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8dc1c54a7c07dc2affdef031a74833e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#aa8dc1c54a7c07dc2affdef031a74833e">getBlockAllSignals</a> (void)</td></tr>
<tr class="memdesc:aa8dc1c54a7c07dc2affdef031a74833e inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do we block all process signals at startup? <br/></td></tr>
<tr class="memitem:acb7ba63e4e43e85f47ff9429de88c599 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb7ba63e4e43e85f47ff9429de88c599"></a>
virtual <a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#acb7ba63e4e43e85f47ff9429de88c599">getFunc</a> (void) const </td></tr>
<tr class="memdesc:acb7ba63e4e43e85f47ff9429de88c599 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the functor that the thread runs. <br/></td></tr>
<tr class="memitem:a48d0856b755e8950d820d71fd097fb0d inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48d0856b755e8950d820d71fd097fb0d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a48d0856b755e8950d820d71fd097fb0d">getJoinable</a> (void) const </td></tr>
<tr class="memdesc:a48d0856b755e8950d820d71fd097fb0d inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the joinable status of the thread. <br/></td></tr>
<tr class="memitem:ad57f4235fd1f9092f55aaec52a57068f inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad57f4235fd1f9092f55aaec52a57068f"></a>
virtual ThreadType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#ad57f4235fd1f9092f55aaec52a57068f">getOSThread</a> (void) const </td></tr>
<tr class="memdesc:ad57f4235fd1f9092f55aaec52a57068f inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying os thread type. <br/></td></tr>
<tr class="memitem:a2f9451e6bcebcd4524d86d88732047b5 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f9451e6bcebcd4524d86d88732047b5"></a>
pid_t&#160;</td><td class="memItemRight" valign="bottom"><b>getPID</b> (void)</td></tr>
<tr class="memitem:a544461d5afc9a1f1d50398ef06f55743 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a544461d5afc9a1f1d50398ef06f55743"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a544461d5afc9a1f1d50398ef06f55743">getRunning</a> (void) const </td></tr>
<tr class="memdesc:a544461d5afc9a1f1d50398ef06f55743 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the running status of the thread. <br/></td></tr>
<tr class="memitem:a05333f5f05022f42ab46a6dd8a8f1958 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05333f5f05022f42ab46a6dd8a8f1958"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a05333f5f05022f42ab46a6dd8a8f1958">getRunningWithLock</a> (void)</td></tr>
<tr class="memdesc:a05333f5f05022f42ab46a6dd8a8f1958 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the running status of the thread, locking around the variable. <br/></td></tr>
<tr class="memitem:a1f17f4a7f59d8e14399e03ee405380be inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f17f4a7f59d8e14399e03ee405380be"></a>
virtual const ThreadType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a1f17f4a7f59d8e14399e03ee405380be">getThread</a> (void) const </td></tr>
<tr class="memdesc:a1f17f4a7f59d8e14399e03ee405380be inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying thread type. <br/></td></tr>
<tr class="memitem:af3c3543b2749dccd4e94e96fad418780 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3c3543b2749dccd4e94e96fad418780"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#af3c3543b2749dccd4e94e96fad418780">getThreadName</a> (void)</td></tr>
<tr class="memdesc:af3c3543b2749dccd4e94e96fad418780 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the thread. <br/></td></tr>
<tr class="memitem:a2220d1f5e5701a6666038cc4754b7c50 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2220d1f5e5701a6666038cc4754b7c50"></a>
pid_t&#160;</td><td class="memItemRight" valign="bottom"><b>getTID</b> (void)</td></tr>
<tr class="memitem:af5868982670b17f27aab0bbbf0749cb6 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#af5868982670b17f27aab0bbbf0749cb6">isThreadFinished</a> () const </td></tr>
<tr class="memdesc:af5868982670b17f27aab0bbbf0749cb6 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread has been completed and can be deleted.  <a href="#af5868982670b17f27aab0bbbf0749cb6"></a><br/></td></tr>
<tr class="memitem:a38dd0b805242f8144e14c0662eeee37c inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a38dd0b805242f8144e14c0662eeee37c">isThreadStarted</a> () const </td></tr>
<tr class="memdesc:a38dd0b805242f8144e14c0662eeee37c inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread has been started.  <a href="#a38dd0b805242f8144e14c0662eeee37c"></a><br/></td></tr>
<tr class="memitem:ab07c2ba39f6c537889db203d36291dd0 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07c2ba39f6c537889db203d36291dd0"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#ab07c2ba39f6c537889db203d36291dd0">join</a> (void **ret=NULL)</td></tr>
<tr class="memdesc:ab07c2ba39f6c537889db203d36291dd0 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join on the thread. <br/></td></tr>
<tr class="memitem:a0fa936e087d49e5151cb3cc1358ae1ce inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a0fa936e087d49e5151cb3cc1358ae1ce">lock</a> (void)</td></tr>
<tr class="memdesc:a0fa936e087d49e5151cb3cc1358ae1ce inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the thread instance.  <a href="#a0fa936e087d49e5151cb3cc1358ae1ce"></a><br/></td></tr>
<tr class="memitem:ac971ee8ad4b23a5d87e6f0db02062cde inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac971ee8ad4b23a5d87e6f0db02062cde"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#ac971ee8ad4b23a5d87e6f0db02062cde">logThreadInfo</a> (void)</td></tr>
<tr class="memdesc:ac971ee8ad4b23a5d87e6f0db02062cde inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the information about this thread. <br/></td></tr>
<tr class="memitem:a6eb9bbbff1f1494a4218be4551c28073 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb9bbbff1f1494a4218be4551c28073"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a6eb9bbbff1f1494a4218be4551c28073">setRunning</a> (bool running)</td></tr>
<tr class="memdesc:a6eb9bbbff1f1494a4218be4551c28073 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the running value on the thread. <br/></td></tr>
<tr class="memitem:af03075fb22fbfca1212d524f772f6c1c inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af03075fb22fbfca1212d524f772f6c1c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#af03075fb22fbfca1212d524f772f6c1c">setThreadName</a> (const char *name)</td></tr>
<tr class="memdesc:af03075fb22fbfca1212d524f772f6c1c inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the thread. <br/></td></tr>
<tr class="memitem:a718af06ca33f467f714a46f059e2455b inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a718af06ca33f467f714a46f059e2455b">threadFinished</a> (void)</td></tr>
<tr class="memdesc:a718af06ca33f467f714a46f059e2455b inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the thread as finished and logs useful debugging information.  <a href="#a718af06ca33f467f714a46f059e2455b"></a><br/></td></tr>
<tr class="memitem:a2cec8be019396610a5ba10b6ffcd819e inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a2cec8be019396610a5ba10b6ffcd819e">threadStarted</a> (void)</td></tr>
<tr class="memdesc:a2cec8be019396610a5ba10b6ffcd819e inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the thread as started and logs useful debugging information.  <a href="#a2cec8be019396610a5ba10b6ffcd819e"></a><br/></td></tr>
<tr class="memitem:aeefc89261e7760985b91566029fc9c6c inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#aeefc89261e7760985b91566029fc9c6c">tryLock</a> (void)</td></tr>
<tr class="memdesc:aeefc89261e7760985b91566029fc9c6c inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the thread instance without blocking.  <a href="#aeefc89261e7760985b91566029fc9c6c"></a><br/></td></tr>
<tr class="memitem:aa95ba7294af22e4be13215f39de61b38 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#aa95ba7294af22e4be13215f39de61b38">unlock</a> (void)</td></tr>
<tr class="memdesc:aa95ba7294af22e4be13215f39de61b38 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the thread instance.  <a href="#aa95ba7294af22e4be13215f39de61b38"></a><br/></td></tr>
<tr class="memitem:a02c1f44d7adb2b9524f0fc410158b554 inherit pub_methods_classArThread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02c1f44d7adb2b9524f0fc410158b554"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a02c1f44d7adb2b9524f0fc410158b554">~ArThread</a> ()</td></tr>
<tr class="memdesc:a02c1f44d7adb2b9524f0fc410158b554 inherit pub_methods_classArThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a48cf6dfa9c6f95864534b4d87849e033"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a48cf6dfa9c6f95864534b4d87849e033">addHandlerCB</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *func, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>
<tr class="memdesc:a48cf6dfa9c6f95864534b4d87849e033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler callback.  <a href="#a48cf6dfa9c6f95864534b4d87849e033"></a><br/></td></tr>
<tr class="memitem:ace80ef77760a9c47639a82ba891d2c9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#ace80ef77760a9c47639a82ba891d2c9b">block</a> (Signal sig)</td></tr>
<tr class="memdesc:ace80ef77760a9c47639a82ba891d2c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the given signal.  <a href="#ace80ef77760a9c47639a82ba891d2c9b"></a><br/></td></tr>
<tr class="memitem:a4df88f6d1c86dd2367be1a490cd59104"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4df88f6d1c86dd2367be1a490cd59104"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a4df88f6d1c86dd2367be1a490cd59104">blockAllThisThread</a> ()</td></tr>
<tr class="memdesc:a4df88f6d1c86dd2367be1a490cd59104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block all the signals for the calling thread only. <br/></td></tr>
<tr class="memitem:ac3905b131f4224e7cbaec67de0cd3d49"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#ac3905b131f4224e7cbaec67de0cd3d49">blockCommon</a> ()</td></tr>
<tr class="memdesc:ac3905b131f4224e7cbaec67de0cd3d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block all the common signals the kill a program.  <a href="#ac3905b131f4224e7cbaec67de0cd3d49"></a><br/></td></tr>
<tr class="memitem:aaacbb0de60881c236fbb01eafab26c0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#aaacbb0de60881c236fbb01eafab26c0f">blockCommonThisThread</a> ()</td></tr>
<tr class="memdesc:aaacbb0de60881c236fbb01eafab26c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block all the common signals for the calling thread only.  <a href="#aaacbb0de60881c236fbb01eafab26c0f"></a><br/></td></tr>
<tr class="memitem:a3ec75831b5c143668b4aefba87fd5f6e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a3ec75831b5c143668b4aefba87fd5f6e">createHandlerNonThreaded</a> ()</td></tr>
<tr class="memdesc:a3ec75831b5c143668b4aefba87fd5f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the signal handling for a non-threaded program.  <a href="#a3ec75831b5c143668b4aefba87fd5f6e"></a><br/></td></tr>
<tr class="memitem:a01509c79a6be50f527c0aa04efdfddf6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a01509c79a6be50f527c0aa04efdfddf6">createHandlerThreaded</a> ()</td></tr>
<tr class="memdesc:a01509c79a6be50f527c0aa04efdfddf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the signal handling for a multi-threaded program.  <a href="#a01509c79a6be50f527c0aa04efdfddf6"></a><br/></td></tr>
<tr class="memitem:aaefe2eba1ea2ea8d686813ad0edc86ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#aaefe2eba1ea2ea8d686813ad0edc86ac">delAllHandlerCBs</a> (void)</td></tr>
<tr class="memdesc:aaefe2eba1ea2ea8d686813ad0edc86ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the handlers.  <a href="#aaefe2eba1ea2ea8d686813ad0edc86ac"></a><br/></td></tr>
<tr class="memitem:a56c5f923669397fad6eb6a513f978b6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a56c5f923669397fad6eb6a513f978b6f">delHandlerCB</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *func)</td></tr>
<tr class="memdesc:a56c5f923669397fad6eb6a513f978b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler callback.  <a href="#a56c5f923669397fad6eb6a513f978b6f"></a><br/></td></tr>
<tr class="memitem:aa8a7697764708f84daa86c53f0fdc682"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classArSignalHandler.html">ArSignalHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#aa8a7697764708f84daa86c53f0fdc682">getHandler</a> ()</td></tr>
<tr class="memdesc:aa8a7697764708f84daa86c53f0fdc682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the single <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a> instance.  <a href="#aa8a7697764708f84daa86c53f0fdc682"></a><br/></td></tr>
<tr class="memitem:aa2645175511274d6816b24c2b190f827"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#aa2645175511274d6816b24c2b190f827">handle</a> (Signal sig)</td></tr>
<tr class="memdesc:aa2645175511274d6816b24c2b190f827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the given signal.  <a href="#aa2645175511274d6816b24c2b190f827"></a><br/></td></tr>
<tr class="memitem:a39fa57bedbb7ccf657c8c5106903ee25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39fa57bedbb7ccf657c8c5106903ee25"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>logThread</b> (void)</td></tr>
<tr class="memitem:a5be3b4e338a9a54df36a81f1619d02fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5be3b4e338a9a54df36a81f1619d02fa"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a5be3b4e338a9a54df36a81f1619d02fa">nameSignal</a> (int sig)</td></tr>
<tr class="memdesc:a5be3b4e338a9a54df36a81f1619d02fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the given signal. <br/></td></tr>
<tr class="memitem:a78ba0630454de3eb86707eb7b6c02cf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78ba0630454de3eb86707eb7b6c02cf8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>signalCB</b> (int sig)</td></tr>
<tr class="memitem:aedd9a39d9b5aabcc93544706253f8d1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#aedd9a39d9b5aabcc93544706253f8d1c">unblock</a> (Signal sig)</td></tr>
<tr class="memdesc:aedd9a39d9b5aabcc93544706253f8d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock the given signal.  <a href="#aedd9a39d9b5aabcc93544706253f8d1c"></a><br/></td></tr>
<tr class="memitem:a0d8582a19d463dc7618188701061a14b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a0d8582a19d463dc7618188701061a14b">unblockAll</a> ()</td></tr>
<tr class="memdesc:a0d8582a19d463dc7618188701061a14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock all the signals.  <a href="#a0d8582a19d463dc7618188701061a14b"></a><br/></td></tr>
<tr class="memitem:a6ac04eee0943686bd97006a57f185192"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a6ac04eee0943686bd97006a57f185192">unhandle</a> (Signal sig)</td></tr>
<tr class="memdesc:a6ac04eee0943686bd97006a57f185192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dont handle the given signal.  <a href="#a6ac04eee0943686bd97006a57f185192"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a0868e84f292fdaba87bc9abc599f6020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0868e84f292fdaba87bc9abc599f6020"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>initSigMap</b> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7824916846be32ead951de403ac9d740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7824916846be32ead951de403ac9d740"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ourIgnoreQUIT</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:afc9c752f74b7273b24036042b6df0cc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc9c752f74b7273b24036042b6df0cc8"></a>
static sigset_t&#160;</td><td class="memItemRight" valign="bottom"><b>ourBlockSigSet</b></td></tr>
<tr class="memitem:ab8b9dcfe55daa25b289bec031def90fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b9dcfe55daa25b289bec031def90fc"></a>
static std::list&lt; <a class="el" href="classArFunctor1.html">ArFunctor1</a><br class="typebreak"/>
&lt; int &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ourHandlerList</b></td></tr>
<tr class="memitem:a3d63a9af96e5f26b0a92af8a724985e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d63a9af96e5f26b0a92af8a724985e1"></a>
static sigset_t&#160;</td><td class="memItemRight" valign="bottom"><b>ourHandleSigSet</b></td></tr>
<tr class="memitem:a80ce9dae77f52333e4bb579820b6e8bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ce9dae77f52333e4bb579820b6e8bf"></a>
static ArStrMap&#160;</td><td class="memItemRight" valign="bottom"><b>ourSigMap</b></td></tr>
<tr class="memitem:ab6586d0779e91ed5915e3d3a16f065ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6586d0779e91ed5915e3d3a16f065ab"></a>
static <a class="el" href="classArSignalHandler.html">ArSignalHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ourSignalHandler</b> = 0</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Signal handling class. </p>
<p>This is a signal handling class. It has both a threaded and non-threaded mode of operation. The non-threaded mode will work in a threaded application but it is best to use the threaded mode. The benefit of the threaded mode is that if the signal incures some processing, but does not shutdown the program (ie. SIGUSR1 or SIGUSR2), the threaded mode will handle the signal in its own thread and hopefully that will not hurt the performance of the tight loop robot control. Exaclty how much performance you get out of this depends on your machines physical hardware and exactly what the processing the signal handler does. For instance, a multi-processor machine has a much greater chance of the signal handler not interfering with the robot control loop.</p>
<p>See the <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> main class for how to initialize a default setup of the signal handling.</p>
<p>There are functions to block, unblock, handle and unhandle signals. These functions all must be called before creating the signalhandler. In either single or multi-threaded mode. The functions to block and handle signals creates a set of blocking and handling which is then used by the create functions to tell the Linux kernel what to do.</p>
<p>In the threaded mode, there is a signal handler thread that is created. That thread is created in a detached state, which means it can not be joined on. When the program exits, the signal handler thread will be ignored and that thread will never exit its run loop. This is perfectly fine behavior. There is no state that can be messed up in this fashion. It is just easier to exit the program than to try to wake up that thread and get it to exit itself.</p>
<p>This class is for Linux only. Windows has virtualy no support for signals and the little support that it does have is not realy usefull. There is an empty implementation of this class for Windows so that code can compile in both Linux and Windows. Just do not expect the code that uses this signal handling to do anything in Windows. This should not be a problem since signals are not used in Windows. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a48cf6dfa9c6f95864534b4d87849e033"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::addHandlerCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a handler callback. </p>
<p>Add a handler callback to the list of callbacks.</p>
<p>When there is a signal sent to the process, the list of callbacks are invoked and passed the signal number. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor created from ArFunctorC1&lt;int&gt; which refers to the function to call. </td></tr>
    <tr><td class="paramname">position</td><td>whether to place the functor first or last </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace80ef77760a9c47639a82ba891d2c9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::block </td>
          <td>(</td>
          <td class="paramtype">Signal&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the given signal. </p>
<p>Call this before calling createHandlerNonThreaded or createHandlerThreaded. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the number of the signal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3905b131f4224e7cbaec67de0cd3d49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::blockCommon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block all the common signals the kill a program. </p>
<p>Sets the signal handler to block all the common signals.</p>
<p>The 'common' signals are SIGHUP, SIGINT, SIGQUIT, SIGTERM, SIGSEGV, and SIGPIPE. Call this before calling createHandlerNonThreaded or createHandlerThreaded. </p>

</div>
</div>
<a class="anchor" id="aaacbb0de60881c236fbb01eafab26c0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::blockCommonThisThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block all the common signals for the calling thread only. </p>
<p>Block all the common signals for the calling thread.</p>
<p>The calling thread will never receive the common signals which are SIGHUP, SIGINT, SIGQUIT, and SIGTERM. This function can be called at any time. </p>

</div>
</div>
<a class="anchor" id="a3ec75831b5c143668b4aefba87fd5f6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::createHandlerNonThreaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the signal handling for a non-threaded program. </p>
<p>Sets up the signal handling for a non-threaded program.</p>
<p>When the program This uses the system call signal(2). This should not be used if you have a threaded program. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classArSignalHandler.html#a01509c79a6be50f527c0aa04efdfddf6" title="Setup the signal handling for a multi-threaded program.">createHandlerThreaded</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a01509c79a6be50f527c0aa04efdfddf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::createHandlerThreaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the signal handling for a multi-threaded program. </p>
<p>Sets up the signal handling for a threaded program.</p>
<p>This call is only useful for Linux. This will create a dedicated thread in which to handle signals. The thread calls sigwait(3) and waits for a signal to be sent. By default all <a class="el" href="classArThread.html" title="POSIX/WIN32 thread wrapper class.">ArThread</a> instances block all signals. Thus the signal is sent to the signal handler thread. This will allow the other threads to continue uninterrupted and not skew their timing loops. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classArSignalHandler.html#a3ec75831b5c143668b4aefba87fd5f6e" title="Setup the signal handling for a non-threaded program.">createHandlerNonThreaded</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaefe2eba1ea2ea8d686813ad0edc86ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::delAllHandlerCBs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the handlers. </p>
<p>Removes all of the signal handler callback from the list of callbacks. </p>

</div>
</div>
<a class="anchor" id="a56c5f923669397fad6eb6a513f978b6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::delHandlerCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a handler callback. </p>
<p>Remove a handler callback from the list of callbacks.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor created from ArFunctorC1&lt;int&gt; which refers to the function to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8a7697764708f84daa86c53f0fdc682"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArSignalHandler.html">ArSignalHandler</a> * ArSignalHandler::getHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the single <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a> instance. </p>
<p>Get a pointer to the single instance of the <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a>.</p>
<p>The signal handler uses the singleton model, which means there can only be one instance of <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a>. If the single instance of <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a> has not been created, getHandler will create it. This is how the handler should be created. </p>
<dl class="section return"><dt>Returns:</dt><dd>returns a pointer to the instance of the signal handler </dd></dl>

</div>
</div>
<a class="anchor" id="aa2645175511274d6816b24c2b190f827"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::handle </td>
          <td>(</td>
          <td class="paramtype">Signal&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the given signal. </p>
<p>All the handler callbacks will be called with this signal when it is received. Call this before calling createHandlerNonThreaded or createHandlerThreaded. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the number of the signal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedd9a39d9b5aabcc93544706253f8d1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::unblock </td>
          <td>(</td>
          <td class="paramtype">Signal&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unblock the given signal. </p>
<p>Call this before calling createHandlerNonThreaded or createHandlerThreaded. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the number of the signal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d8582a19d463dc7618188701061a14b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::unblockAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unblock all the signals. </p>
<p>Call this before calling createHandlerNonThreaded or createHandlerThreaded. </p>

</div>
</div>
<a class="anchor" id="a6ac04eee0943686bd97006a57f185192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::unhandle </td>
          <td>(</td>
          <td class="paramtype">Signal&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dont handle the given signal. </p>
<p>Do not handle the given signal.</p>
<p>Call this before calling createHandlerNonThreaded or createHandlerThreaded. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the number of the signal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ArSignalHandler.h</li>
<li>ArSignalHandler_LIN.cpp</li>
<li>ArSignalHandler_WIN.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classArSignalHandler.html">ArSignalHandler</a></li>
    <li class="footer">Generated on Wed Nov 15 2017 12:04:27 for Aria by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1 </li>
  </ul>
</div>
</body>
</html>
