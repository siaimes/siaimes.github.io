<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Aria: ArMapInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Aria
   &#160;<span id="projectnumber">2.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classArMapInterface.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ArMapInterface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> defines the methods that are available on all <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> maps.  
 <a href="classArMapInterface.html#details">More...</a></p>

<p><code>#include &lt;ArMapInterface.h&gt;</code></p>

<p>Inherits <a class="el" href="classArHasFileName.html">ArHasFileName</a>, <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a>, <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a>, <a class="el" href="classArMapScanInterface.html">ArMapScanInterface</a>, and <a class="el" href="classArMapSupplementInterface.html">ArMapSupplementInterface</a>.</p>

<p>Inherited by <a class="el" href="classArMap.html">ArMap</a>, and <a class="el" href="classArMapSimple.html">ArMapSimple</a>.</p>

<p><a href="classArMapInterface-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a456c9419ae512d319935e4f9ba482de5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classArMapInterface.html#a456c9419ae512d319935e4f9ba482de5a40732d41ab529094aace100632e2c16b">MAX_MAP_NAME_LENGTH</a> =  512
 }</td></tr>
<tr class="inherit_header pub_types_classArMapInfoInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classArMapInfoInterface')"><img src="closed.png" alt="-"/>&nbsp;Public Types inherited from <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a></td></tr>
<tr class="memitem:a9acc582d92ba2e4748a21c74bd298ac9 inherit pub_types_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classArMapInfoInterface.html#a9acc582d92ba2e4748a21c74bd298ac9a20ee240af44438cad2f33cfe29f21b23">INFO_COUNT</a> =  LAST_INFO + 1
 }</td></tr>
<tr class="memitem:ae8f1a9d7cce478985fc30c9237d93e05 inherit pub_types_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05">InfoType</a> { <br/>
&#160;&#160;<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a34eb25df5af2b80fc9da559b7074b2a7">MAP_INFO</a>, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a43cc914ec328dc61f7ad3ac3c7241c4c">FIRST_INFO</a> =  MAP_INFO, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a71dc6cbd05a61ca0f3c6d6bfd57b2cf2">MACRO_INFO</a>, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05af2f297edecf3ad24764990d325d35f29">META_INFO</a>, 
<br/>
&#160;&#160;<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05af8292aef78325420d45fb11f7a0bbf67">TASK_INFO</a>, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a7ae389082ea4c263a4df2f3aa3186a8f">ROUTE_INFO</a>, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a3b4136d47451943fde3375cdb811c98b">SCHED_TASK_INFO</a>, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a6322eef461adaf54bd22c6eda06523b9">SCHED_INFO</a>, 
<br/>
&#160;&#160;<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05afab7a58fe818b209b1932ee8d758db27">CAIRN_INFO</a>, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a6fda900fe4e3a84219b49c8670377b22">CUSTOM_INFO</a>, 
<a class="el" href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05a96063b169201f877050e201d280f6404">LAST_INFO</a> =  CUSTOM_INFO
<br/>
 }</td></tr>
<tr class="memdesc:ae8f1a9d7cce478985fc30c9237d93e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of the standard Info categories defined for <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> maps.  <a href="classArMapInfoInterface.html#ae8f1a9d7cce478985fc30c9237d93e05">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4473ac4e92936dab506739e7a20b9810"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a4473ac4e92936dab506739e7a20b9810">addMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>
<tr class="memdesc:a4473ac4e92936dab506739e7a20b9810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback that is invoked when the map has been changed.  <a href="#a4473ac4e92936dab506739e7a20b9810"></a><br/></td></tr>
<tr class="memitem:a8f72e43ccdc17ca9ace947b0cd6a3647"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a8f72e43ccdc17ca9ace947b0cd6a3647">addMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, int position=50)=0</td></tr>
<tr class="memdesc:a8f72e43ccdc17ca9ace947b0cd6a3647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback that is invoked when the map has been changed.  <a href="#a8f72e43ccdc17ca9ace947b0cd6a3647"></a><br/></td></tr>
<tr class="memitem:a7a7e9be6f6d788181f5293637cf6ee57"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7a7e9be6f6d788181f5293637cf6ee57">addMapChangedLocalizationCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>
<tr class="memdesc:a7a7e9be6f6d788181f5293637cf6ee57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback for localization that is invoked when the map has been changed.  <a href="#a7a7e9be6f6d788181f5293637cf6ee57"></a><br/></td></tr>
<tr class="memitem:aea58cfcaa05e4669b26b0392108cf789"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#aea58cfcaa05e4669b26b0392108cf789">addMapChangedLocalizationCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, int position=50)=0</td></tr>
<tr class="memdesc:aea58cfcaa05e4669b26b0392108cf789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback for localization that is invoked when the map has been changed.  <a href="#aea58cfcaa05e4669b26b0392108cf789"></a><br/></td></tr>
<tr class="memitem:a7fb84a87631988abd346361c01aff86e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7fb84a87631988abd346361c01aff86e">addMapChangedPathPlanningCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>
<tr class="memdesc:a7fb84a87631988abd346361c01aff86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback for pathplanning that is invoked when the map has been changed.  <a href="#a7fb84a87631988abd346361c01aff86e"></a><br/></td></tr>
<tr class="memitem:a26c4f9660334ebcd3133de605c46c2ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a26c4f9660334ebcd3133de605c46c2ae">addMapChangedPathPlanningCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, int position=50)=0</td></tr>
<tr class="memdesc:a26c4f9660334ebcd3133de605c46c2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback for path planning that is invoked when the map has been changed.  <a href="#a26c4f9660334ebcd3133de605c46c2ae"></a><br/></td></tr>
<tr class="memitem:a40d8eea550274935ff957b93f340dc60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a40d8eea550274935ff957b93f340dc60">addPostWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=<a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a>)=0</td></tr>
<tr class="memdesc:a40d8eea550274935ff957b93f340dc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to be invoked after the map file is written.  <a href="#a40d8eea550274935ff957b93f340dc60"></a><br/></td></tr>
<tr class="memitem:a68292e93e05b174ee8f35ee5cd11403b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a68292e93e05b174ee8f35ee5cd11403b">addPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>
<tr class="memdesc:a68292e93e05b174ee8f35ee5cd11403b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback called before the map changed callbacks are called.  <a href="#a68292e93e05b174ee8f35ee5cd11403b"></a><br/></td></tr>
<tr class="memitem:a7be484cdd56bc5610073ea7a70824c75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7be484cdd56bc5610073ea7a70824c75">addPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, int position=50)=0</td></tr>
<tr class="memdesc:a7be484cdd56bc5610073ea7a70824c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback called before the map changed callbacks are called.  <a href="#a7be484cdd56bc5610073ea7a70824c75"></a><br/></td></tr>
<tr class="memitem:abb19d9b10f3d7927c5d2be759e4b99a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#abb19d9b10f3d7927c5d2be759e4b99a3">addPreParseFileCB</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; std::string &gt; *functor)=0</td></tr>
<tr class="memdesc:abb19d9b10f3d7927c5d2be759e4b99a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified "pre-map-parse callback" with the map format as string.  <a href="#abb19d9b10f3d7927c5d2be759e4b99a3"></a><br/></td></tr>
<tr class="memitem:a7b1e1bc876eba9f442f170449b79f69e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7b1e1bc876eba9f442f170449b79f69e">addPreWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=<a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a>)=0</td></tr>
<tr class="memdesc:a7b1e1bc876eba9f442f170449b79f69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to be invoked before the map file is written.  <a href="#a7b1e1bc876eba9f442f170449b79f69e"></a><br/></td></tr>
<tr class="memitem:afe8e08b6c419a144dc5622b785c584df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe8e08b6c419a144dc5622b785c584df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#afe8e08b6c419a144dc5622b785c584df">ArMapInterface</a> ()</td></tr>
<tr class="memdesc:afe8e08b6c419a144dc5622b785c584df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:a11d230f4851af9cd23683ec1b425f7e8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a11d230f4851af9cd23683ec1b425f7e8">calculateChecksum</a> (unsigned char *md5DigestBuffer, size_t md5DigestBufferLen)=0</td></tr>
<tr class="memdesc:a11d230f4851af9cd23683ec1b425f7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the checksum of the map.  <a href="#a11d230f4851af9cd23683ec1b425f7e8"></a><br/></td></tr>
<tr class="memitem:a3545fd896f5bfa3b23c3585483d7aa8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3545fd896f5bfa3b23c3585483d7aa8e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a3545fd896f5bfa3b23c3585483d7aa8e">clear</a> ()=0</td></tr>
<tr class="memdesc:a3545fd896f5bfa3b23c3585483d7aa8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map, removing all info, objects and data points and lines. <br/></td></tr>
<tr class="memitem:abc68f5bb2b270a3621206c0bb60de750"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapInterface.html">ArMapInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#abc68f5bb2b270a3621206c0bb60de750">clone</a> ()=0</td></tr>
<tr class="memdesc:abc68f5bb2b270a3621206c0bb60de750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new map that is "equivalent" to this map.  <a href="#abc68f5bb2b270a3621206c0bb60de750"></a><br/></td></tr>
<tr class="memitem:a1c7ea2928593dabdb79eaf328f803123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c7ea2928593dabdb79eaf328f803123"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a1c7ea2928593dabdb79eaf328f803123">createRealFileName</a> (const char *fileName)=0</td></tr>
<tr class="memdesc:a1c7ea2928593dabdb79eaf328f803123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the appropriate directory information on the given filename. <br/></td></tr>
<tr class="memitem:a69999157a3713d4ada7d47f6a3087b73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a69999157a3713d4ada7d47f6a3087b73">findMapObjectParams</a> (const char *mapObjectName)=0</td></tr>
<tr class="memdesc:a69999157a3713d4ada7d47f6a3087b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optional parameters associated with a map object, or NULL if none.  <a href="#a69999157a3713d4ada7d47f6a3087b73"></a><br/></td></tr>
<tr class="memitem:a6a75aadc1642ea9f8f6004c09fa94306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a75aadc1642ea9f8f6004c09fa94306"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a6a75aadc1642ea9f8f6004c09fa94306">getBaseDirectory</a> (void) const =0</td></tr>
<tr class="memdesc:a6a75aadc1642ea9f8f6004c09fa94306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base directory. <br/></td></tr>
<tr class="memitem:a209d91e860f6c22478b6b91a190a59a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a209d91e860f6c22478b6b91a190a59a0"></a>
virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a209d91e860f6c22478b6b91a190a59a0">getChildObjects</a> ()=0</td></tr>
<tr class="memdesc:a209d91e860f6c22478b6b91a190a59a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct access to the child map objects which are used to define group templates. <br/></td></tr>
<tr class="memitem:a4e4b9de7ebaa896d12728e2b16d5eb0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e4b9de7ebaa896d12728e2b16d5eb0f"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a4e4b9de7ebaa896d12728e2b16d5eb0f">getFileName</a> (void) const =0</td></tr>
<tr class="memdesc:a4e4b9de7ebaa896d12728e2b16d5eb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fileName that was loaded. <br/></td></tr>
<tr class="memitem:abd35c2a4363d41c6633fd064a45188bd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#abd35c2a4363d41c6633fd064a45188bd">getIgnoreCase</a> (void)=0</td></tr>
<tr class="memdesc:abd35c2a4363d41c6633fd064a45188bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether we ignore case or not.  <a href="#abd35c2a4363d41c6633fd064a45188bd"></a><br/></td></tr>
<tr class="memitem:ae71fec67708492f07fe4cf88fe5bd570"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ae71fec67708492f07fe4cf88fe5bd570">getIgnoreEmptyFileName</a> (void)=0</td></tr>
<tr class="memdesc:ae71fec67708492f07fe4cf88fe5bd570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether we ignore empty file names or fail if we encounter one.  <a href="#ae71fec67708492f07fe4cf88fe5bd570"></a><br/></td></tr>
<tr class="memitem:af71351c58a7c772b852002babf282220"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#af71351c58a7c772b852002babf282220">getInactiveInfo</a> ()=0</td></tr>
<tr class="memdesc:af71351c58a7c772b852002babf282220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct access to the inactive map info.  <a href="#af71351c58a7c772b852002babf282220"></a><br/></td></tr>
<tr class="memitem:a06520aefeb5654a4b4adae7f4b5c0e5a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a06520aefeb5654a4b4adae7f4b5c0e5a">getInactiveObjects</a> ()=0</td></tr>
<tr class="memdesc:a06520aefeb5654a4b4adae7f4b5c0e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct access to the inactive map objects.  <a href="#a06520aefeb5654a4b4adae7f4b5c0e5a"></a><br/></td></tr>
<tr class="memitem:af2273d028d0be565267a68e6ac8b2837"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2273d028d0be565267a68e6ac8b2837"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getMapCategory</b> ()=0</td></tr>
<tr class="memitem:a55d2dc775f7dfb095f4a97c1c8493f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d2dc775f7dfb095f4a97c1c8493f82"></a>
virtual <a class="el" href="classArLog.html#ac8cc0fb3aa323ab2a1c21340fdd1dce3">ArLog::LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a55d2dc775f7dfb095f4a97c1c8493f82">getMapChangedLogLevel</a> (void)=0</td></tr>
<tr class="memdesc:a55d2dc775f7dfb095f4a97c1c8493f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level at which information about the map changed callbacks is logged. <br/></td></tr>
<tr class="memitem:a42438b0cdb01d4f1613b05dcaa8bae60"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a42438b0cdb01d4f1613b05dcaa8bae60">getMapId</a> (<a class="el" href="classArMapId.html">ArMapId</a> *mapIdOut, bool isInternalCall=false)=0</td></tr>
<tr class="memdesc:a42438b0cdb01d4f1613b05dcaa8bae60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the map ID.  <a href="#a42438b0cdb01d4f1613b05dcaa8bae60"></a><br/></td></tr>
<tr class="memitem:ab9736c0a90ec57e51b3415ef787de861"><td class="memItemLeft" align="right" valign="top">virtual struct stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ab9736c0a90ec57e51b3415ef787de861">getReadFileStat</a> () const =0</td></tr>
<tr class="memdesc:ab9736c0a90ec57e51b3415ef787de861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the map file that was read.  <a href="#ab9736c0a90ec57e51b3415ef787de861"></a><br/></td></tr>
<tr class="memitem:a33d5f7c640ead8c14268379b35d5cbe0"><td class="memItemLeft" align="right" valign="top">virtual std::list<br class="typebreak"/>
&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a33d5f7c640ead8c14268379b35d5cbe0">getRemainder</a> ()=0</td></tr>
<tr class="memdesc:a33d5f7c640ead8c14268379b35d5cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the map file lines that were not recognized.  <a href="#a33d5f7c640ead8c14268379b35d5cbe0"></a><br/></td></tr>
<tr class="memitem:af1c75dac69881ba57ffd7826dd600a32"><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#af1c75dac69881ba57ffd7826dd600a32">getScanTypes</a> () const =0</td></tr>
<tr class="memdesc:af1c75dac69881ba57ffd7826dd600a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the scan types that are defined for this map.  <a href="#af1c75dac69881ba57ffd7826dd600a32"></a><br/></td></tr>
<tr class="memitem:a15ff7bcde5b7655300e8e35f59eaab7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15ff7bcde5b7655300e8e35f59eaab7a"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a15ff7bcde5b7655300e8e35f59eaab7a">getTempDirectory</a> (void) const =0</td></tr>
<tr class="memdesc:a15ff7bcde5b7655300e8e35f59eaab7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the temp directory. <br/></td></tr>
<tr class="memitem:a660969c77405c2795a47ce58f0625977"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a660969c77405c2795a47ce58f0625977">isLoadingDataStarted</a> ()=0</td></tr>
<tr class="memdesc:a660969c77405c2795a47ce58f0625977"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value returns true once the first DATA tag has been reached.  <a href="#a660969c77405c2795a47ce58f0625977"></a><br/></td></tr>
<tr class="memitem:a6d2628ce711c2d6774746586932f7913"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a6d2628ce711c2d6774746586932f7913">isLoadingLinesAndDataStarted</a> ()=0</td></tr>
<tr class="memdesc:a6d2628ce711c2d6774746586932f7913"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value returns true once the first LINES tag has been reached.  <a href="#a6d2628ce711c2d6774746586932f7913"></a><br/></td></tr>
<tr class="memitem:a2e72e85ff0680d98570b096cf24938ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e72e85ff0680d98570b096cf24938ba"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba">lock</a> ()=0</td></tr>
<tr class="memdesc:a2e72e85ff0680d98570b096cf24938ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the map instance. <br/></td></tr>
<tr class="memitem:a00f12f15367b9c97592b0f45fda2fc2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f">mapChanged</a> (void)=0</td></tr>
<tr class="memdesc:a00f12f15367b9c97592b0f45fda2fc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that will call the map changed CBs if needed.  <a href="#a00f12f15367b9c97592b0f45fda2fc2f"></a><br/></td></tr>
<tr class="memitem:ac277640473ac86d1389e6445f40f18ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac277640473ac86d1389e6445f40f18ee"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>mapChanged</b> (bool invokePathPlanningCB, bool invokeLocalizationCB)=0</td></tr>
<tr class="memitem:a7a5270bda8f803df83079940ac6e15e5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7a5270bda8f803df83079940ac6e15e5">parseLine</a> (char *line)=0</td></tr>
<tr class="memdesc:a7a5270bda8f803df83079940ac6e15e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public for ArQMapProducer.  <a href="#a7a5270bda8f803df83079940ac6e15e5"></a><br/></td></tr>
<tr class="memitem:a7aa64d691b47caab38efa72a90767294"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa64d691b47caab38efa72a90767294"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7aa64d691b47caab38efa72a90767294">parsingComplete</a> (void)=0</td></tr>
<tr class="memdesc:a7aa64d691b47caab38efa72a90767294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Says that the parsing by lines is done and to use the parsed data. <br/></td></tr>
<tr class="memitem:a9ec33c9ef77c8d6fcd6f68b33d0385d9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a9ec33c9ef77c8d6fcd6f68b33d0385d9">readFile</a> (const char *fileName, char *errorBuffer=NULL, size_t errorBufferLen=0, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0)=0</td></tr>
<tr class="memdesc:a9ec33c9ef77c8d6fcd6f68b33d0385d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the map from the specified file.  <a href="#a9ec33c9ef77c8d6fcd6f68b33d0385d9"></a><br/></td></tr>
<tr class="memitem:a412f9906797ed2e34e6d4589033e3d80"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a412f9906797ed2e34e6d4589033e3d80">refresh</a> ()=0</td></tr>
<tr class="memdesc:a412f9906797ed2e34e6d4589033e3d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the map file needs to be re-read.  <a href="#a412f9906797ed2e34e6d4589033e3d80"></a><br/></td></tr>
<tr class="memitem:a65da492e1379f9a9d226b552a2be65d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a65da492e1379f9a9d226b552a2be65d3">remMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr class="memdesc:a65da492e1379f9a9d226b552a2be65d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a callback called when the map has been changed.  <a href="#a65da492e1379f9a9d226b552a2be65d3"></a><br/></td></tr>
<tr class="memitem:ab3db05cc87cb3bb4dcd090bc1c4a03d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ab3db05cc87cb3bb4dcd090bc1c4a03d1">remMapChangedLocalizationCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr class="memdesc:ab3db05cc87cb3bb4dcd090bc1c4a03d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a callback for localizationcalled when the map has been changed.  <a href="#ab3db05cc87cb3bb4dcd090bc1c4a03d1"></a><br/></td></tr>
<tr class="memitem:a9922debd656da46d9a2bad95a58f954e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a9922debd656da46d9a2bad95a58f954e">remMapChangedPathPlanningCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr class="memdesc:a9922debd656da46d9a2bad95a58f954e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a callback for path planning called when the map has been changed.  <a href="#a9922debd656da46d9a2bad95a58f954e"></a><br/></td></tr>
<tr class="memitem:a80f3ea46ca3969d4eaf6253b39c84f5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a80f3ea46ca3969d4eaf6253b39c84f5c">remPostWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr class="memdesc:a80f3ea46ca3969d4eaf6253b39c84f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given callback from the list of post-write callbacks.  <a href="#a80f3ea46ca3969d4eaf6253b39c84f5c"></a><br/></td></tr>
<tr class="memitem:a0563d1953c0795a0ee85ebb2a7c9b13c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a0563d1953c0795a0ee85ebb2a7c9b13c">remPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr class="memdesc:a0563d1953c0795a0ee85ebb2a7c9b13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified "pre-map-changed callback".  <a href="#a0563d1953c0795a0ee85ebb2a7c9b13c"></a><br/></td></tr>
<tr class="memitem:a2551259120e6668c9f8cbed15516506f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a2551259120e6668c9f8cbed15516506f">remPreParseFileCB</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; std::string &gt; *functor)=0</td></tr>
<tr class="memdesc:a2551259120e6668c9f8cbed15516506f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified "pre-map-parse callback" with the map format as string.  <a href="#a2551259120e6668c9f8cbed15516506f"></a><br/></td></tr>
<tr class="memitem:a44fbadba38009509c473ca622a59b8b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a44fbadba38009509c473ca622a59b8b1">remPreWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr class="memdesc:a44fbadba38009509c473ca622a59b8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given callback from the list of pre-write callbacks.  <a href="#a44fbadba38009509c473ca622a59b8b1"></a><br/></td></tr>
<tr class="memitem:a20061ab5be4b9b469a7221ca12fdd9be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a20061ab5be4b9b469a7221ca12fdd9be">set</a> (<a class="el" href="classArMapInterface.html">ArMapInterface</a> *other)=0</td></tr>
<tr class="memdesc:a20061ab5be4b9b469a7221ca12fdd9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this map to be "equivalent" to the given other map.  <a href="#a20061ab5be4b9b469a7221ca12fdd9be"></a><br/></td></tr>
<tr class="memitem:a2389288fc4c29e1d380cd961877c2acd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2389288fc4c29e1d380cd961877c2acd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a2389288fc4c29e1d380cd961877c2acd">setBaseDirectory</a> (const char *baseDirectory)=0</td></tr>
<tr class="memdesc:a2389288fc4c29e1d380cd961877c2acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the base directory. <br/></td></tr>
<tr class="memitem:a60ca7573c074769719b00c3c96ec17c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a60ca7573c074769719b00c3c96ec17c4">setIgnoreCase</a> (bool ignoreCase=false)=0</td></tr>
<tr class="memdesc:a60ca7573c074769719b00c3c96ec17c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether we ignore case or not.  <a href="#a60ca7573c074769719b00c3c96ec17c4"></a><br/></td></tr>
<tr class="memitem:aa65367c7823f46fdae42d53f201699a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#aa65367c7823f46fdae42d53f201699a5">setIgnoreEmptyFileName</a> (bool ignore)=0</td></tr>
<tr class="memdesc:aa65367c7823f46fdae42d53f201699a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether we ignore empty file names or fail if we encounter one.  <a href="#aa65367c7823f46fdae42d53f201699a5"></a><br/></td></tr>
<tr class="memitem:a5774ac76e0e7dc6b47a5125bc00c2b51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5774ac76e0e7dc6b47a5125bc00c2b51"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a5774ac76e0e7dc6b47a5125bc00c2b51">setMapChangedLogLevel</a> (<a class="el" href="classArLog.html#ac8cc0fb3aa323ab2a1c21340fdd1dce3">ArLog::LogLevel</a> level)=0</td></tr>
<tr class="memdesc:a5774ac76e0e7dc6b47a5125bc00c2b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the level at which to log information about the map changed callbacks. <br/></td></tr>
<tr class="memitem:acac90c5ce18a25ecd6d08ce8116a27aa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#acac90c5ce18a25ecd6d08ce8116a27aa">setMapObjectParams</a> (const char *mapObjectName, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *params, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:acac90c5ce18a25ecd6d08ce8116a27aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the optional parameters associated with a map object.  <a href="#acac90c5ce18a25ecd6d08ce8116a27aa"></a><br/></td></tr>
<tr class="memitem:ac3226d90f6e888de43fa4ab4e86c1a52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3226d90f6e888de43fa4ab4e86c1a52"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ac3226d90f6e888de43fa4ab4e86c1a52">setQuiet</a> (bool isQuiet)=0</td></tr>
<tr class="memdesc:ac3226d90f6e888de43fa4ab4e86c1a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on this flag to reduce the number of verbose log messages. <br/></td></tr>
<tr class="memitem:ac519568cc0d2e3a87d4e7feabf04a7aa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ac519568cc0d2e3a87d4e7feabf04a7aa">setScanTypes</a> (const std::list&lt; std::string &gt; &amp;scanTypeList)=0</td></tr>
<tr class="memdesc:ac519568cc0d2e3a87d4e7feabf04a7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scan types that are defined for this map.  <a href="#ac519568cc0d2e3a87d4e7feabf04a7aa"></a><br/></td></tr>
<tr class="memitem:adc9644192ab38bd3b8a019d6e910ef42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#adc9644192ab38bd3b8a019d6e910ef42">setSourceFileName</a> (const char *sourceName, const char *fileName, bool isInternalCall=false)=0</td></tr>
<tr class="memdesc:adc9644192ab38bd3b8a019d6e910ef42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the source and the file from which the map was loaded.  <a href="#adc9644192ab38bd3b8a019d6e910ef42"></a><br/></td></tr>
<tr class="memitem:a3dbb287b9996bc395755015c6474b01c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbb287b9996bc395755015c6474b01c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a3dbb287b9996bc395755015c6474b01c">setTempDirectory</a> (const char *tempDirectory)=0</td></tr>
<tr class="memdesc:a3dbb287b9996bc395755015c6474b01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the temp directory. <br/></td></tr>
<tr class="memitem:a43cd5a39e989e99453e59fad86408897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43cd5a39e989e99453e59fad86408897"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a43cd5a39e989e99453e59fad86408897">tryLock</a> ()=0</td></tr>
<tr class="memdesc:a43cd5a39e989e99453e59fad86408897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the map instance without blocking. <br/></td></tr>
<tr class="memitem:a0f53472e8700abcc05a85b9f7a7d6820"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f53472e8700abcc05a85b9f7a7d6820"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820">unlock</a> ()=0</td></tr>
<tr class="memdesc:a0f53472e8700abcc05a85b9f7a7d6820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the map instance. <br/></td></tr>
<tr class="memitem:ade2aaba8c0a991964c2a623987a589fe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ade2aaba8c0a991964c2a623987a589fe">writeFile</a> (const char *fileName, bool internalCall=false, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0, time_t fileTimestamp=-1)=0</td></tr>
<tr class="memdesc:ade2aaba8c0a991964c2a623987a589fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the map to the specified file.  <a href="#ade2aaba8c0a991964c2a623987a589fe"></a><br/></td></tr>
<tr class="memitem:abc4e372308bbf06195dea3c0bccc93b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#abc4e372308bbf06195dea3c0bccc93b8">writeObjectsToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars, bool isOverrideAsSingleScan=false, const char *maxCategory=NULL)=0</td></tr>
<tr class="memdesc:abc4e372308bbf06195dea3c0bccc93b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the map header information and objects to a text-based functor.  <a href="#abc4e372308bbf06195dea3c0bccc93b8"></a><br/></td></tr>
<tr class="memitem:a4721211e839289dc8ab24202e07471cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a4721211e839289dc8ab24202e07471cc">writeToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars)=0</td></tr>
<tr class="memdesc:a4721211e839289dc8ab24202e07471cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all of the map to the given text-based functor.  <a href="#a4721211e839289dc8ab24202e07471cc"></a><br/></td></tr>
<tr class="memitem:ab3a168bc2130af13b415979a75e536fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3a168bc2130af13b415979a75e536fa"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ab3a168bc2130af13b415979a75e536fa">~ArMapInterface</a> (void)</td></tr>
<tr class="memdesc:ab3a168bc2130af13b415979a75e536fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="inherit_header pub_methods_classArHasFileName"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classArHasFileName')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classArHasFileName.html">ArHasFileName</a></td></tr>
<tr class="memitem:a2d0d77e077c1bebae6c11282cbb19b24 inherit pub_methods_classArHasFileName"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d0d77e077c1bebae6c11282cbb19b24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArHasFileName.html#a2d0d77e077c1bebae6c11282cbb19b24">ArHasFileName</a> ()</td></tr>
<tr class="memdesc:a2d0d77e077c1bebae6c11282cbb19b24 inherit pub_methods_classArHasFileName"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:a73b65fbf00f81d9ebfa143d5cff67d54 inherit pub_methods_classArHasFileName"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73b65fbf00f81d9ebfa143d5cff67d54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArHasFileName.html#a73b65fbf00f81d9ebfa143d5cff67d54">ArHasFileName</a> (<a class="el" href="classArHasFileName.html">ArHasFileName</a> const &amp;)</td></tr>
<tr class="memdesc:a73b65fbf00f81d9ebfa143d5cff67d54 inherit pub_methods_classArHasFileName"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="memitem:a0b921521f0a8fc48c935f9ca6cc546be inherit pub_methods_classArHasFileName"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b921521f0a8fc48c935f9ca6cc546be"></a>
<a class="el" href="classArHasFileName.html">ArHasFileName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArHasFileName.html#a0b921521f0a8fc48c935f9ca6cc546be">operator=</a> (<a class="el" href="classArHasFileName.html">ArHasFileName</a> const &amp;)</td></tr>
<tr class="memdesc:a0b921521f0a8fc48c935f9ca6cc546be inherit pub_methods_classArHasFileName"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="memitem:a0740ec1dccd9fcb923ffd5ac69c2fccd inherit pub_methods_classArHasFileName"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0740ec1dccd9fcb923ffd5ac69c2fccd"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArHasFileName.html#a0740ec1dccd9fcb923ffd5ac69c2fccd">~ArHasFileName</a> ()</td></tr>
<tr class="memdesc:a0740ec1dccd9fcb923ffd5ac69c2fccd inherit pub_methods_classArHasFileName"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="inherit_header pub_methods_classArMapInfoInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classArMapInfoInterface')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a></td></tr>
<tr class="memitem:aa2b0edebd71ed20087faf5a9b96e0e01 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2b0edebd71ed20087faf5a9b96e0e01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#aa2b0edebd71ed20087faf5a9b96e0e01">ArMapInfoInterface</a> ()</td></tr>
<tr class="memdesc:aa2b0edebd71ed20087faf5a9b96e0e01 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:a377012af07697ccb5b2d5cbff842d10c inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual std::list<br class="typebreak"/>
&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#a377012af07697ccb5b2d5cbff842d10c">getInfo</a> (const char *infoName)=0</td></tr>
<tr class="memdesc:a377012af07697ccb5b2d5cbff842d10c inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arguments for the specified info category; or NULL if none found.  <a href="#a377012af07697ccb5b2d5cbff842d10c"></a><br/></td></tr>
<tr class="memitem:a25271fd1737e048170dae5e5dc5e841a inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual std::list<br class="typebreak"/>
&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#a25271fd1737e048170dae5e5dc5e841a">getInfo</a> (int infoType)=0</td></tr>
<tr class="memdesc:a25271fd1737e048170dae5e5dc5e841a inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the strings for the specified Info category.  <a href="#a25271fd1737e048170dae5e5dc5e841a"></a><br/></td></tr>
<tr class="memitem:a4f87bdbc62656d509bdfdc638ebe9af2 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f87bdbc62656d509bdfdc638ebe9af2"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#a4f87bdbc62656d509bdfdc638ebe9af2">getInfoCount</a> () const =0</td></tr>
<tr class="memdesc:a4f87bdbc62656d509bdfdc638ebe9af2 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of info categories that are contained in this collection. <br/></td></tr>
<tr class="memitem:a7ee59537e836bd0e7cde332a6bc46140 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#a7ee59537e836bd0e7cde332a6bc46140">getInfoName</a> (int infoType)=0</td></tr>
<tr class="memdesc:a7ee59537e836bd0e7cde332a6bc46140 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the specified Info type.  <a href="#a7ee59537e836bd0e7cde332a6bc46140"></a><br/></td></tr>
<tr class="memitem:ae76435246b06fe6f967f4c2d098cd959 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#ae76435246b06fe6f967f4c2d098cd959">getInfoNames</a> () const =0</td></tr>
<tr class="memdesc:ae76435246b06fe6f967f4c2d098cd959 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the info category names that are contained in this collection.  <a href="#ae76435246b06fe6f967f4c2d098cd959"></a><br/></td></tr>
<tr class="memitem:a91d7186534412c603f6f6ac2a9e8d4f7 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual std::list<br class="typebreak"/>
&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#a91d7186534412c603f6f6ac2a9e8d4f7">getMapInfo</a> (void)=0</td></tr>
<tr class="memdesc:a91d7186534412c603f6f6ac2a9e8d4f7 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the map info strings.  <a href="#a91d7186534412c603f6f6ac2a9e8d4f7"></a><br/></td></tr>
<tr class="memitem:af8e673838d267f7831d56c7cd7822e32 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#af8e673838d267f7831d56c7cd7822e32">setInfo</a> (const char *infoName, const std::list&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *infoList, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:af8e673838d267f7831d56c7cd7822e32 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contents of the specified Info category (copies those passed in)  <a href="#af8e673838d267f7831d56c7cd7822e32"></a><br/></td></tr>
<tr class="memitem:afe493ef1948a114cbd69b22c8b0043f0 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#afe493ef1948a114cbd69b22c8b0043f0">setInfo</a> (int infoType, const std::list&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *infoList, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:afe493ef1948a114cbd69b22c8b0043f0 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contents of the specified Info category (copies those passed in)  <a href="#afe493ef1948a114cbd69b22c8b0043f0"></a><br/></td></tr>
<tr class="memitem:a04615a60f87e76efc5149c116cdc5119 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#a04615a60f87e76efc5149c116cdc5119">setMapInfo</a> (const std::list&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *mapInfo, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:a04615a60f87e76efc5149c116cdc5119 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the map info (copies those passed in)  <a href="#a04615a60f87e76efc5149c116cdc5119"></a><br/></td></tr>
<tr class="memitem:a7e6f85608759c92ed8079cd047a3ea32 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#a7e6f85608759c92ed8079cd047a3ea32">writeInfoToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars)=0</td></tr>
<tr class="memdesc:a7e6f85608759c92ed8079cd047a3ea32 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the info collection to a text-based functor.  <a href="#a7e6f85608759c92ed8079cd047a3ea32"></a><br/></td></tr>
<tr class="memitem:ae9bef84cbe069ec2619d9e80504f2059 inherit pub_methods_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9bef84cbe069ec2619d9e80504f2059"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInfoInterface.html#ae9bef84cbe069ec2619d9e80504f2059">~ArMapInfoInterface</a> ()</td></tr>
<tr class="memdesc:ae9bef84cbe069ec2619d9e80504f2059 inherit pub_methods_classArMapInfoInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="inherit_header pub_methods_classArMapObjectsInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classArMapObjectsInterface')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a></td></tr>
<tr class="memitem:a8e28fd911e2ae9e7071d7a1917b9582a inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e28fd911e2ae9e7071d7a1917b9582a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#a8e28fd911e2ae9e7071d7a1917b9582a">ArMapObjectsInterface</a> ()</td></tr>
<tr class="memdesc:a8e28fd911e2ae9e7071d7a1917b9582a inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="memitem:af7ee907155b224d7a85bdd2886fcff2e inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapObject.html">ArMapObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#af7ee907155b224d7a85bdd2886fcff2e">findFirstMapObject</a> (const char *name, const char *type, bool isIncludeWithHeading=false)=0</td></tr>
<tr class="memdesc:af7ee907155b224d7a85bdd2886fcff2e inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first map object of given name and type, or NULL if none is found.  <a href="#af7ee907155b224d7a85bdd2886fcff2e"></a><br/></td></tr>
<tr class="memitem:a0e3b929760b5898064e5d3e25796ffb9 inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapObject.html">ArMapObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#a0e3b929760b5898064e5d3e25796ffb9">findMapObject</a> (const char *name, const char *type=NULL, bool isIncludeWithHeading=false)=0</td></tr>
<tr class="memdesc:a0e3b929760b5898064e5d3e25796ffb9 inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map object of given name and type, or NULL if none is found.  <a href="#a0e3b929760b5898064e5d3e25796ffb9"></a><br/></td></tr>
<tr class="memitem:acdabca2faba0483f9eecb51354b86c92 inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; <a class="el" href="classArMapObject.html">ArMapObject</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#acdabca2faba0483f9eecb51354b86c92">findMapObjectsOfType</a> (const char *type, bool isIncludeWithHeading=false)=0</td></tr>
<tr class="memdesc:acdabca2faba0483f9eecb51354b86c92 inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all map objects of the specified type.  <a href="#acdabca2faba0483f9eecb51354b86c92"></a><br/></td></tr>
<tr class="memitem:a66394898f80b1917b5f96aa4b7a8e37c inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; <a class="el" href="classArMapObject.html">ArMapObject</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#a66394898f80b1917b5f96aa4b7a8e37c">getMapObjects</a> (void)=0</td></tr>
<tr class="memdesc:a66394898f80b1917b5f96aa4b7a8e37c inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal list of map objects.  <a href="#a66394898f80b1917b5f96aa4b7a8e37c"></a><br/></td></tr>
<tr class="memitem:ac145d6f5324b7e5a251f32907e957cc5 inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#ac145d6f5324b7e5a251f32907e957cc5">setMapObjects</a> (const std::list&lt; <a class="el" href="classArMapObject.html">ArMapObject</a> * &gt; *mapObjects, bool isSortedObjects=false, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:ac145d6f5324b7e5a251f32907e957cc5 inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the map objects (copies those passed in)  <a href="#ac145d6f5324b7e5a251f32907e957cc5"></a><br/></td></tr>
<tr class="memitem:a0a6ee2839a69de95728956f3125a2c5b inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#a0a6ee2839a69de95728956f3125a2c5b">writeObjectListToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars)=0</td></tr>
<tr class="memdesc:a0a6ee2839a69de95728956f3125a2c5b inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the list of map objects to a text-based functor.  <a href="#a0a6ee2839a69de95728956f3125a2c5b"></a><br/></td></tr>
<tr class="memitem:ada2086bd9de769074e1a1a49225d73e0 inherit pub_methods_classArMapObjectsInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada2086bd9de769074e1a1a49225d73e0"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapObjectsInterface.html#ada2086bd9de769074e1a1a49225d73e0">~ArMapObjectsInterface</a> ()</td></tr>
<tr class="memdesc:ada2086bd9de769074e1a1a49225d73e0 inherit pub_methods_classArMapObjectsInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="inherit_header pub_methods_classArMapScanInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classArMapScanInterface')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classArMapScanInterface.html">ArMapScanInterface</a></td></tr>
<tr class="memitem:ac2148e6b805f454df92629107524cc6b inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#ac2148e6b805f454df92629107524cc6b">addToFileParser</a> (<a class="el" href="classArFileParser.html">ArFileParser</a> *fileParser)=0</td></tr>
<tr class="memdesc:ac2148e6b805f454df92629107524cc6b inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds handlers for this scan data's header information to the given file parser.  <a href="#ac2148e6b805f454df92629107524cc6b"></a><br/></td></tr>
<tr class="memitem:a97ab0fd481e4adbd043a6c565a577216 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97ab0fd481e4adbd043a6c565a577216"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a97ab0fd481e4adbd043a6c565a577216">ArMapScanInterface</a> ()</td></tr>
<tr class="memdesc:a97ab0fd481e4adbd043a6c565a577216 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="memitem:aa3e8606369e3f4676492c0c320370c9f inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3e8606369e3f4676492c0c320370c9f"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getDisplayString</b> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memitem:afb1843e08cfcd465ed0e7b81bcb3a080 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#afb1843e08cfcd465ed0e7b81bcb3a080">getLineMaxPose</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:afb1843e08cfcd465ed0e7b81bcb3a080 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper right point (maximum x and y) of the scan's line segments.  <a href="#afb1843e08cfcd465ed0e7b81bcb3a080"></a><br/></td></tr>
<tr class="memitem:a73ee1150e0bae55d06c90fe12a448226 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a73ee1150e0bae55d06c90fe12a448226">getLineMinPose</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:a73ee1150e0bae55d06c90fe12a448226 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower left point (minimum x and y) of the scan's line segments.  <a href="#a73ee1150e0bae55d06c90fe12a448226"></a><br/></td></tr>
<tr class="memitem:afb236644c2df2f7f1f65c94226a029da inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#afb236644c2df2f7f1f65c94226a029da">getLines</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:afb236644c2df2f7f1f65c94226a029da inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the line segments for the specified scan.  <a href="#afb236644c2df2f7f1f65c94226a029da"></a><br/></td></tr>
<tr class="memitem:aab1cf68c7c01205c63fc7f64257d8e70 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#aab1cf68c7c01205c63fc7f64257d8e70">getMaxPose</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:aab1cf68c7c01205c63fc7f64257d8e70 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper right point (maximum x and y) of the scan's points.  <a href="#aab1cf68c7c01205c63fc7f64257d8e70"></a><br/></td></tr>
<tr class="memitem:a30c9b95c5162084dadb8602891254492 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a30c9b95c5162084dadb8602891254492">getMinPose</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:a30c9b95c5162084dadb8602891254492 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower left point (minimum x and y) of the scan's points.  <a href="#a30c9b95c5162084dadb8602891254492"></a><br/></td></tr>
<tr class="memitem:a89bc799ecce6710728ef14863fdc97b3 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a89bc799ecce6710728ef14863fdc97b3">getNumLines</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:a89bc799ecce6710728ef14863fdc97b3 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of line segments in the specified scan.  <a href="#a89bc799ecce6710728ef14863fdc97b3"></a><br/></td></tr>
<tr class="memitem:a891d5c22c516c783e947063298e34494 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a891d5c22c516c783e947063298e34494">getNumPoints</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:a891d5c22c516c783e947063298e34494 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of points in the specified scan.  <a href="#a891d5c22c516c783e947063298e34494"></a><br/></td></tr>
<tr class="memitem:a1dcd08b5cfc13ac5dc7d4b165d25bcaf inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a1dcd08b5cfc13ac5dc7d4b165d25bcaf">getPoints</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:a1dcd08b5cfc13ac5dc7d4b165d25bcaf inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the map points for the specified scan.  <a href="#a1dcd08b5cfc13ac5dc7d4b165d25bcaf"></a><br/></td></tr>
<tr class="memitem:a00e165a9f6d1accbf685fdf11bfe072e inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a00e165a9f6d1accbf685fdf11bfe072e">getResolution</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:a00e165a9f6d1accbf685fdf11bfe072e inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resolution (-1 if none specified)  <a href="#a00e165a9f6d1accbf685fdf11bfe072e"></a><br/></td></tr>
<tr class="memitem:ab832d545112db2fe6728a4c832e8dd1f inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#ab832d545112db2fe6728a4c832e8dd1f">isSortedLines</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>) const =0</td></tr>
<tr class="memdesc:ab832d545112db2fe6728a4c832e8dd1f inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the line segment vector for the specified scan is sorted.  <a href="#ab832d545112db2fe6728a4c832e8dd1f"></a><br/></td></tr>
<tr class="memitem:a96f6ecf236726619b8beca21d93b1d04 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a96f6ecf236726619b8beca21d93b1d04">isSortedPoints</a> (const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>) const =0</td></tr>
<tr class="memdesc:a96f6ecf236726619b8beca21d93b1d04 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the point vector for the specified scan is sorted.  <a href="#a96f6ecf236726619b8beca21d93b1d04"></a><br/></td></tr>
<tr class="memitem:aaf3ec826e7b3180d0ea26071e735fba9 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3ec826e7b3180d0ea26071e735fba9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#aaf3ec826e7b3180d0ea26071e735fba9">loadDataPoint</a> (double x, double y)=0</td></tr>
<tr class="memdesc:aaf3ec826e7b3180d0ea26071e735fba9 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified data point to the scan data. <br/></td></tr>
<tr class="memitem:ae19cc5a481b6c73369261a14d7c0c6e1 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19cc5a481b6c73369261a14d7c0c6e1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#ae19cc5a481b6c73369261a14d7c0c6e1">loadLineSegment</a> (double x1, double y1, double x2, double y2)=0</td></tr>
<tr class="memdesc:ae19cc5a481b6c73369261a14d7c0c6e1 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified line segment to the scan data. <br/></td></tr>
<tr class="memitem:aec0a8ac2dfc18c01f1764e80a0e4588d inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#aec0a8ac2dfc18c01f1764e80a0e4588d">readDataPoint</a> (char *line)=0</td></tr>
<tr class="memdesc:aec0a8ac2dfc18c01f1764e80a0e4588d inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a data point from the given line and adds it to this scan data.  <a href="#aec0a8ac2dfc18c01f1764e80a0e4588d"></a><br/></td></tr>
<tr class="memitem:aa0ee33dcc7cafeb818b5fc3905be0dc1 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#aa0ee33dcc7cafeb818b5fc3905be0dc1">readLineSegment</a> (char *line)=0</td></tr>
<tr class="memdesc:aa0ee33dcc7cafeb818b5fc3905be0dc1 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a line segment from the given line and adds it to this scan data.  <a href="#aa0ee33dcc7cafeb818b5fc3905be0dc1"></a><br/></td></tr>
<tr class="memitem:a3a5ad36fe57fee02deacff8b7121a9c7 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a3a5ad36fe57fee02deacff8b7121a9c7">remFromFileParser</a> (<a class="el" href="classArFileParser.html">ArFileParser</a> *fileParser)=0</td></tr>
<tr class="memdesc:a3a5ad36fe57fee02deacff8b7121a9c7 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the handlers for this scan data's header information from the given file parser.  <a href="#a3a5ad36fe57fee02deacff8b7121a9c7"></a><br/></td></tr>
<tr class="memitem:a89b013a50a0bebca595c3cc0d30dccd7 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a89b013a50a0bebca595c3cc0d30dccd7">setLines</a> (const std::vector&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; *lines, const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>, bool <a class="el" href="classArMapScanInterface.html#ab832d545112db2fe6728a4c832e8dd1f">isSortedLines</a>=false, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:a89b013a50a0bebca595c3cc0d30dccd7 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lines (copies those passed in)  <a href="#a89b013a50a0bebca595c3cc0d30dccd7"></a><br/></td></tr>
<tr class="memitem:ab195302c09f759ed475f20ab9acc9ede inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#ab195302c09f759ed475f20ab9acc9ede">setPoints</a> (const std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; *points, const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>, bool <a class="el" href="classArMapScanInterface.html#a96f6ecf236726619b8beca21d93b1d04">isSortedPoints</a>=false, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:ab195302c09f759ed475f20ab9acc9ede inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the points (copies those passed in)  <a href="#ab195302c09f759ed475f20ab9acc9ede"></a><br/></td></tr>
<tr class="memitem:adbff07c05db036ae2135a5686d23b13e inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#adbff07c05db036ae2135a5686d23b13e">setResolution</a> (int resolution, const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:adbff07c05db036ae2135a5686d23b13e inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the resolution (-1 if none specified)  <a href="#adbff07c05db036ae2135a5686d23b13e"></a><br/></td></tr>
<tr class="memitem:a56d0066fd304a1381a5b101317a437ab inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a56d0066fd304a1381a5b101317a437ab">writeLinesToFunctor</a> (<a class="el" href="classArFunctor2.html">ArFunctor2</a>&lt; int, std::vector&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; * &gt; *functor, const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>, <a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *keywordFunctor=NULL)=0</td></tr>
<tr class="memdesc:a56d0066fd304a1381a5b101317a437ab inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the map line segments to a functor.  <a href="#a56d0066fd304a1381a5b101317a437ab"></a><br/></td></tr>
<tr class="memitem:a5c66d0c8ec8e74a1cae28fb5d26545d2 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a5c66d0c8ec8e74a1cae28fb5d26545d2">writePointsToFunctor</a> (<a class="el" href="classArFunctor2.html">ArFunctor2</a>&lt; int, std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; * &gt; *functor, const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>, <a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *keywordFunctor=NULL)=0</td></tr>
<tr class="memdesc:a5c66d0c8ec8e74a1cae28fb5d26545d2 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the scan data points to a functor.  <a href="#a5c66d0c8ec8e74a1cae28fb5d26545d2"></a><br/></td></tr>
<tr class="memitem:abb744ca0073a2624cf786710dd03de33 inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#abb744ca0073a2624cf786710dd03de33">writeScanToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars, const char *scanType=<a class="el" href="ArMapInterface_8h.html#ac9bfc47ae45cd704d0c287fa69f56686">ARMAP_DEFAULT_SCAN_TYPE</a>)=0</td></tr>
<tr class="memdesc:abb744ca0073a2624cf786710dd03de33 inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method writes a text line for each of the scan header attributes (such as MinPose, MaxPose, NumPoints).  <a href="#abb744ca0073a2624cf786710dd03de33"></a><br/></td></tr>
<tr class="memitem:a31cb8d64d81abe99b086b104157b6cbc inherit pub_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31cb8d64d81abe99b086b104157b6cbc"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a31cb8d64d81abe99b086b104157b6cbc">~ArMapScanInterface</a> ()</td></tr>
<tr class="memdesc:a31cb8d64d81abe99b086b104157b6cbc inherit pub_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="inherit_header pub_methods_classArMapSupplementInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classArMapSupplementInterface')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classArMapSupplementInterface.html">ArMapSupplementInterface</a></td></tr>
<tr class="memitem:a75e349954bd7cab8ab02cbef2477afbb inherit pub_methods_classArMapSupplementInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e349954bd7cab8ab02cbef2477afbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapSupplementInterface.html#a75e349954bd7cab8ab02cbef2477afbb">ArMapSupplementInterface</a> ()</td></tr>
<tr class="memdesc:a75e349954bd7cab8ab02cbef2477afbb inherit pub_methods_classArMapSupplementInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="memitem:af88e4a2570cad93de78b6ffaea8a79d8 inherit pub_methods_classArMapSupplementInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapSupplementInterface.html#af88e4a2570cad93de78b6ffaea8a79d8">getOriginAltitude</a> ()=0</td></tr>
<tr class="memdesc:af88e4a2570cad93de78b6ffaea8a79d8 inherit pub_methods_classArMapSupplementInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the altitude of the origin; valid only if hasOriginLatLongAlt returns true.  <a href="#af88e4a2570cad93de78b6ffaea8a79d8"></a><br/></td></tr>
<tr class="memitem:a40cf90a392ae8ef708c9ef6de2a958d5 inherit pub_methods_classArMapSupplementInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40cf90a392ae8ef708c9ef6de2a958d5"></a>
virtual <a class="el" href="classArPose.html">ArPose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapSupplementInterface.html#a40cf90a392ae8ef708c9ef6de2a958d5">getOriginLatLong</a> ()=0</td></tr>
<tr class="memdesc:a40cf90a392ae8ef708c9ef6de2a958d5 inherit pub_methods_classArMapSupplementInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the latitude/longitude origin; valid only if hasOriginLatLongAlt returns true. <br/></td></tr>
<tr class="memitem:a8e20fd22020e562a213b1bd572ff6557 inherit pub_methods_classArMapSupplementInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e20fd22020e562a213b1bd572ff6557"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapSupplementInterface.html#a8e20fd22020e562a213b1bd572ff6557">hasOriginLatLongAlt</a> ()=0</td></tr>
<tr class="memdesc:a8e20fd22020e562a213b1bd572ff6557 inherit pub_methods_classArMapSupplementInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this map has an origin specified in latitude/longitude (and altitude) <br/></td></tr>
<tr class="memitem:af3019f796bc838b1d41a525f710ce9e2 inherit pub_methods_classArMapSupplementInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapSupplementInterface.html#af3019f796bc838b1d41a525f710ce9e2">setOriginLatLongAlt</a> (bool hasOriginLatLong, const <a class="el" href="classArPose.html">ArPose</a> &amp;originLatLong, double altitude, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr class="memdesc:af3019f796bc838b1d41a525f710ce9e2 inherit pub_methods_classArMapSupplementInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the latitude/longitude and altitude of the origin.  <a href="#af3019f796bc838b1d41a525f710ce9e2"></a><br/></td></tr>
<tr class="memitem:a718ef19d1c4028465dd45808e9f01427 inherit pub_methods_classArMapSupplementInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapSupplementInterface.html#a718ef19d1c4028465dd45808e9f01427">writeSupplementToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars)=0</td></tr>
<tr class="memdesc:a718ef19d1c4028465dd45808e9f01427 inherit pub_methods_classArMapSupplementInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the supplemental data to the given functor.  <a href="#a718ef19d1c4028465dd45808e9f01427"></a><br/></td></tr>
<tr class="memitem:ad2a0de4d8b9a9eab364b18e5d1baf05d inherit pub_methods_classArMapSupplementInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a0de4d8b9a9eab364b18e5d1baf05d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapSupplementInterface.html#ad2a0de4d8b9a9eab364b18e5d1baf05d">~ArMapSupplementInterface</a> ()</td></tr>
<tr class="memdesc:ad2a0de4d8b9a9eab364b18e5d1baf05d inherit pub_methods_classArMapSupplementInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aadffe2b39f07bbc856355e1b70a08be0"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#aadffe2b39f07bbc856355e1b70a08be0">createRealFileName</a> (const char *baseDirectory, const char *fileName, bool isIgnoreCase)</td></tr>
<tr class="memdesc:aadffe2b39f07bbc856355e1b70a08be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method creates a full file path name from the given components.  <a href="#aadffe2b39f07bbc856355e1b70a08be0"></a><br/></td></tr>
<tr class="memitem:a442ea3133e3c994934338d3730d1b2cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a442ea3133e3c994934338d3730d1b2cf"></a>
static std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a442ea3133e3c994934338d3730d1b2cf">getMapCategoryList</a> ()</td></tr>
<tr class="memdesc:a442ea3133e3c994934338d3730d1b2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all map categories supported by this software version. <br/></td></tr>
<tr class="inherit_header pub_static_methods_classArMapScanInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classArMapScanInterface')"><img src="closed.png" alt="-"/>&nbsp;Static Public Member Functions inherited from <a class="el" href="classArMapScanInterface.html">ArMapScanInterface</a></td></tr>
<tr class="memitem:a3d44443ed74d6fd42d7a63146b2c7c63 inherit pub_static_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d44443ed74d6fd42d7a63146b2c7c63"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a3d44443ed74d6fd42d7a63146b2c7c63">isDefaultScanType</a> (const char *scanType)</td></tr>
<tr class="memdesc:a3d44443ed74d6fd42d7a63146b2c7c63 inherit pub_static_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given scan type is the default (i.e. no prefix on the map tags) <br/></td></tr>
<tr class="memitem:ab1cf557a1fa8c18d71d5de70e8af549c inherit pub_static_methods_classArMapScanInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1cf557a1fa8c18d71d5de70e8af549c"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#ab1cf557a1fa8c18d71d5de70e8af549c">isSummaryScanType</a> (const char *scanType)</td></tr>
<tr class="memdesc:ab1cf557a1fa8c18d71d5de70e8af549c inherit pub_static_methods_classArMapScanInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given scan type represents the summary of all other scan types. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a534fc541999ac13d2afb7297458e0a28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a534fc541999ac13d2afb7297458e0a28"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_CATEGORY_2D</b> = &quot;2D-Map&quot;</td></tr>
<tr class="memitem:a8e0c7cffd95768e5eecb468ca1c116bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e0c7cffd95768e5eecb468ca1c116bc"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a8e0c7cffd95768e5eecb468ca1c116bc">MAP_CATEGORY_2D_COMPOSITE</a> = &quot;2D-Map-Ex3&quot;</td></tr>
<tr class="memdesc:a8e0c7cffd95768e5eecb468ca1c116bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated. Superset of extended; includes group objects and parent maps. <br/></td></tr>
<tr class="memitem:a0ecb554bd7784500b4495dbc8a64fb71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ecb554bd7784500b4495dbc8a64fb71"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a0ecb554bd7784500b4495dbc8a64fb71">MAP_CATEGORY_2D_EXTENDED</a> = &quot;2D-Map-Ex2&quot;</td></tr>
<tr class="memdesc:a0ecb554bd7784500b4495dbc8a64fb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superset of multi-sources; includes advanced Info types, CairnInfo and CustomInfo. <br/></td></tr>
<tr class="memitem:ad893149ccf58439c104cae7b77e01fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad893149ccf58439c104cae7b77e01fc6"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_CATEGORY_2D_MULTI_SOURCES</b> = &quot;2D-Map-Ex&quot;</td></tr>
<tr class="memitem:a0a98ba4bc3b4355dffc9c8b9bb8c86a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a98ba4bc3b4355dffc9c8b9bb8c86a6"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a0a98ba4bc3b4355dffc9c8b9bb8c86a6">MAP_CATEGORY_2D_TEMPLATE</a> = &quot;2D-Map-Ex4&quot;</td></tr>
<tr class="memdesc:a0a98ba4bc3b4355dffc9c8b9bb8c86a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superset of extended; includes group and macro templates. <br/></td></tr>
<tr class="inherit_header pub_static_attribs_classArMapInfoInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classArMapInfoInterface')"><img src="closed.png" alt="-"/>&nbsp;Static Public Attributes inherited from <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a></td></tr>
<tr class="memitem:aa457e8079e6871cdde8a1faa2140b589 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa457e8079e6871cdde8a1faa2140b589"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>CAIRN_INFO_NAME</b> = &quot;CairnInfo:&quot;</td></tr>
<tr class="memitem:aa25010ac54bf3dcc37f52c917e1cd6db inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25010ac54bf3dcc37f52c917e1cd6db"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>CUSTOM_INFO_NAME</b> = &quot;CustomInfo:&quot;</td></tr>
<tr class="memitem:a7ea055ba6917dedc71dd4fa81fde0a22 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea055ba6917dedc71dd4fa81fde0a22"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO_INFO_NAME</b> = &quot;MacroInfo:&quot;</td></tr>
<tr class="memitem:a9e9ecd1f5750dfe1e59f78d8470e5df7 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e9ecd1f5750dfe1e59f78d8470e5df7"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_INFO_NAME</b> = &quot;MapInfo:&quot;</td></tr>
<tr class="memitem:a110d07d9f631d0a442f10db8bab6ab25 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a110d07d9f631d0a442f10db8bab6ab25"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>META_INFO_NAME</b> = &quot;MetaInfo:&quot;</td></tr>
<tr class="memitem:ad19fbd8acc0ad17b80989dcc21ce9c77 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad19fbd8acc0ad17b80989dcc21ce9c77"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ROUTE_INFO_NAME</b> = &quot;RouteInfo:&quot;</td></tr>
<tr class="memitem:aae64bff4e830279cdb33996b21e2e3f0 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae64bff4e830279cdb33996b21e2e3f0"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>SCHED_INFO_NAME</b> = &quot;SchedInfo:&quot;</td></tr>
<tr class="memitem:a81301565faf511a94e795c021df79758 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81301565faf511a94e795c021df79758"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>SCHED_TASK_INFO_NAME</b> = &quot;SchedTaskInfo:&quot;</td></tr>
<tr class="memitem:ab7f972070c029ded9a888accda522229 inherit pub_static_attribs_classArMapInfoInterface"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7f972070c029ded9a888accda522229"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>TASK_INFO_NAME</b> = &quot;TaskInfo:&quot;</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> defines the methods that are available on all <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> maps. </p>
<p>These maps represent the operating space of a robot, and can be used for space searching, localizing, navigating etc. The types of data stored in a map include sensable obstacles (e.g. walls and furniture in a room) represented either as a collection of data points (similar to a raster or bit map, useful for high resolution sensors like a laser), or lines (a vector map, useful for low resolution sensors like the sonar), goals, and other points or regions of interest ("map objects").</p>
<p>The methods in <a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> can be broadly categorized as follows:</p>
<ul>
<li>Scan Methods: These provide access the sensable obstacles that are represented as a collection of data points or lines. These are typically generated during the scanning process (i.e. the creation of the .2d file). If more than one sensor is used, then the data is organized on a per-sensor basis. The scan methods are grouped into the <a class="el" href="classArMapScanInterface.html" title="Methods related to setting and retrieving the scan-related data in an Aria map.">ArMapScanInterface</a>.</li>
<li>Object Methods: These provide access to the "high-level" objects in the environment. Such objects include goals, docks, forbidden areas, and other user-defined points of interest. They may also include special data objects that are actually part of the operating environment and are generally added automatically and are not editable by the user. The object methods are grouped into the <a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a>.</li>
<li>Info Methods: A wide variety of supporting information is included in various "info" categories. This includes definitions for the types of map objects that can be stored in the map. It also includes various optional features such as macros and schedules. The info methods are grouped into the <a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an Aria map.">ArMapInfoInterface</a>.</li>
<li>Extra Data Methods: These are essentially the "leftovers" &ndash; i.e. methods that are related directly to map data but which do not fit into any of the above categories. They are defined in the <a class="el" href="classArMapSupplementInterface.html" title="Methods related to miscellaneous extra data in an Aria map.">ArMapSupplementInterface</a>.</li>
<li>Callback Methods: Users of the <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map may install callbacks onto the map in order to be notified when the map contents has changed. These methods are defined below.</li>
<li>File and I/O Methods: Methods to read and write map files are also included below. In addition, the MD5 checksum of the map contents may be calculated.</li>
</ul>
<p>TODO:</p>
<ul>
<li>Possibly make the calculation of checksums optional? </li>
</ul>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a456c9419ae512d319935e4f9ba482de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a456c9419ae512d319935e4f9ba482de5a40732d41ab529094aace100632e2c16b"></a>MAX_MAP_NAME_LENGTH</em>&nbsp;</td><td>
<p>Maximum length of the map file's name. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4473ac4e92936dab506739e7a20b9810"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArMapInterface::addMapChangedCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<p>This method is just a wrapper for compatibility, the one that takes position as an integer is the main one that should be used now.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f72e43ccdc17ca9ace947b0cd6a3647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addMapChangedCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL</td></tr>
    <tr><td class="paramname">position</td><td>this indicates the order in which the functors will be called, the nominal range is 0 to 100, highest is called first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a7e9be6f6d788181f5293637cf6ee57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArMapInterface::addMapChangedLocalizationCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback for localization that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<p>This method is just a wrapper for compatibility, the one that takes position as an integer is the main one that should be used now.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea58cfcaa05e4669b26b0392108cf789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addMapChangedLocalizationCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback for localization that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL</td></tr>
    <tr><td class="paramname">position</td><td>this indicates the order in which the functors will be called, the nominal range is 0 to 100, highest is called first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fb84a87631988abd346361c01aff86e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArMapInterface::addMapChangedPathPlanningCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback for pathplanning that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<p>This method is just a wrapper for compatibility, the one that takes position as an integer is the main one that should be used now.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26c4f9660334ebcd3133de605c46c2ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addMapChangedPathPlanningCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback for path planning that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL</td></tr>
    <tr><td class="paramname">position</td><td>this indicates the order in which the functors will be called, the nominal range is 0 to 100, highest is called first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40d8eea550274935ff957b93f340dc60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addPostWriteFileCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback to be invoked after the map file is written. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be added </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> that specifies whether the callback should be added at the front or the back of the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68292e93e05b174ee8f35ee5cd11403b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArMapInterface::addPreMapChangedCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback called before the map changed callbacks are called. </p>
<p>The "pre-map-changed callbacks" are invoked <em>after</em> the map has been changed, but before the other "map-changed callbacks" are invoked. This method is not thread-safe.</p>
<p>This method is just a wrapper for compatibility, the one that takes position as an integer is the main one that should be used now.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list)</td></tr>
  </table>
  </dd>
</dl>
<p><b>Java and Python Wrappers:</b> call as addPreMapChangedCBPos() if passing an <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos.Pos</a> object for <em>position</em> rather than an int </p>

</div>
</div>
<a class="anchor" id="a7be484cdd56bc5610073ea7a70824c75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addPreMapChangedCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback called before the map changed callbacks are called. </p>
<p>The "pre-map-changed callbacks" are invoked <em>after</em> the map has been changed, but before the other "map-changed callbacks" are invoked. This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL</td></tr>
    <tr><td class="paramname">position</td><td>this indicates the order in which the functors will be called, the nominal range is 0 to 100, highest is called first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb19d9b10f3d7927c5d2be759e4b99a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addPreParseFileCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified "pre-map-parse callback" with the map format as string. </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to be added; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b1e1bc876eba9f442f170449b79f69e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addPreWriteFileCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback to be invoked before the map file is written. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be added </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> that specifies whether the callback should be added at the front or the back of the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11d230f4851af9cd23683ec1b425f7e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::calculateChecksum </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>md5DigestBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>md5DigestBufferLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the checksum of the map. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">md5DigestBuffer</td><td>the unsigned char buffer in which to store the calculated checksum </td></tr>
    <tr><td class="paramname">md5DigestBufferLen</td><td>the length of the md5DigestBuffer; should be <a class="el" href="classArMD5Calculator.html#aeca285eb7c968becf9d4a61f68fd740da1c49adf9388dec84457b4f47ec6a0cbb" title="Number of bytes in the checksum buffer.">ArMD5Calculator::DIGEST_LENGTH</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>bool true if the checksum was successfully calculated; false if an error occurrred </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors.">ArMD5Calculator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc68f5bb2b270a3621206c0bb60de750"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapInterface.html">ArMapInterface</a>* ArMapInterface::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new map that is "equivalent" to this map. </p>
<p>Creates a new map that is effectively a copy of this map. Note, however, that the returned map may not be of exactly the same class (so the term "clone" is being used somewhat loosely). In particular, if the active <a class="el" href="classArMap.html" title="A map of a two-dimensional space the robot can navigate within, and which can be updated via the Aria...">ArMap</a> that is associated with the robot configuration is cloned, then the resulting map will be simpler and not associated with the robot configuration. </p>
<dl class="section return"><dt>Returns:</dt><dd><a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> * a new copy of this map </dd></dl>
<p><b>Java Wrapper Library:</b> Use cloneMap() instead </p>

</div>
</div>
<a class="anchor" id="aadffe2b39f07bbc856355e1b70a08be0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ArMapInterface::createRealFileName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isIgnoreCase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method creates a full file path name from the given components. </p>
<p>Determines what system file path to use based on the contents of <em>baseDirectory</em>, <em>fileName</em> and <em>isIgnoreCase</em>.</p>
<p>If <em>fileName</em> is not an absolute path and <em>baseDirectory</em> is not null and not empty, then it is combined with <em>baseDirectory</em> to form a full path. An absolute path starts with the '/' or '\' character, or on Windows, with "X:\" where X is any upper or lower case alphabetic character A-Z or a-z. </p>

</div>
</div>
<a class="anchor" id="a69999157a3713d4ada7d47f6a3087b73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a>* ArMapInterface::findMapObjectParams </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mapObjectName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the optional parameters associated with a map object, or NULL if none. </p>
<p>The <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map provides an advanced feature that allows a parameter list to be defined for custom map object types. (Refer to the <a class="el" href="classArMap.html" title="A map of a two-dimensional space the robot can navigate within, and which can be updated via the Aria...">ArMap</a> MapFileFormat for more information.)</p>
<p>This convenience method provides access to the parameter values for a specified map object. It is basically a shortcut for searching and parsing the CairnInfo argument list. Unlike the CairnInfo arguments (which also include an introduction and map object name), the argument builder returned by this method only contains the parameter values. Also note that if the argument builder contains string parameters, then they may be surrounded by quotes.</p>
<p>The returned pointer should not be stored, modified, or deleted.</p>
<p>See setMapObjectParams for important information about changing the parameter values or the associated map object.</p>
<p>This method is not thread-safe. (The call and use of the returned <a class="el" href="classArArgumentBuilder.html" title="This class is to build arguments for things that require argc and argv.">ArArgumentBuilder</a> should be surrounded by calls to <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>/unlock().)</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapObjectName</td><td>the unique char * name of the map object whose parameters are to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd><a class="el" href="classArArgumentBuilder.html" title="This class is to build arguments for things that require argc and argv.">ArArgumentBuilder</a> * a pointer to the map object's parameter values; </dd></dl>

</div>
</div>
<a class="anchor" id="abd35c2a4363d41c6633fd064a45188bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::getIgnoreCase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether we ignore case or not. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="ae71fec67708492f07fe4cf88fe5bd570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::getIgnoreEmptyFileName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether we ignore empty file names or fail if we encounter one. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="af71351c58a7c772b852002babf282220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a>* ArMapInterface::getInactiveInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides direct access to the inactive map info. </p>
<p>The "inactive" info is a section of the <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that applications may use to store "_XInfo:" lines that are not currently active or applicable. The inactive info will be written to the map file, but it will not be included in any of the inherited <a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an Aria map.">ArMapInfoInterface</a> calls (e.g. getInfo(type)). This is primarily intended for advanced specialized use where something needs to be removed from the map file, but it may be necessary to restore it later. This method is not thread-safe. </p>
<dl class="section return"><dt>Returns:</dt><dd><a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an Aria map.">ArMapInfoInterface</a> * a pointer to the inactive map info section </dd></dl>

</div>
</div>
<a class="anchor" id="a06520aefeb5654a4b4adae7f4b5c0e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a>* ArMapInterface::getInactiveObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides direct access to the inactive map objects. </p>
<p>The "inactive" objects is a section of the <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that applications may use to store "_Cairn" lines that are not currently active or applicable. The inactive objects will be written to the map file, but they will not be included in any of the inherited <a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a> calls (e.g. <a class="el" href="classArMapObjectsInterface.html#a66394898f80b1917b5f96aa4b7a8e37c" title="Returns a pointer to the internal list of map objects.">getMapObjects()</a>). This is primarily intended for advanced specialized use where an object needs to be removed from the map file, but it may be necessary to restore it later. This method is not thread-safe. </p>
<dl class="section return"><dt>Returns:</dt><dd><a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a> * a pointer to the inactive map objects section </dd></dl>

</div>
</div>
<a class="anchor" id="a42438b0cdb01d4f1613b05dcaa8bae60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::getMapId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArMapId.html">ArMapId</a> *&#160;</td>
          <td class="paramname"><em>mapIdOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInternalCall</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the map ID. </p>
<p>The map ID is a unique identifier based on the map file name and the checksum data. (Perhaps more accurately, it is highly likely to be unique during normal usage.) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapIdOut</td><td>a pointer to the <a class="el" href="classArMapId.html" title="Enapsulates the data used to uniquely identify an Aria map.">ArMapId</a> to be set </td></tr>
    <tr><td class="paramname">isInternalCall</td><td>a bool set to true only when getMapId is called within the context of a method that has already locked the map; if false, then the map is locked by this method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>bool true if the map ID was successfully set; false, otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab9736c0a90ec57e51b3415ef787de861"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual struct stat ArMapInterface::getReadFileStat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about the map file that was read. </p>

<p>Implemented in <a class="el" href="classArMapSimple.html#aa4905db6761bbdad452da8e08f1ca871">ArMapSimple</a>, and <a class="el" href="classArMap.html#a0413938cf922ff7f52e31b42fbbabfee">ArMap</a>.</p>

</div>
</div>
<a class="anchor" id="a33d5f7c640ead8c14268379b35d5cbe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt;<a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&gt;* ArMapInterface::getRemainder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of the map file lines that were not recognized. </p>
<p>Ideally, the returned list should be empty. The remainder list is primarily used to determine whether the editor is up-to-date for the current map version and to try to minimize lost data.</p>
<p>Note that this method returns a pointer to the actual list that is stored in the map object. It is not safe to store this pointer.</p>
<p>This method is not thread-safe. </p>

</div>
</div>
<a class="anchor" id="af1c75dac69881ba57ffd7826dd600a32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt;std::string&gt; ArMapInterface::getScanTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of the scan types that are defined for this map. </p>
<p>This method is not thread-safe.</p>
<dl class="section return"><dt>Returns:</dt><dd>std::list&lt;std::string&gt; a list of the scan types that are defined for this map </dd></dl>

</div>
</div>
<a class="anchor" id="a660969c77405c2795a47ce58f0625977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::isLoadingDataStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value returns true once the first DATA tag has been reached. </p>
<p>The rest of the map contains data points. </p>

</div>
</div>
<a class="anchor" id="a6d2628ce711c2d6774746586932f7913"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::isLoadingLinesAndDataStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value returns true once the first LINES tag has been reached. </p>
<p>The rest of the map contains data lines and points. </p>

</div>
</div>
<a class="anchor" id="a00f12f15367b9c97592b0f45fda2fc2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::mapChanged </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that will call the map changed CBs if needed. </p>
<p>Users of <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> maps should invoke this method after making any changes to the map. It causes the installed map changed handlers to be invoked.</p>
<p>This method is not thread-safe. It should be surrounded by calls to <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a>. For example:</p>
<p><code> std::list&lt;ArMapObject*&gt; newMapObjects; // Add some objects... myMap-&gt;<a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>; myMap-&gt;setMapObjects(&amp;newMapObjects); myMap-&gt;<a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a>; myMap-&gt;<a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a>; </code></p>
<p>Note that this method is automatically invoked under some circumstances (such as when the map file is re-read following a change to the robot configuration). Also note that this method will not invoke any callbacks if the map has not been modified via an explicit call to a set method.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classArMapInterface.html#a4473ac4e92936dab506739e7a20b9810" title="Adds a callback that is invoked when the map has been changed.">addMapChangedCB</a> </dd>
<dd>
<a class="el" href="classArMapInterface.html#a68292e93e05b174ee8f35ee5cd11403b" title="Adds a callback called before the map changed callbacks are called.">addPreMapChangedCB</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a5270bda8f803df83079940ac6e15e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::parseLine </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Public for ArQMapProducer. </p>
<p>Parses a map line </p>

</div>
</div>
<a class="anchor" id="a9ec33c9ef77c8d6fcd6f68b33d0385d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::readFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errorBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errorBufferLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>md5DigestBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>md5DigestBufferLen</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the map from the specified file. </p>
<p>If the file is successfully read into the map, then this method calls <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> afterwards to invoke the installed callbacks.</p>
<p>This method automatically calls <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a> during operation. Do not call this method if the map is already locked.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>the name of the file to read; Unless an absolute path to a file is given (starting with "/" or "\" or, on Windows, a drive letter root such as "C:\", "D:\", etc.), it is combined with this map's base directory (see <a class="el" href="classArMapInterface.html#a6a75aadc1642ea9f8f6004c09fa94306" title="Gets the base directory.">getBaseDirectory()</a>) to form the complete file path name; must be non-NULL </td></tr>
    <tr><td class="paramname">errorBuffer</td><td>a pointer to a char buffer in which specific read errors can be recorded; if NULL, then the return value is the only success indication </td></tr>
    <tr><td class="paramname">errorBufferLen</td><td>the size_t of the error buffer </td></tr>
    <tr><td class="paramname">md5DigestBuffer</td><td>an optional pointer to a buffer in which to store the calculated checksum of the map; if NULL, then the checksum is not output </td></tr>
    <tr><td class="paramname">md5DigestBufferLen</td><td>the size_t of the checksum buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>bool true if the file was successfully read and the map was populated; false if an error occurred </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors.">ArMD5Calculator</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMap.html#a41309477c89bc6ee5a8c90c46cc3ab5b">ArMap</a>.</p>

</div>
</div>
<a class="anchor" id="a412f9906797ed2e34e6d4589033e3d80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the map file needs to be re-read. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. It checks to see if the map file has been modified since it was read, and re-reads it if necessary. The method may do nothing for "simpler" maps. </p>

</div>
</div>
<a class="anchor" id="a65da492e1379f9a9d226b552a2be65d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remMapChangedCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a callback called when the map has been changed. </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3db05cc87cb3bb4dcd090bc1c4a03d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remMapChangedLocalizationCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a callback for localizationcalled when the map has been changed. </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9922debd656da46d9a2bad95a58f954e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remMapChangedPathPlanningCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a callback for path planning called when the map has been changed. </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80f3ea46ca3969d4eaf6253b39c84f5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remPostWriteFileCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given callback from the list of post-write callbacks. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0563d1953c0795a0ee85ebb2a7c9b13c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remPreMapChangedCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified "pre-map-changed callback". </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2551259120e6668c9f8cbed15516506f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remPreParseFileCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified "pre-map-parse callback" with the map format as string. </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to be remove; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44fbadba38009509c473ca622a59b8b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remPreWriteFileCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given callback from the list of pre-write callbacks. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20061ab5be4b9b469a7221ca12fdd9be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArMapInterface.html">ArMapInterface</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this map to be "equivalent" to the given other map. </p>
<p>Modifies this map so that is effectively a copy of the given map. All info, objects, and data points and lines in the other map are copied and stored in this map. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a pointer to the <a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> to be copied; must not be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>bool true if the map was successfully copied to this one; false if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a60ca7573c074769719b00c3c96ec17c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::setIgnoreCase </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether we ignore case or not. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="aa65367c7823f46fdae42d53f201699a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::setIgnoreEmptyFileName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether we ignore empty file names or fail if we encounter one. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="acac90c5ce18a25ecd6d08ce8116a27aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::setMapObjectParams </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mapObjectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *&#160;</td>
          <td class="paramname"><em>changeDetails</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the optional parameters associated with a map object. </p>
<p>This method sets the parameter values for the specified map object. It should be used only for custom map object types that have a parameter list defined in the MapInfo. (Refer to the <a class="el" href="classArMap.html" title="A map of a two-dimensional space the robot can navigate within, and which can be updated via the Aria...">ArMap</a> MapFileFormat for more information.)</p>
<p>Like <a class="el" href="classArMapInterface.html#a69999157a3713d4ada7d47f6a3087b73" title="Returns the optional parameters associated with a map object, or NULL if none.">findMapObjectParams()</a>, this is basically a convenience method that simplifies access to the data stored in the CairnInfo argument list.</p>
<p>If the given params is non-NULL, then it is copied and stored in the map. (Note that this deletes the pointer previously returned by findMapObjectParams(mapObjectName). Do not store that pointer.) It is entirely the caller's responsibility to ensure that the params arg count and types are correct.</p>
<p>If the given params is NULL, then the parameter information for the map object is cleared. If a mapObjectWithParams is to be deleted, then setMapObjectParams(mapObjectWithParams-&gt;getName(), NULL) must be called first.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapObjectName</td><td>the unique char * name of the map object whose parameters are to be updated </td></tr>
    <tr><td class="paramname">params</td><td>the ArArgumentBuiler * containing the new parameter values; if NULL, then the parameter information for the map object is deleted </td></tr>
    <tr><td class="paramname">changeDetails</td><td>an optional pointer to the <a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> in which to accumulate a description of the changes to the map; if NULL, then changes are not tracked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMapSimple.html#a9b3beb8b640bec38f6db16c63fd11232">ArMapSimple</a>.</p>

</div>
</div>
<a class="anchor" id="ac519568cc0d2e3a87d4e7feabf04a7aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::setScanTypes </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>scanTypeList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scan types that are defined for this map. </p>
<p>This method clears all of the exisiting scans (i.e. point and line data). This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">scanTypeList</td><td>the list of scan type string identifiers to be set; the list must not contain any duplicate entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>bool true if the scan types were successfully set; false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adc9644192ab38bd3b8a019d6e910ef42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::setSourceFileName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInternalCall</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the source and the file from which the map was loaded. </p>
<p>This method is primarily used to track when a map has been received from the central server or another robot. The source and file name can be retrieved from the map ID. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceName</td><td>the const char * name of the central server or robot from which the map was obtained </td></tr>
    <tr><td class="paramname">fileName</td><td>the const char * name of the map file on the source </td></tr>
    <tr><td class="paramname">isInternalCall</td><td>a bool set to true if this method is being called while the map is locked; if false, then this method will lock the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade2aaba8c0a991964c2a623987a589fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::writeFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalCall</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>md5DigestBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>md5DigestBufferLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>fileTimestamp</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the map to the specified file. </p>
<p>By default, this method automatically calls <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a> during its operation. If the map is already locked when the file needs to be written, then set the internalCall parameter to true to override the default locking behavior</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>the const char * name of the file to written; it is combined with the <a class="el" href="classArMapInterface.html#a6a75aadc1642ea9f8f6004c09fa94306" title="Gets the base directory.">getBaseDirectory()</a> to form the complete file path name; must be non-NULL </td></tr>
    <tr><td class="paramname">internalCall</td><td>a bool set to true if writeFile is being called while the map is already locked; set to false to indicate that the map should lock itself during the method </td></tr>
    <tr><td class="paramname">md5DigestBuffer</td><td>an optional pointer to a buffer in which to store the calculated checksum of the map; if NULL, then the checksum is not output </td></tr>
    <tr><td class="paramname">md5DigestBufferLen</td><td>the size_t of the checksum buffer </td></tr>
    <tr><td class="paramname">fileTimestamp</td><td>the time_t to which to set the file write time; in general, this should be left as -1 to indicate that the actual write time is desired; a real time value can be used to synchronize the map across many robots </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>bool true if the file was successfully written; false if an error occurred </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors.">ArMD5Calculator</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMap.html#a3922ae9a351c1739a24d9247f7db1cc5">ArMap</a>.</p>

</div>
</div>
<a class="anchor" id="abc4e372308bbf06195dea3c0bccc93b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::writeObjectsToFunctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>endOfLineChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOverrideAsSingleScan</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>maxCategory</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the map header information and objects to a text-based functor. </p>
<p>This method writes all of the map scan headers, the info arguments, and the Cairn map objects to the given functor. It does not write the actual scan point or line segment data (nor the header lines that introduce the data). This method is not thread-safe.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to which to write the map header as text lines </td></tr>
    <tr><td class="paramname">endOfLineChars</td><td>the const char * string to use as an end-of-line indicator </td></tr>
    <tr><td class="paramname">isOverrideAsSingleScan</td><td>a bool set to true if only a single scan header should be written; this is generally the "summary scan" and is used to maintain backwards compatibility with client applications that do not expect multiple scan types in a single map. </td></tr>
    <tr><td class="paramname">maxCategory</td><td>if given, limit map category </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4721211e839289dc8ab24202e07471cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::writeToFunctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>endOfLineChars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes all of the map to the given text-based functor. </p>
<p>This method is not thread-safe </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to which to write the map header as text lines </td></tr>
    <tr><td class="paramname">endOfLineChars</td><td>the const char * string to use as an end-of-line indicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ArMapInterface_8h.html">ArMapInterface.h</a></li>
<li>ArMapInterface.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classArMapInterface.html">ArMapInterface</a></li>
    <li class="footer">Generated on Wed Nov 15 2017 12:04:26 for Aria by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1 </li>
  </ul>
</div>
</body>
</html>
