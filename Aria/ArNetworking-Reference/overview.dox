/**
   \mainpage ArNetworking

   MobileRobots <b>Advanced Robotics Networking Infrastructure (ArNetworking)</b>
   Developer's API Reference Manual<br>
   Copyright 2005 ActivMedia Robotics, LLC. All rights reserved.<br>
   Copyright 2006, 2007, 2008, 2009, 2010 MobileRobots Inc. All rights reserved.<br>
   Copyright 2011, 2012, 2013, 2014, 2015 Adept Technology. All rights reserved.


   ArNetworking is an extensible networking protocol and infrastructure. It
   is used to add networking services to a robot control program, integrated
   with ARIA and other MobileRobots software libraries.

   For a list of requests clients can send to servers, with example code of
   making request, receiving replies, and how a server can respond to 
   requests, see @ref
   RemoteRequestAPI. For more description of how ArNetworking works and what is
   included in the ArNetworking library, see below.

   @tableofcontents

   @section overviewintro Introduction

   ArNetworking is used in a client-server architecture. A client
   issues <i>requests</i> to a server to issue a single command the server,
   or to start retrieving data from the server at a specified time interval.
   A request type is identified by a short string.

   A client may be an operator's graphical interface, or a component requiring
   off-board resources (such as a multi-robot planning system, for example).
   However, a program onboard the robot could also implement a client, and issue
   requests to an offboard server (e.g. to retrieve data from a central database).
   It is also possible for an ArNetworking server to also include a client
  interface, for example to relay data (e.g. sensor or image data received and
  processed by a second computer).

   In a typical application, however, a program acting as the server runs on the robot's
   computer, and uses ARIA (and possibly ARNL or SONARNL) to control the robot.
   This creates a three-tier system: the robot itself is the first tier, and acts as a
   "robot server" to a program on its onboard computer which is simultaneously a
   "robot client" and an "ArNetworking server".  Offboard ArNetworking clients are the final
   tier.  This three-tier architecture allows a tight, reliable control loop between the robot
   control program on the onboard computer, and removes higher level user-interface clients
   accross the potentially unreliable network, protecting the more critical robot control program,
   and providing a more immediate and flexible user interface.

   ArNetworking can use both TCP and UDP.


   \image html ArNetworking_overview.png Abstract overview of ArNetworking in a typical client-server configuration with one client issuing requests to a server

   \section Servers Servers

   An ArNetworking server program is comprised of an ArServerBase object, to which
   callback functors are added for each request type you wish to handle
   using ArServerBase::addData(), or an ArServerDataProvider object.
   These callbacks or provider objects are often encapsulated in handler classes.
   The ArNetworking library provides a variety of prewritten classes for
   providing current state information about the robot and devices, for teleoperation
   control, and more (these are classes in the ArNetworking library typically
   beginning with the prefix ArServerHandler... or ArServerInfo...)    

   ArServerBase creates a background thread to asyncronously accept client connections
   and receive clients' requests, while your main program thread executes simultaneously.
   (This thread runs in a loop, and you may add general-purpose callback functors
   to be invoked each cycle of this loop using ArServerBase::addCycleCallback(),
   if desired. This is useful since these callbacks are invoked within the
   server's thread.)

   An ArServerDataProvider object handles requests from clients, obtains a 
   simple value or list of values from a user-supplied callback or pointer, 
   and sends the value to the client as a reply. See documentation for
   ArServerDataProvider for more details.

   You can also directly handle requests yourself, if you need to parse
   arguments provided with the client's request, or to assemble a reply packet
   which is more complex than can be handled automatically by ArServerDataProvider.
   A callback functor for a request, when invoked, receives an ArNetPacket
   object containing the request's payload data, and a pointer
   to an object used to send a reply packet to the client.

   To simplify server program setup, a helper class ArServerSimpleOpener is available.

   The default port number for an ArServerBase object to open is 7272, though
   an alternate port number may be used via a command line argument to the program,
   or specified in the ArServerBase constructor.

   For a concise list of all requests handled by various server classes in
   ArNetworking, see @ref RemoteRequestAPI.

   \subsection ServerModes Server Modes

   ArNetworking also provides a system of robot control mode classes (see ArServerMode
   base class).   The server may only be in one mode at a time, each of which
   enables and disables ARIA ArAction objects.

   \subsection SimpleServerCommands Simple Server Commands

   ArNetworking includes the ArServerHandlerCommands class that provides a very
   simple API for simple "command" requests: requests, perhaps with a few
   parameters, that simply perform some action or change some state, and have
   no data to reply with.    Callback functors added for requests via
   an ArServerHandlerCommands object do not receive the request packet data, so they
   do not need to do any decoding of that data. Additionally, ArServerHandlerCommands
   keeps a list of requests that it manages, which is available to clients.
   ArNetworking includes some prewritten classes (ArServerSimpleCom*) which
   simply add new commands to an ArServerHandlerCommands object and encapsulate their
   request callbacks.

   For example, MobileEyes queries this list on
   connection, and if some of these simple
   commands are available, it makes a menu in the toolbar called Custom Commands
   accessible.  This is a way to make special features of your custom robot server
   application controllable from MobileEyes.

   \subsection ARNLServerClasses Networking in ARNL and SONARNL

   The ARNL and SONARNL libraries contain some ServerHandler/ServerInfo classes
   that implement useful server requests, as well as server Mode classes.

   \subsection PreMadeServices Standard Services Available in ArNetworking

   These are some of the pre-written services which are available in the ArNetworking
   library for you to use in your server programs.  To use these services, your
   server program typically only needs to create and retain an instance of the class,
   though some require some additional setup.

   For a concise list of all requests handled by various server classes in
   ArNetworking, see @ref RemoteRequestAPI.

   <ul>
    <li>ArServerInfoRobot - Supplies clients with basic robot state information (current position and velocity, active server mode and status, battery voltage)</li>
    <li>ArServerInfoSensor - Supplies clients with current sensor readings (Sonar or Laser)</li>
    <li>ArServerHandlerMap - Supplies clients with data from an ArMap</li>
    <li>ArServerInfoDrawings - Supplies clients with a set of graphical figures to be displayed with the map (e.g. point sets, lines, circles)</li>
    <li>ArServerHandlerCamera - Allows clients to control a pan-tilt camera and provides information about its current position</li>
    <li>ArServerInfoStrings - A set of general purpose key,value string pairs obtained from a global table (See Aria::getInfoGroup())</li>
    <li>ArServerHandlerMapping - Allows clients to trigger collection of laser scan data for use in making a map later (with the Mapper3 application)</li>
    <li>ArServerFileToClient, ArServerFileFromClient, ArServerFileLister - Allows clients to upload and download files from the server filesystem</li>
   </ul>


   \section Clients Clients

   A client program is comprised of an ArClientBase object which must be connected
   to a server via a network socket (either TCP or the default, UDP). The server is
   identified by network hostname and port number, which may be given
   through ArClientBase API or in the program command line arguments. Requests
   are made to the server via ArClientBase::request(),
   ArClientBase::requestOnce(), or using an ArClientDataReceiver object.

   If an ArClientDataReceiver object is used, it will make requests at a
   specified interval, receive
   any replies, automatically parse some simple data types provided in the
   reply from the server, and call a user-supplied callback function, or just
   store the value(s).   See documentation for ArClientDataReceiver for more
   details.

   You can also directly make requests and handle reply packets yourself, if
   you need to parse a reply packet that is more complex than can be handled
   automatically by ArClientDataReciver.  

   ArClientBase creates a background thread to asyncronously communicate with the server.

   A client may query a server to discover if a data request type is available using
   ArClientBase::dataExists().

   To simplify client program setup and connection to a server, a helper class
   ArClientSimpleConnector is available.

   For a concise list of all requests handled by various server classes in
   ArNetworking, see @ref RemoteRequestAPI.

   See example programs in the examples directory for complete example programs.


**/

